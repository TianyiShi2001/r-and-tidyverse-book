---
nocite: |
  @Gentleman2009R-Programming-Bioinfo
---

# R中的数据，逻辑，和函数 {#vectors-logicals-and-functions}

### 本章内容速览 {-#intro-overview-vector}

- 第\@ref(vector-section)节介绍了R中向量的概念，使用方法和优越性。
  - \@ref(create-vector)：向量的创建（赋值）和合并
  - \@ref(indexing)：向量的索引（indexing）和取子集（subsetting）
  - \@ref(generator)：生成有序数列（连续整数，重复数/重复向量，
  - \@ref(vector-misc)：向量的其它操作
  - \@ref(vectorization-basics)：向量的优越性——向量化计算概念基础
- 第\@ref(data-types)节介绍了R中的数据/对象类型
  - \@ref(data-types-basics)：如何查看数据/对象的类型；最基础的5种（atomic vector所存储的）数据类型；其它常用数据/对象类型
  - \@ref(data-types-advanced)：数据类型详解；更多的数据类型
- 第\@ref(math)节介绍了R中的数学规则
  - \@ref(math-notation)：数的表达；整数，浮点数，科学计数法
  - \@ref(arithmetic)：基础的数学运算
  - \@ref(statistics)：基础的统计学计算，包括t分布，t检验，卡方检验
- 第\@ref(list)节介绍了R中列表 (list)的性质和使用方法。
- 第\@ref(matrix-array)节介绍了R中矩阵 (matrix)和数组 (array)的性质和使用方法。
- 第\@ref(logical-operation)节介绍了R中逻辑值(`TRUE`, `FALSE`, `NA`)的概念和玩法。
- 第\@ref(control-flow)届介绍了R中的流程控制和`apply()`族函数
- 第\@ref(functions)节介绍了R中的函数的定义和使用。


*注意，R中的变量名/自定义函数名不能以数字和特殊符号开头，中间只能使用"_"和"."作为特殊符号*[^naming]

[^naming]: 如果一定要违反规则，可以使用转义符号`\``，比如可以`` `4foo%b=a+r` <- 50 ``


## 向量的概念，操作和优越性 {#vector-section}

R使用各种类型的向量 (vector)来存储单一类型的数据。

### 创建向量（赋值）{#create-vector}

单元素的向量，可以直接像这样赋值：

```{r}
x <- 2
x
```

要创建一个多元素的向量，需要用到`c()` (concatenate)函数：

```{r}
nums <- c(1,45,78)
cities <- c("Zürich", "上海", "Tehrān")
nums
cities
```

通过`length()`函数，可以查看向量的长度。

```{r linewidth=60}
length(nums)
#如果无后续使用，没必要赋值一个变量；c(...)的计算结果就是一个向量，并直接传给`length()`函数
length(c("Guten Morgen")) 
```

（每个被引号包围的一串字符，都只算做一个元素，因此长度为1；多元素的向量请看第\@ref(create-vector)节）

还是通过`c()`函数，可以把多个向量拼接成一个大向量：

```{r}
cities_1 <- c("Zürich", "上海", "Tehrān")
cities_2 <- c("大阪", "Poznań", "Cairo")

cities <- c(cities_1, cities_2, c("Jyväskylä", "邯郸", "札幌่"))

cities
```

### 索引/取子集/子集重新赋值 (indexing/subsetting) {#indexing}

索引 (index)就是一个元素在向量中的位置。R是从1开始索引的，即索引为1的元素是第一个元素（因此用熟了Python和C可能会有些不适应）。在向量后方使用方括号进行取子集运算（即抓取索引为对应数字的元素）。

```{r}
x <- c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine")
x[3]
```

可以在方括号中使用另一个向量抓取多个元素：

```{r}
x[c(2,5,9)] # 第2个，第5个，第9个元素
```

如果方括号内是一个负数向量：

```{r}
x[-c(2,5,9)] # 除了第2个，第5个，第9个以外的元素
```

我们可以重新赋值子集：

```{r}
x[c(2,5,9)] <- c("二", "五", "九")
x
```

经常，我们会抓取几个连续的元素。如果想知道方法，请继续往下看。

### 生成器 {#generator}

有时候我们需要其元素按一定规律排列的向量，这时，相对于一个个手动输入，有更方便的方法：

#### 连续整数 {#successive-int}

```{r}
1:10 #从左边的数（包含）到右边的数（包含），即1:10
```

这时，你应该会有个大胆的想法：

```{r}
x[3:6]
```

没错就是这么用的，而且极为常用。

当元素比较多的时候： 

```{r}
y <- 7:103
y
```

注意到了左边方括号中的数字了吗？它们正是所对应的那一行第一个元素的索引。

下面的内容可能有点偏，**可以酌情从这里跳到第\@ref(vectorization-basics)节。**

#### 复读机`rep()` {#rep}

```{r}
rep(6, 8) # 把6重复8遍；或rep(6, times = 8)
```

```{r}
rep(c(0, 7, 6, 1), 4) # 把(0, 7, 6, 1)重复4遍
```

```{r}
rep(c(0, 7, 6, 1), each = 4) # 把0, 7, 6, 1各重复4遍
```

```{r}
rep(c(0, 7, 6, 1), c(1, 2, 3, 4)) # 把0, 7, 6, 1分别重复1, 2, 3, 4遍
```

想一想，`rep(8:15, rep(1:5, rep(1:2, 2:3)))`的计算结果是什么？

#### 等差数列: `seq()` {#seq}

公差确定时：

```{r}
seq(0, 15, 2.5) # 其实是`seq(from = 0, to = 50, by = 5)`的简写
```

长度确定时：

```{r}
 seq(0, 50, length.out = 11) # 其实是`seq(from = 0, to = 50, length.out = 11)`的简写
```

#### 随机数： {#random-nums}
 
连续型均匀分布随机数用`runif(n, min, max)`，n是数量，min是最小值，max是最大值。默认min为0，max为1。

```{r}
x_unif <- runif(100000, 40, 60) # 生成100000个40到60之间，连续均匀分布的的随机数
hist(x_unif) # 画直方图
```

正态分布随机数用`rnorm(n, mean, sd)`, 三个参数分别为数量，平均值，标准差。默认mean为0，sd为1。

```{r}
x_norm <- rnorm(100000, 250, 20) # 按照平均值为250，标准差为20的正态分布的概率密度函数生成100000个随机数
hist(x_norm) # 画直方图
```

此外，还有`rlnorm()`, `rpois()`, `rexp()`等函数。`?stats::distributions`中介绍了R中自带的分布，其中大部分都有对应的随机数生成器。

#### 简单随机抽样 {#math-random-sampling}

随机抽样的应用比随机数要广。

假设一个盒子里有10个球，上面分别写着字母"a"至"j".

```{r}
balls <- letters[1:10]
balls
```

我想从这10个球中随机取20个球，每取一次之后，把球放回去：

```{r}
sample(balls, 20, replace = TRUE)
```


我想从这10个球中随机取3个球，取完之后不把球放回去：

```{r}
sample(balls, 3) # 即`sample(balls, 3, replace = FALSE)`
```

可以看到，`sample()`函数第一个参数是样本空间，第二个参数是样本量。

当然，它经常被用作随机整数生成器（这也是我为什么把它放在这一小节）：

```{r}
sample(1:100, 10, replace = TRUE)
```

在后面的章节中，比如第\@ref(tibble-slice-sample)节，我们会学到`sample()`更实际的用法。

### 向量的其他操作 {#vector-misc}

#### 创建长度为0的向量 {#vector-length-0}

使用循环的时候，经常需要初始化一个长度为0的向量（见第\@ref(control-flow)节

有两种方法实现：

```{r}
x <- vector("numeric")
# 或`vector("integer")`, `vector("character")`等
class(x)
```

或者：

```{r}
x <- integer(0)
# 或 x <- integer()
# 或`character(0)`, `numeric(0)`等
class(x)
```

其中后面这种方法亦可用于创建长度为$n$的向量，把0替换成你想要的长度即可。

#### `sort()`, `rank()`和`order()` {#sort-rank-order}

```{r eval=FALSE}
x <- c(2, 5, 3, 6, 10, 9, 7, 8, 1, 4)
sort(x)
rank(x)
order(x)
rev(sort(x))
# 为方便同框展示，我用的代码是 list(x = x), `sort(x)` = sort(x), `rank(x)` = rank(x), `order(x)` = order(x), `rev(sort(x))` = rev(sort(x)))
```

```{r echo=FALSE}
x <- c(-10, 5, -89, 999, 84)
list(x = x, `sort(x)` = sort(x), `rank(x)` = rank(x), `order(x)` = order(x), `rev(sort(x))` = rev(sort(x)))
```

`sort()`很好理解，就是把原向量的元素从小到大重新排列。如果要从小到大：`rev(sort(x))`. 

`rank()`是原向量各个元素的（从小到大的）排名。（`-10`是第2名，`5`是第3名，`-89`是第1名，以此类推）

`order()`是一个原向量索引的排序，使得`x[order(x)] = sort(x)`，即`x[order(x)] = x[c(3, 1, 2, 5, 4)] = c(-89, -10, 5, 84, 999) = sort(x)`

至于文字向量，英文按`a, b, c, d, e, ...`排列，中文按笔画排列。

#### 元素的命名 {#naming-elements}

```{r}
scores <- c(ochem = 79, math = 66, mcb = 64, blc = 75, bpc = 72)
scores
```

然后便可以额外地用名字抓取元素：

```{r}
scores[c("math", "bpc")] == scores[c(2, 5)]
```


### R向量的优越性 {#vectorization-basics}

R中的向量（矩阵和数列也是）的各种计算默认都是逐元素 (elementwise)的。比如：

```{r}
x <- c(4, 9, 25)
y <- c(8, 6, 3)
x + y
x * y # 在matlab中这样乘是不行的，要用`.*`，除法也是
sqrt(x)
```

拥有这种特性的计算也被称为向量化计算 (vectorized computation).

相比于常用的编程语言，向量化计算省去了for循环，计算效率得到极大的提升；相比于matlab的默认矩阵乘法，逐元素乘法在数据处理中更有用。

若想更多地了解向量化计算（比如如何使用`apply()`族函数把for循环需要39秒的运算压缩到0.001秒），请看第\@ref(apply)节。

## 数据/对象类型 (Data/Object Types) {#data-types}

### 基础的数据/对象类型 {#data-types-basics}

#### 向量所存储的数据类型 {#data-types-vector}

向量所存储的的数据类型有5种：

|类型     |含义与说明            |例子                        |
|:--------|:---------------------|:---------------------------|
|numeric  |浮点数向量            |`3`, `0.5`, `sqrt(2)`, `NaN`, `Inf`|
|integer  |整数向量              |`3L`, `100L`                |
|character|字符向量；需被引号包围|`"1"`, `"$"`, `"你好"`      |
|logical  |逻辑向量              |`TRUE`, `FALSE`, `NA`       |
|complex  |复数向量              |`3+5i`, `1i`, `1+0i`        |

**一个向量的所有元素必须属于同一种类型。**如果尝试把不同类型的元素合并成一个向量，其中一些元素的类型会被强制转换 (coerced)。你可以试试`c(2, "a")`, `c(2+5i, 4)`, `c(TRUE, 1+9i)`和`c(TRUE, 1+9i, "a")`，但是实际操作的时候尽量不要这么做。

#### 关于数据类型的简单操作 {#data-types-simple-operations}

通过`class()`函数，可以查看数据/对象的类型。

```{r}
class(6) # 6是一个（浮点）数，应为"numeric"
```

通过`is.XXX()`函数，可以得到一个逻辑值，指明此数据/对象是否属于某个类型，`TRUE`为是，`FALSE`为否。比如：

```{r}
is.numeric(6)
is.character("6")
```

通过`as.XXX()`函数，可以把数据/对象强行转换成另一种类型，比如：

```{r}
as.integer(c(TRUE, FALSE))
as.character(c(23, 90))
```

#### `NA`, `Inf`, `NaN`和`NULL` {#na-inf-nan-null}

`NA`为缺损值，意思是该元素所代表的数值丢失/不确定/不可用。举个例子，当我们统计学生的200m跑成绩时，有一些学生因为身体不适未能参与测试，这时他们的成绩应被记为`NA`：

```{r}
time_in_sec <- c(29.37, 28.66, 31.32, NA, 27.91, NA)
```

之前说过，一个向量中，所有的元素都是同一类型的。的确，这里的`NA`的类型是`numeric`:

```{r}
class(time_in_sec[4])
```

同理，`character`向量里的`NA`，类型也是`character`，其他类型也是一样的道理。如果只是单个的`NA`, 它的类型是`logical`:

```{r}
y <- c("a", "b", NA)
class(y[3])
class(NA)
```

`Inf`（无限）`NaN`（非数）的概念，以及作为`numeric`的`NA`的数学计算在第\@ref(math-NA)小节讨论。

作为`logical`的`NA`的逻辑运算在第\@ref(logical-operation)小节讨论。

`NULL`是“无”。它几乎一无是处，因此在此不作更多讨论。学有余力者可以自己去了解。

#### 其它的数据/对象类型 {#other-data-types}

- Dataframe/tibble 是R中存储复杂（多变量）数据的规范格式，从第\@ref(tibble)章开始将一直占据我们话题的中心。
- 因子 (factor)有很多向量的特性，尤其是能在dataframe/tibble中作为变量，但是它并不是向量；因子的详细内容在第\@ref(factors)节。
- 函数 (function)。我们刚才用`c()`来创建向量，它就是一个函数：`class(c)`；函数的详细内容在第\@ref(functions)节。
- list类似于向量，但是一个list可以包含不同类型的元素。性质和使用方法也和向量大相径庭。详细内容在第\@ref(list)节，算是较为进阶的内容。
- 矩阵 (matrix)和数组 (array)可以算作是二维和多维的向量，同样只能存储一种类型的数据，详细内容在第\@ref(matrix-array)节，同样是较为进阶的内容。

### 数据类型（严谨版） {#data-types-advanced}

可以酌情跳到第\@ref(math)节。

本小节内容没完成，请跳到第\@ref(math)节。

#### `class`, `type`, `mode`和`storage mode`

其实`class`根本不是基础的数据类型。学过编程的应该猜到了，此`class`类似于OOP里的“类”，是“高层”的类型。你可以随意篡改`class`：

```{r}
x <- c("Joe", "Lynne", "Pat")
class(x) # 本应为"character"
class(x) <- c("high_school", "student") # 篡改
class(x) # 新class
```

用`typeof()`, `mode()`, `storage.mode()`所获取到的三种属性是不可篡改的“底层”类型。

以下是五种atomic vectors用四种方式获取到的结果：

|对象   |例子              |`typeof()` |`mode()`  |`storage.mode()`| `class()`|
|:------|:-----------------|:----------|:---------|:---------------|:---------|
|浮点数 |`1`, `NaN`, `Inf` |`double`   |`numeric` |`double`        |`numeric` |
|整数   |`1L`              |`integer`  |`numeric` |`integer`       |`integer` |
|复数   |`0+1i`            |`complex`  |`complex` |`complex`       |`complex` |
|字符串 |`"a"`             |`character`|`character`|`character`   |`character`|
|逻辑值 |`TRUE`            |`logical`  |`logical` |`logical`       |`logical` |

其中浮点数和整数的“类型”名称有一些出入。`is.XX()`系列有三个用于实数的函数：

- `is.numeric()`用于判断对象是否是实数，即`1`和`1L`的判断结果都为`TRUE`
- `is.double()`用于判断对象是否是浮点数，即`1`为`TRUE`, `1L`为`FALSE`
- `is.integer()`用于判断对象是否是整数，即`1`为`FALSE`, `1L`为`TRUE`

对于矩阵和数列，用`typeof()`, `mode()`, `storage.mode()`所得到的结果与对应的atomic vectors得到的结果一致[^typeof-matrix]。而用`class()`会得到`matrix`/`array`.

[^typeof-matrix]: 矩阵和数列和atomic vector一样，都只能存储一种形式的数据；本质上，它们就是多维的向量。

```{r}
x <- matrix(c(TRUE, FALSE, FALSE, TRUE), ncol = 2)
typeof(x); class(x)
```

以下是其它数据类型用四种方式获取到的结果：

|对象                  |例子              |`typeof()` |`mode()`  |`storage.mode()`| `class()`|
|:---------------------|:-----------------|:----------|:---------|:---------------|:---------|
|基础函数[^if]         |`sum`, `^`        |`buitin`   |`function` |`function`     |`function`|
|闭包（包括自定义函数）|`mean`, `function(x) 2*x`|`closure`|`function`|`function` |`function`|
|流程控制关键字[^if]|`if`, `while`, `break`|`special` |`function` |`function`     |`function`|
|因子 (factor)         |factor("a")
|列表 (list)           |list("a", 2)      |`list`     |`list`     |`list`         |`list`    |
|数据框 (dataframe)    |`data.frame(x = 1)`|`list`    |`list`     |`list`       |`data.frame`|

[^if]: 若是二元运算符，要用`` typeof(`+`) ``的形式。自定义的二元运算符和流程控制关键字同理。


日期和时间是一种特殊的数据格式。它们被存储在向量中，可以拥有维度（即，可以做成矩阵和数列）。它们的属性展示如下：

|对象                  |例子              |`typeof()` |`mode()`  |`storage.mode()`| `class()`|
|:---------------------|:-----------------|:----------|:---------|:---------------|:---------|
|国际标准格式的日期+时间|`as.POSIXct("2018-01-02 12:23:56")`|`double`|`numeric`|`double` |`POSIXt`  |
|日期                  |as.date("2018-01-02")|`double`|`numeric` |`double`        |`date`    |

## 数学表达和运算 {#math}

### 数的表达 {#math-notation}

#### 浮点数 {#math-double-nums}

除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其`class`为`numeric`。

```{r}
class(3)
```

这会导致一些有趣的现象，比如$(\sqrt{3})^2 \neq 3$：~~（强迫症患者浑身难受）~~

```{r}
sqrt(3)^2-3
```

浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位；只有当两个非常，非常大且数值相近对数字相减才会出现较大的误差）。

#### 科学计数法 {#math-sci-not}

在R中可以使用科学计数法(`AeB`$= A \times 10^B$)，比如：

```{r}
3.1e5
```
```{r}
-1.2e-4+1.1e-5
```

#### 整数 {#math-int-nums}

整数的class为`integer`。有两种常见的方法创建整数：
1）在数后面加上`L`；

```{r}
class(2)
class(2L)
```

2）创建数列

```{r}
1:10 #公差为1的整数向量生成器，包含最小值和最大值
class(1:10)
seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数
class(seq(5,50,5)) #因此产生的是一个浮点数向量
seq(5L,50L,5L) #可以强制生成整数
class(seq(5L,50L,5L)) #是整数没错
```

整数最常见的用处是indexing（索引）。

##### 整数变成浮点数的情况 {#math-int-to-double}

这一小段讲的比较细，**请酌情直接跳到下一节（\@ref(arithmetic)）。**

整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(`factorial`)也是，即便现实中不管怎么阶乘都不可能得到非整数）：
```{r include=FALSE}
x <- list(2L+1L, 2L-1L, 2L*3L, 17L%/%3L, 17L%%3L, 1000L/1L, 3L^4L, sqrt(4L), log(exp(5L)),factorial(5L),sin(0L))
for (num in x){
  print(num)
  print(class(num))
}

y <- c(8L/2L, 2L^3L)
```

```{r}
class(2L+1L)
class(2L-1L)
class(2L*3L)
class(17L%/%3L)
class(17L%%3L)
```

```{r}
class(1000L/1L)
class(3L^4L)
class(sqrt(4L))
class(log(exp(5L)))
class(factorial(5L))
```

整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。

### 运算 {#arithmetic}

#### 二元运算符号 {#math-binary-operators}

R中常用的binary operators（二元运算符）有：

|  符号     |     描述    |
|:---------:|:-----------:|
|   `+`     | 加          |
| `-`       | 减          |
| `*`       | 乘          |
| `/`       | 除以        |
| `^`或`**` | 乘幂        |
|`%/%`      |求整数商，比如`7%%3`$=2$|
|`%%`       |求余数，比如`7%%3`$=1$|

其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（见[本章小测](#test-base-basics)）。

#### $e^x$和$\log_x{y}$ {#math-exponent-log}

`exp(x)`便是运算$e^x$。如果想要$e=2.71828...$这个数：

```{r}
exp(1)
```

`log(x, base=y)`便是运算$\log_y{x}$，可以简写成`log(x,y)`（简写需要注意前后顺序，第\@ref(abbr)有解释）。

默认底数为$e$：

```{r}
log(exp(5))
```

有以10和2为底的快捷函数, `log10()`和`log2()`

```{r}
log10(1000)
log2(128)
```

#### 近似数（取整，取小数位，取有效数字）{#quzheng}

取有效数字用`signif()`函数；第一个参数是对象，第二个参数是保留的位数；若保留的位数未指定，默认为6.

```{r}
signif(12.3456789, 4)
```

当对象的有效数字小于你想保留的有效数字位数时，它不会让你乱来（下面`round()`函数也类似）：

```{r}
signif(12.3, 8)
```

保留小数位用`round()`函数。

```{r}
round(12.3456789, 3) # 保留3个小数位
```

若不指定保留多少位，默认为0，即四舍五入地取整：

```{r}
round(13.5)
```

此外，还有三种取整函数：`floor()`, `ceiling()`和`trunc()`

```{r eval=FALSE}
floor(5.6) # = 5 # “地板”；比x小的最近的整数
ceiling(5.4) # = 6 # “天花板”；比x大的最近的整数
floor(-5.6) # = -6 # 不是-5，因为-6是比-5.6小的最近的整数
ceiling(-5.4) # = -5 # 不是-6；因为-5是比x大的最近的整数
trunc(-5.6) # = -5 # 你可能需要这个；它无视了小数点后面的位数
```

注意，所有取整函数给出的的结果都并不是整数！

```{r}
class(ceiling(7.4))
```

虽然浮点数使用起来真没啥不方便的，但是如果你一定需要的话，可以用`as.integer()`函数把它转换成真·整数。

#### `NA`, `Inf`, `NaN`相关 {#math-NA}

我不知道张三有几个苹果，我也不知道李四有几个苹果；你问我张三和李四共有几个苹果：

```{r}
NA + NA
```

鬼才知道咧！

类似地，`NA - NA`, `NA/NA`, `NA*NA`, `log(NA)`都等于`NA`

`NA^0`等于几？别上当！R的开发者们可没有忘记$\forall x\in \mathbb{R:x^0 = 1}$

`Inf`, 即$\infty$, 表示很大的数字（准确地说，大于等于$2^{1024}$即$1.797693\times10^{308}$的数字）它还有个负值，`-Inf`. 以下是几个结果为`Inf`的例子：

```{r eval=FALSE}
exp(1000) # = Inf; 这个很明显
1/0 # = Inf; 0被当作很小的数
0^(-1) # = 1/(0^1) = 1/0 = Inf
log(0) # = -Inf; 0又被当作很小的数
```

`NaN`是“非数” (not a number). 运算结果为`NaN`的例子有：

```{r eval=FALSE}
0/0 # NaN
log(-1) # = NaN
0^(3+8i) # = NaN + NaNi
Inf-Inf; Inf/Inf # = NaN
-NaN # = NaN
```

`Inf`和`NaN`的类型是`numeric`（浮点数）.

```{r}
class(Inf); class(NaN)
```

`is.na()`会判定`NaN`为真：

```{r}
is.na(NaN)
```

#### R中自带的常用数学函数概览 {#math-builtin-mathFuncs}

|函数          |描述          |
|:---------------|:-------------|
|`exp(x)`        |$e^x$         |
|`log(x,y)`      |$\log_yx$     |
|`log(x)`        |$\ln(x)$     |
|`sqrt(x)`       |$\sqrt{x}$    |
|`factorial(x)`  |$x!=x\times(x-1)\times(x-2)\ldots\times2\times1$|
|`choose(n,k)`   |$\binom{n}{k}=\frac{n!}{k!(n-k)!}$（二项式系数）|
|`gamma(z)`      |$\Gamma(z)=\int_0^\infty x^{z-1}e^{-x}dx$（[伽马函数](https://en.wikipedia.org/wiki/Gamma_function)）|
|`lgamma(z)`     |$\ln(\Gamma(z))$|
|`floor(x)`, `ceiling(x)`, `trunc(x)`, |取整；见上一小节。|
|`round(x, digits = n)`|四舍五入，保留n个小数位，n默认为0|
|`signif(x,digits = n)`|四舍五入，保留n个有效数字，n默认为6）|
|`sin(x)`, `cos(x)`, `tan(x)`|三角函数|
|`asin(x)`, `acos(x)`, `atan(x)`|反三角函数|
|`sinh(x)`, `cosh(x)`, `tanh(x)`|双曲函数|
|`abs(x)`|$|x|$（取绝对值）|
|`sum(...)`, `prod(...)`|所有元素相加之和/相乘之积|

### 简易的统计学计算 {#statistics}

本节简要解释了R中的基础统计学函数，t分布，t检验和$\chi^2$检验。统计学方法并不是本书的重点，因此可以酌情跳到第\@ref(logical-operation)节（基础内容：逻辑）或第\@ref{list}节（进阶内容：列表）。

#### 基础 {#stats-basics}

中位数`median()`; 平均数`mean()`; 方差`var()`; 标准差`sd()`.

#### t分布 {#t-dist}

众所周知，t分布长这样：

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics("img/graphics/t-distribution.png")
```

阴影面积为$P(t<T)$，虚线对应的$t$为$T$.
`qt()`可以把$P(t≤T)$的值转化成$T$,`pt()`则相反。

假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为$95\%$，即$\alpha=0.05$，degrees of freedom(自由度)为$12$，那么怎么算$t^*$呢？

```{r}
qt(0.975, df = 12)
```

为什么是$0.975$？因为你要把$0.05$分到左右两边，所对应的t*就等同于t分布中，$P(t ≤ T) = 0.975$时T的值。

再举一个例子，你在做t检验，双尾的，算出来$t=1.345$，自由度是$15$，那么$p$值怎么算呢？

```{r}
p <- (1-(pt(2.2, df = 15)))*2
p
```

其中`pt(2.2, df = 15)`算出阴影面积（$P(t≤T)$的值），1减去它再乘以2就是对应的双尾t检验的$p$值。

#### z分布 {#z-dist}

没有z分布专门的函数。可以直接用t分布代替，把`df`调到很大（比如`999999`）就行了。比如我们试一下$95\%$置信区间所对应的$z*$：

```{r}
qt(0.975,9999999)
```

（果然是$1.96$）

#### t检验 {#t-test}

t检验分为以下几种：

- One sample t test （单样本）
- paired t test（配对）
- Two sample...（双样本）
  - Unequal variance (Welch) t test（不等方差）
  - Equal variance t test（等方差）
  
在R中做t检验，很简单，以上这些t检验，都是用`t.test` 这个函数去完成。

以单样本为例：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
t.test(x, mu = 2.31)
```

可以看到$p=0.06766$。

R的默认是双尾检验，你也可以设置成单尾的：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)

t.test(x, mu = 2.31, alternative = "less") # 检验是否*less* than μ
```

$p$值瞬间减半。

双样本/配对:

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
y <- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22)

t.test(x, y)
```

R的默认是non-paired, unequal variance，你可以通过增加`paired = TRUE`，`var.equal = TRUE`这两个参数来改变它。

```{r}
t.test(x, y, paired = TRUE)
```

#### $\chi^2$ 检验 {#chisq-test}

$\chi^2$检验有两种，goodness of fit test（适配度检验）和contigency table test/test of independence（列联表分析/独立性检验）。都是用`chisq.test()`函数去完成。

##### 适配度检验 {#chisq-gof}

假设我们制造了一个有问题的骰子，使1至6朝上的概率分别为：

```{r}
expected_probs <- c(0.05, 0.1, 0.15, 0.2, 0.2, 0.3)
```

然后我们投掷了100次，实际1至6朝上的次数分别为：

```{r}
observed_vals <- c(6, 9, 14, 24, 18, 29)
```

通过`chisq.test()`，检验实际的1至6朝上概率是否与预期有偏差：

```{r}
chisq.test(observed_vals, p = expected_probs) # 参数p是指概率
```

p值很大（远大于0.05），因此结论是骰子各面朝上的概率符合预期。

如果不指定p参数，默认为检测是否所有值相等（即骰子的所有面朝上的概率相等）：

```{r}
chisq.test(observed_vals)
```

这时p值小于0.05. 得出“骰子各面朝上的概率不等”的结论。

##### 列联表分析/独立性检验 {#chisq-contig}

假设我们有一组不同年级的学生参加社团的人数数据：

```{r}
(社团参与 <- matrix(c(28,36,40,40,32,33,38,29,36), nrow = 3, dimnames = list(c("一年级", "二年级", "三年级"), c("棒球", "足球", "网球"))))
```

我们想知道社团的参与，与所在年级是否是独立事件：

```{r}
chisq.test(社团参与)
```

p值不小于0.05，无法拒绝“社团的参与，与所在年级是独立事件”的虚无假设。

彩蛋：用R代码实现卡方分布的概率密度函数的图像：

```{r}
#其实还可以更精简，但是为了易读性不得不牺牲一点精简度。
Z <- matrix(rep(rnorm(1000000), 6), nrow = 6)^2

X <- Z^2

Q <- matrix(nrow = 6, ncol = 1000000)

for (i in (1+1):6) {
  Q[1,] = Z[1,]
  Q[i,] = Q[(i-1),] + Z[i,]
}

plot(NULL, xlim=c(0.23,6), ylim = c(0,1),
     main = expression(paste('X ~ ', chi^'2', '(k)')), 
     xlab = "x", 
     ylab= expression(f[k]*'(x)')
    )
colors <- c('blue', 'black', 'red', 'green', 'gray', 'orange')
for (i in 1:6) {
  lines(density(Q[i,]),
        col=colors[i],
        lwd=2)
}
legend('topright',c('k=1','k=2','k=3','k=4','k=5','k=6'),
       fill = colors)
```

##### 其他

R自带的检验还有`Box.test()`, `PP.test()`, `ansari.test()`, `bartlett.test()`, `wilcox.test`等共31种。查看帮助文件或利用网络资源以了解更多。

## 列表 (list) {#list}

R中的列表是一种特殊的数据存储形式。使用`list()`函数来创建列表，比如list(1, 2, 3).

data          `is.vector()`  `is.list()`  `is.atomic()`  `is.recursive()`
------------- -------------- ------------ -------------- ----------------
list(1, 2, 3) `TRUE`         `TRUE`       `FALSE`        `TRUE`
c(1 ,2 , 3)   `TRUE`         `FALSE`      `TRUE`         `FALSE`

Table: 在一个列表和向量上分别使用四个判断数据结构类型的函数得到的结果

尝试对lists和vectors使用`is.vector()`, `is.list()`, `is.atomic()`和`is.recursive()`函数，你会发现列表虽然也是“vector”，但我们一般说的“vector”都是指只能存储一种数据类型的atomic vector；而lists是recursive vector. 

这意味着**一个list能存储多种类型的数据，且可以包含子列表**。列表中的每个*分量*可以是**任何R中的对象** (object)：除了常用的 (atomic) vector和另外一个（子）列表以外，还可以有dataframe/tibble和函数：

```{r}
y <- list(1, c("a","あ"), list(1+3i, c(FALSE, NA, TRUE)), 
          data.frame(x = c("阿拉木图", "什切青"), y = c(2, 3)),
          t.test)
y
```

这个列表有5个分量，其中第3个是一个有2个分量的子列表。

### list的索引/取子集 {#list-index}

使用上面的例子：

```{r}
y[2] # 使用单方括号，得到的是一个只有一个分量的列表
y[[2]] # 使用双方括号，得到的是一个向量
y[[3]][[2]] # 得到的也是一个向量；父列表的索引在前，子列表的在后
y[[3]] # 这个位置包含两个子列表，因此得到一个有两个分量的列表
y[[3]][[2]][2] # 得到向量时，直接在后面用单方括号
```

列表里的分量可以有名字；被命名的元素可以通过`$`符号抓取：

```{r}
z <- list(c(1, 3), z2 = c(4, 5, 6), c("a", "b"))
z # `[[2]]`被`$z2`所取代
z$z2 == z[[2]] # `z[[2]]`仍然是可用的，结果和`z$z2`一样
```

### 合并与拆解 {#list-combine-unlist}

通过`c()`函数来合并多个列表。

```{r eval=FALSE}
c(list(1, 2), list(3, 4, list(5,6)))
# 将等同于list(1, 2, 3, 4, list(5,6))
```

也许你想把需要“合并”的列表作为子列表放在另一个列表里；这也很简单，在本节一开始就讲了：

```{r}
list(list(1, 2), list(3, 4))
```

通过`unlist()`函数来拆解列表中的子列表。若参数`recursive`为`TRUE`（默认值），将一直拆解至无子列表的列表，如果此最简列表的所有分量都属于五种atomic vector中的数据[^unlist-df]，此列表还会被进一步化简成向量。若`recursive = FALSE`，最“靠外”的一级列表（可能是多个）将会被拆解。

[^unlist-df]: dataframe也是可以unlist成向量的，但是并不实用。（试试`unlist(list(data.frame(x = c(1,2), y = c(3,4)), 5, 6))`）

```{r eval=FALSE}
unlist(list(1, list(2, list(3, 4)), list(5, 6), 7, 8, 9))
# 将等同于c(1, 2, 3, 4, 5, 6, 7, 8, 9) 
# 注意被化简成了向量

unlist(list(1, list(2, list("a", 4)), list(5, TRUE), 7L, 8, 9+0i))
# 将等同于c("1", "2", "a", 4, 5, "TRUE", "7", 8, "9+0i")
# 化简成向量时，非字符元素被强制转换成字符了

unlist(list(1, list(2, list(t.test, 4)), list(5, TRUE), 7L, x, 9+0i))
# t.test无法存储于向量中，因此最简结果为一个list：
# list(1, 2, t.test, 4, 5, TRUE, 7L, x, 9+0i)


unlist(list(1, list(2, 3, list(4, 5)), list(6, 7), 8, 9), recursive = FALSE)
# 将等同于list(1, 2, 3, list(4, 5), 6, 7, 8, 9)
```

因此，当`A`, `B`为列表，`unlist(list(A, B), recursive = FALSE)`等同于`c(A, B)`.

### 其他性质和操作 {#list-other-properties-operations}

上面说到`unlist(list(A, B), recursive = FALSE)`等同于`c(A, B)`，你可能很想用`==`验证一下。很不幸，你会得到一条错误信息：

```{}
comparison of these types is not implemented
```

在第\@ref(relational-operators)节讲过，`==`只能用于atomic vectors；对于列表（和其他对象）可以用`identical()`函数确认两者是否完全一致。

```{r}
A <- list("a", 1, TRUE); B <- list(5+8i, NA, 4L)
C1 <- unlist(list(A, B), recursive = FALSE); C2 <- c(A, B)
identical(C1, C2)
```

## 数组 (array)和矩阵 (matrix)简介 {#matrix-array}

Vector是一维的数据。Array是多维的数据。Matrix是二维的数据，因此matrix是array的一种特殊情况。

Dataframe不是matrix（虽然都是方的）. Matrix是二维的，**仅包含数字**的**array**. Dataframe是一个二维的**list**，不同列（即列表的分量）**可以存储不同的数据类型**。

本质上，矩阵和数组都是以向量的形式存储的。它们只是额外地拥有`dim`（即“dimensions”，维度）属性。我们可以用`dim()`函数从向量创建数组/矩阵：

```{r}
A <- 1:48 
dim(A) <- c(6,8) 
A
```

可以看到我们创建了一个二维的数组, 即一个4行6列的矩阵。

```{r}
is.array(A)
is.matrix(A)
```

它多出来的`dim`属性可以用`attr()`（即“attributes”，属性）函数来查看：

```{r}
attributes(A)
```

注意24个数字排列的方式。第一个维度是行，所以先把4行排满，随后再使用下一个维度（列），使用第2列继续排4行，就像数字一样，（十进制中）先把个位从零数到9，再使用第二个位数（十位），以此类推。下面三维和四维的例子可能会更清晰。

同时注意最左边和最上边的[1,], [,3]之类的标记。你应该猜出来了，这些是index. 假设你要抓取第五行第三列的数值：

```{r}
A[5,3]
```

或者第三行的全部数值：

```{r}
A[3,]
```

或者第四列的全部数值：

```{r}
A[,4]
```

接下来我们再看一个三维的例子（还是用1-48）：

```{r}
dim(A) <- c(2,8,3)
A
```

它生成了三个二维的矩阵。在每个2*8的矩阵存储满16个元素后，第三个维度就要加一了。每个矩阵开头的`, , x`正是第三个维度的值。同理，我们可以生成四维的array（这是另外一种改变维度的方法。dim作为一个属性 (attribute), 可以通过`attr()`函数赋值。`attr()`还可以赋值其他的属性。）：

```{r}
attr(A, "dim") <- c(3,4,2,2)
A
```

观察每个矩阵开头的`, , x, y`.  x是第三个维度，y是第四个维度。每个二位矩阵存满后，第三个维度（x）加一。x达到上限后，第四个维度（y）再加1。

类似二维矩阵，你可以通过index任意抓取数据，比如：

```{r}
A[ ,3 , , ] #每个矩阵第3列的数据，即所有第二个维度为3的数值
```

### 给matrices和arrays命名 {#matrix-array-naming}

假设我们记录了3种药物（chloroquine, artemisinin, doxycycline)
对5种疟原虫(P. falciparum, P. malariae, P. ovale, P. vivax, P. knowlesi)的疗效，其中每个药物对每种疟原虫做6次实验。为了记录数据，我们可以做3个6*5的矩阵：（这里只是举例子，用的是随机生成的数字）

```{r}
B <- runif(90, 0, 1) #从均匀分布中取90个0到1之间的数
dim(B) <- c(6, 5, 3) #注意顺序
B
```

然后我们用`dimnames()`来命名：

```{r}
dimnames(B) <- list(paste("trial.", 1:6), 
                    c('P. falciparum', 'P. malariae', 'P. ovale', 'P. vivax', 'P. knowlesi'), 
                    c('chloroquine', 'artemisinin', 'doxycycline'))
B
```

## 逻辑 {#logical-operation}

### 逻辑值 {logical-values}

逻辑值有三个。`TRUE`, `FALSE`和`NA`.

```{r}
class(c(TRUE,FALSE,NA))
```

`TRUE`为真，`FALSE`为假，`NA`为未知（即真假难辨）。

### 关系运算符和简单的逻辑运算 {#relational-operators}

R中常用的关系运算符有：

|符号|描述|
|:--:|:----:|
|`==`  |equal to（等于）|
|`!=`  |equal to（不等于）|
|`<`|less than（小于）|
|`>`|more than（大于）|
|`<=`|less than or equal to（小于等于）|
|`>=`|more than or equal to（大于等于）|

这些关系运算符只能用于(atomic) vectors, 不能用于其他类型的R对象；`indentical()`函数可以用于所有类型的对象，用来确认两者是否完全一致。

使用关系运算符进行计算，会产生逻辑值作为结果。比如：

```{r}
x <- 5
x != 3 #x等于5，所以“x不等于3”为真
```

有一些其他的运算符或函数也会返回逻辑值，比如

```{r}
7 %in% c(1,4,5,6,7)
```

顾名思义，这个运算符是用来检测一个元素是否在另一个向量中。其它类型的运算符，我在需要用到的时候再讲。

有很多种运算会以`NA`作为计算结果，在此不一一列举。最重要的一个是：

```{r}
NA == NA
```

这看起来像是一个bug，然而仔细想想才发现这个设计很巧妙。假设你问我是否知道我的一些朋友写完了暑假作业。我说我**不知道**张三是否写完了，也**不知道**李四是否写完了。你再问我“张三和李四的作业完成情况是一样的吗”？鬼才知道咧！

这意味着不能直接使用`x == NA`来判断`x`是否是`NA`，而要用`is.na()`函数：

```{r}
x <- NA
is.na(x)
```

**关系运算符具有的向量化的性质。**也就是说，用于长度大于1的向量时，会返回一个同等长度的逻辑向量，且这种运算速度极快。

```{r}
x <- c(2, 1, 6, 5, 4, 9, 7, 3, 10, 8)
x <= 5
```

像这样与某向量等长的逻辑向量可以用于那个向量的取子集：

```{r}
x[c(TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)]
```

更常见的用法是使用关系运算作为索引：

```{r}
x[x <= 5]
```

有时候，你可能不需要向量化的计算，只需要一个`TRUE`或`FALSE`. `all()`和`any()`或许能帮到你。顾名思义，`all()`测试的是“是否全部为`TRUE`”，`any()`测试的是“是否至少有一个`TRUE`”：

```{r}
all(x <= 5); any(x <= 5)
```


### 逻辑运算符 {#logical-logical-operators}

以下是最常用的三个逻辑运算符。

|符号|描述|
|:--:|:----:|
|`&`|AND（且）|
|`|`|OR（或）|
|`!`|反义符号|

#### 反义符号（`!`） {#logical-logical-operators-anti}

`!`使`TRUE` `FALSE`颠倒。一般，我们用小括号来包住一个逻辑运算，然后在它的前面加上一个`!`来反转结果，比如

```{r}
!(3 < 4) # 这个例子很简单，反义符号意义不大。后面实操的时候才能领略到它的用处。
```

#### 多个逻辑运算的组合（`&`（且）和`|`（或）） {#logical-logical-operators-and-or}

`&`和`|`可以把多个逻辑运算的结果合并成一个逻辑值。

`&`判断是否两边运算结果都为`TRUE`。如果是，才会得到`TRUE`（即一真和一假得到假）。

`|`判断两边运算结果是否至少有一个 `TRUE`，如果是，就会得到`TRUE`。

不用死记硬背！其实就是“且”和“或”的逻辑。

用脑子想一下以下三条运算的结果，然后复制代码到R console对答案。

```{r eval=FALSE}
1 == 1 & 1 == 2 & 3 == 3 #即：“1等于1且1等于2且3等于3”，是真还是假？
FALSE | FALSE | TRUE # FALSE/TRUE等价于一个运算结果
!(FALSE | TRUE) & TRUE # 注意反义符号
```

我们可以查看三个逻辑值所有两两通过`&`组和的计算结果（如果你不感兴趣，可以不关注方法。这里重点是结果）：

```{r}
vals <- c(TRUE, FALSE, NA) 
names(vals) <- paste('[',as.character(vals),']',sep = '')
outer(vals, vals, "&")
```

可以看到，`FALSE`与任何逻辑值组合，结果都是`FALSE`。这个好理解，因为一旦一个是`FALSE`，那么不可能两边都是`TRUE`. `TRUE & NA`之所以为`NA`（而不是`FALSE`），是因为`NA`的意思是“不能确定真假”，即有可能真也有可能假。因此`TRUE & NA`也无法辨真假。

再来看`|`的组合：

```{r}
outer(vals, vals, "|")
```

可以看到，`TRUE`与任何一个逻辑值组合，都是`TRUE`，而`FALSE | NA`为`NA`。原因一样（因为`NA`的不确定性）。


## 判断和循环（流程控制） {#control-flow}

### 给有编程基础者的快速指南 {#control-flow-for-programmers}

如果没编程基础，没接触过判断和循环，请看第\@ref(kickstart)小节。

如果学过其他编程语言，知道判断和循环的作用，只是需要知道在R中的表达，那么请看以下两个例子快速入门，然后跳至第\@ref(functions)节：

```{r}
m <- 1:100 # 产生一个[1,2,3,...,99,100]的整数向量。上面讲过。
n <- vector("numeric")
for (i in n) {
  if (i %% 2 == 0) {
    n <- append(n, i^2)
  } else if (i == 51) {
    break
  }
}
n
```

```{r}
logi = TRUE
num <- 1
while (num <= 100) {
  if (logi) {
    num = num + 10 # R 不支持 num += 5的简写
    print(num)
    logi = FALSE
  } else {
    num = num + 20
    print(num)
    logi = TRUE
  }
}

```

### 无编程基础者的快速指南 {#kickstart}

我认为，举例子比讲述概念更容易理解。

#### `if`, `else if`, `else`语句（“如果……”，“或者，如果……”，“否则……”）

```{r}
# 以下代码翻译成英语就是：If 1 + 1 = 2, print "hi". Else, print "bye".
# 或中文：如果一加一等于二，那么印出“hi”，否则印出“bye”.
if (1 + 1 == 2) { # 1 + 1 == 2 的运算结果是TRUE，因此“如果”成真
  print("hi") # 所以会执行`print("hi")`
} else {
  print("bye")
}
```

```{r}
# 代码第一行中的FALSE可以替换成任何计算结果为FALSE的运算，
# 比如1 + 1 == 3；小括号内的计算过程不重要，
# 但运算结果必须为TRUE或FALSE（不可以是NA）
if (FALSE) { 
  print("hi")
} else { # 因为是FALSE，所以`else`里的语句被执行
  print("bye")
}
```

```{r}
if (FALSE) { # 第一个`if`为FALSE
  print("hi")
} else if (FALSE) { # 检查下一个`else if`，也是FALSE
  print("yoo")
} else if (TRUE) { # 再检查下一个`else if`，这次是TRUE
  print("hey") # 所以执行`print("hey")`
} else {
  print("bye") # 而轮不到else
}
```

#### for循环 {#control-flow-for-loop}

```{r}
# 以下代码翻译成英文就是: for every element i in c(2, 4, 6, 8): 
# assign i^2 to n, then print n
# 中文：对c(2, 4, 6, 8)`中的每一个元素i：
# 创建一个n使得n等于i的平方，然后印出n
for (i in c(2, 4, 6, 8)) { # i可以是任何你想要的名字，比如num
  n <- i^2 # 如果上一行是 for (num in ..., 这一行就要写成 n <- num^2
  print(n)
}
```

```{r}
x <- vector(mode = "numeric") # 创建一个空的numeric vector
for (m in 1:10) {
  if (m %% 2 == 0) {
    x <- append(x, m)
  }
}

x
```

```{r}
M <- c(1, 2, 3 ,4 ,5)
N <- c(10, 100, 1000)

x <- vector("numeric")
for (m in M) {
  for (n in N) { # 在一个for循环中嵌入另一个for循环
    x <- append(x, m*n)
  }
}

x
```

**实际操作中，要想尽办法避免for循环，尤其是以上这种双层（多层）嵌套的for循环！**原因和方法请看第\@ref(apply)节。

#### while循环 {#control-flow-while-loop}

```{r}
x <- 1
while (x < 10) { # 当x<10的时候，执行大括号内的语句
  print(x)
  x <- x + 3 # 一定要让x的值增加，否则会进入无限循环
}
```

#### `break` 和 `next` {#control-flow-break-next}

```{r}
for (i in 1:10) {
  if (i == 3) {
    next # 当i == 3时，跳过它，继续（最近的）for循环的下一个回合
  } else if (i == 6) {
    break # 当i == 6时，结束（最近的）for循环
  } 
  print(i) # 只有当if和else if里的检验都为FALSE时，`print(i)`才会执行。
}
```

```{r}
M <- c(1, 2, 3, 4, 5)

x <- vector("numeric")
for (m in M) {
  while (TRUE) { # 原本while(TRUE){}将会是一个无限循环（判定条件永远TRUE）
    x <- append(x, 2*m)
    break # break打破了最近的这个while循环，而不影响for循环。
  }
}

x
```

### 严谨版 {#control-flow-rigorous}

如果看懂了[上一节](#kickstart)中的例子，并且作为新手不太想深究，可以暂时跳过这一节，前往第\@ref(functions)节。

*这里很多内容还没完成，请前往第\@ref(functions)节。*
 
#### `if`, `else`, `else if` 语句 {#control-flow-rigorous-if-else}

`if else`语句长这样：

```{r eval=FALSE}
if (something is true) {
  do something
} else {
  do some other things 
}
```

其中小括号内为测试的条件，其运算结果需为TRUE或FALSE（不能是`NA`！）。如果你还不熟悉关于逻辑值的计算，请看第\@ref(logical-operation)节。

- 若运算结果为TRUE：大括号内的语句将会被执行。（如果语句只有一行，大括号可以省略）

- 如运算结果为FALSE：
  - 如果后面没有`else`语句：什么都不会发生。
  - 如果后面有`else`语句：`else`后（大括号里）的语句将会被执行。
  
R中没有专门的`elseif`语句，但用`else`加上`if`能实现同样的效果。`else if`可以添加在`if`语句之后，顾名思义（“或者如果”），它的作用是，如果前一个`if`测试的条件为`FALSE`，那么再新加一个测试条件。一整个`if/else/else if`代码块里可以包含多个`else if`. 

注意，不能直接用`x == NA`来判断`x`是否是`NA`，而要用`is.na(x)`. 否则会得到`NA`的结果。

#### `ifelse()`函数 {#control-flow-rigorous-ifelse-fun}

`ifelse()`是`if`/`else`语句的向量化版本。假设我有一组长度：

```{r}
l <- c(1.21, 1.34, -1.45, 1.56, 1.22, 1.10, 1.78, -1.33, 1.71)
```

我们发现有两个值是负数。长度不可能是负数，因此这些测量结果是错误的，我们需要把它们替换成`NA`. 这时可以用`ifelse()`函数：

```{r}
l_1 <- ifelse(l < 0, NA, l)
l_1
```

#### for循环 {#control-flow-rigorous-for}

以下是R中for循环的伪代码：

```{}
for(i in <vector/list>) {
  <do something> on every i
}
```

当`<vector/list>`是一个向量时，这个for循环会对那个向量里所有的元素依次执行大括号里的命令（即`<do something>`），比如

```{r}
x <- c(1, 4, 9)
y <- c(1, 10, 100)

for(i in x){
  print(i * y)
}
```

`for(i in x)`中`i`的意思是`x`中的元素。`x`中有三个元素，每个元素都是一个`i`. 因此大括号里写的`print(i * y)`便是各个元素` * y`的意思。可以看到，这个for循环对于`x`里的三个元素，`1`, `4`, 和`9`**分别**执行了三次“乘以`y`”的计算，分别得到`1 10 100`, `4 40 400`, `9 90 900`的结果，与

```{r}
1 * y; 4 * y; 9 * y
```

是等效的。

这个`i`可以替换成其他的名字（大括号内相应的名字也要变），比如：

```{r eval=FALSE}
for(num in x){
  print(num * y)
}
```

注意到一个for循环实际上返回了多个结果（这里是三个）。这在实际操作中并不是很有用。更多的实际应用没必要在这里赘述，在以后的使用中会有很多例子，现在需要做的只是能看懂它的逻辑。

如果是对一个列表（list）使用for循环，每个`i`是一个分量。关于列表的内容在第\@ref(list)节，为进阶内容，可酌情阅读。

#### while循环 {#control-flow-rigorous-while}

以下是R中while循环的伪代码：

```{}
while(<some condition is TRUE>) {
 repeat doing something
}
```

小括号里的内容必须是一个计算结果为`TRUE`或`FALSE`的表达式（和`if`/`else`语句类似）。当这个条件为`TRUE`时，大括号内的语句将会被执行，直到小括号里的判别结果为`FALSE`. 需要注意的是，不要让小括号里的运算结果一直为`TRUE`, 否则会造成无限循环。一个错误的例子是：

```{}
i <- 1
while (i < 5) {
  print(i * 10)
}
```

`i`永远小于5，所以是一个无限循环。我们只需每次执行大括号里的计算时给`i`增加一定的值，即可解决这个问题：

```{r}
i <- 1
while (i < 5) {
  print(i * 10)
  i <- i + 1
}
```

当`i`被加到5时候，`i`不再小于5，因此大括号内的语句不再执行。

#### `break`和`next` {#control-flow-rigorous-break-next}

`break`可用来跳出当前所在的for或while循环。

```{r}
for(i in 1:10){
  if(i <= 3){
    print(i)
  } else break
}
```

可以看到，本来应对1至10逐个执行`print`，但当`i`等于4时，`i`不再小于等于3，触发`else`后的`break`, 结束for循环。While循环也是同样的道理：

```{r}
i <- 1
while(i < 10){
  if(i <= 3){
    print(i)
    i <- i + 1
  } else break
}
```

对于for循环，我们可以用`next`跳过一个元素/分量，比如：

```{r}
for(i in 1:5){
  if(i == 3 | i == 4) next
  print(i)
}
```

可以看到3和4被跳过了。

对于多层嵌套的循环，`break`和`next`仅作用于当前所在的循环，比如：

```{r}
for(i in 1:3){
  for(j in c(1, 10, 100)){
    if(i == 2) break
    print(i * j)
  }
}
```

像这样的结构，可以理解为，对于`i`等于1，2和3，分别执行3次（独立的）里面的for循环。

当`i`等于2时，`break`被触发，但只是退出了里面那个for循环，而外面的for循环继续，使`i`等于3，然后重新执行另一次里面的for循环（因`i`不等于2，这一次不会被打断）。

### 如何避免for循环——`apply()`家族函数 {#apply}

R中的循环效率是很低的，尤其是有多层嵌套。通过`system.time()`函数，看看你的电脑执行以下运算需要花多少秒：（`system.time()`函数在第\@ref(system-time)小节有介绍）。如果你还不熟悉R中的函数，不妨先看完第\@ref(functions)节。

```{r eval=FALSE}
x <- vector("numeric")
system.time(
  for (l in 1:40) {
    for (m in 1:50) {
      for (n in 1:60) {
        x <- c(x, l*m*n)
      }
    }
  }
)
```

我的i5处理器(i5-8259U CPU @ 2.30GHz)花了39秒左右才能算出来，然而看起来计算量并不大：
$$x = \left(1\times1\times1, 1\times1\times2\ldots, 40\times50\times59, 40\times50\times60\right)$$
一共有$40\times50\times60 = 120000$次计算. 一个原因是，无论你的CPU有多少核心，R默认只会使用其中的一个进行计算。在第\@ref(parallel)节中介绍了开挂使用多核的方法。但是它治标不治本，解决for循环缓慢的终极方案是避免使用for循环，而使用向量化的方法进行计算 (vectorized computation)。在第\@ref(vectorization-basics)我介绍了简单的（二元）向量化计算。除了二元运算以外，很多时候，复杂的for循环也能用向量化计算实现。我们需要用到`apply()`家族的一系列函数：`apply()`, `sapply()`, `lapply()`, `mapply()`, `tapply()`, `vapply()`, `rapply()`, `eapply()`；此外，像`Map()`, `rep()`, `seq()`等函数也会执行向量化的计算。

在学习它们的用法之前，先来看一个直观的数据：

|方法|$(L,M,N)=(1:40,1:50,1:60)$|$(L,M,N)=(1:500,1:600,1:700)$|
|:-------|:----------------:|:--------------------:|
|普通（单核）for循环 |39秒  |等了一小时，无果，遂弃|
|开挂（四核）for循环|12.304秒；CPU巨热|怕CPU炸，不敢试|
|`sapply()`|0.001秒         | 2.719秒              |
|`rep()` |0.002秒           | 2.825秒              |
|`rapply()` |0.003秒           | 2.094秒           |

同样是运算上面那个for循环花了39秒的例子，使用`sapply()`函数和`rep()`函数几乎是瞬间完成；而把$(l,m,n)$增至$(1:500,1:600,1:700)$时（计算量为1750倍），它们仍只需不到3秒，而for循环则是不可行的。

至于如何用这些函数算出来，就作为本章的练习（见第\@ref(test-base-advanced)节）。

#### `lapply()` {#apply-lapply}

`lapply()` (list apply)至少需要两个参数，第一个是对象（可以是vector或者list），第二个是函数。它的作用是把函数作用于对象中的每一个元素，并返回一个list. 无论对象是vector还是list, 返回的都是一个list. 

有两类使用`lapply()`的方法。第一种是使用匿名函数，这个很直观：

```{r}
lapply(c(1, 2, 3), function(i) i^2*10)
```

另一种是使用有命名的函数。此时，第二个参数是函数名；随后，如果有需要，还可以加上这个函数需要的其它参数：

```{r}
lapply(list(5, 6, 7), rnorm, 3, .1)
```

默认`lapply()`的对象的各元素作为函数的第一个参数。上面这个例子等同于：

```{r eval=FALSE}
list(rnorm(5, 3, .1), # 即 `rnorm(n = 5, mean = 3, sd = .1)`
     rnorm(6, 3, .1),
     rnorm(7, 3, .1))
```

当第一个参数在后面被指定时，`lapply()`的对象的各元素所代表的参数按照排序顺延，比如：

```{r}
lapply(list(5, 6, 7), rnorm, n = 3, .1)
```

等同于：

```{r eval=FALSE}
list(rnorm(n = 3, 5, .1),
     rnorm(n = 3, 6, .1),
     rnorm(n = 3, 7, .1))
```

但是这么做会降低易读性。当对象不是被作为函数的第一个参数时，最好使用匿名函数，使之更易读：

```{r eval=FALSE}
lapply(list(5, 6, 7), function(x) rnorm(3, x, .1))
```

#### `sapply()` {#apply-sapply}

`sapply()` (simplified list apply)的功能本质上和`lapply()`一样。`sapply()`额外的一个特点是尽可能地化简结果：

- 当结果只有一个分量时，`sapply()`返回一个vector
- 当结果有多个分量，但每个分量只包含一个vector且长度相等时，`sapply()`会返回一个matrix

试试以下计算：

```{r eval=FALSE}
lapply(c(1, 2, 3), function(i) i*10)
sapply(c(1, 2, 3), function(i) i*10)

lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10)
sapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10)

lapply(list(1, 2, 3), function(i) i*c(1, 10, 100))
sapply(list(1, 2, 3), function(i) i*c(1, 10, 100))

lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10)
sapply(list(c(1, 2, 3), c(4, 6), c(7, 9)), function(i) i*10)
```

#### `rapply()` {#rapply}

`lapply()`无法使用宇含有子列表的列表。比如，你可以尝试：

```{r eval=FALSE}
lapply(list(c(1, 2, 3), list(c(4, 5, 6))), "*", 10)
```

`rapply()`是`lapply()`的recursive版本，它可以使用于含有子列表的列表，并且有三种使用模式，其中两种比较常用。第一种是`unlist`, 它是默认的模式。它会在计算之后拆解列表至单个向量：

```{r}
rapply(list(c(1, 2, 3), list(c(4, 5, 6), list(7, 8, 9))), function(x) x * 10, how = "unlist") # 默认的模式
```

这可能会造成数据类型的强制转换：

```{r}
rapply(list(c(1, 2, 3), list(c(4, 5, 6), list(c("a", "b", "c")))), function(x) c(x, 1))
```

第二种模式，`list`，则保留了原列表的结构：

```{r}
rapply(list(c(1, 2, 3), list(c(4, 5, 6), list(c("a", "b", "c")))), function(x) c(x, 1), how = "list") 
```

#### `mapply()`和`Map()` {#mapply-and-Map}

`lapply()`和它的衍生产物`sapply()`和`rapply()`本质上是把一个函数应用在**一个**向量/列表上，即这个向量/列表作为函数唯一的“自变量”。`Map()`则可以使用多组自变量。这意味着，`lapply()`能做到的，`Map`都能做到；`Map`能做到的，`lapply()`不一定做得到。

之前`lapply()`的例子`lapply(c(5, 6, 7), rnorm, n = 3, .1)`的`Map()`版本是这样的：

```{r}
Map(rnorm, c(5, 6, 7), 3, .1)
```

多个自变量的计算也很自然：

```{r}
Map(rnorm, c(2, 3, 4), c(1, 10, 100), c(.1, .5, 1))
```

`mapply()`是`Map()`的自动化简版本：

```{r}
mapply(rnorm, 3, c(1, 10, 100), c(.1, .5, 1))
```

想一想，`Map(rep, list(c(1,2), list(2,3)), 3)`的计算结果是什么？

### `foreach` package：for循环的进化版 {#foreach}

```{r include=FALSE}
require(doParallel)
```

`foreach` package相对于base R中的for循环增加了一些特性，不过最实用的是支持多核并行运算：

#### 使用多内核进行计算 {#parallel}

首先需要安装和使用`doParallel`，然后才可以使用`foreach`中的`%dopar`进行多核并行运算。

查看和设置内核数量：

```{r}
library(doParallel)
getDoParWorkers() # 查看R当前使用的内核数量；默认应为1
detectCores() # 查看可用内核总数
```

```{r}
registerDoParallel(4) # 设置内核数量
getDoParWorkers() # 再次检查内核数量
```

设置完之后就可以使用`%dopar`进行多核并行运算了：

```{r eval=FALSE}
x <- foreach(l = 1:40, .combine = "c") %dopar% {
    foreach(m = 1:50, .combine = "c") %dopar% {
        foreach(n = 1:60, .combine = "c") %do% {
        l*m*n
        }
    }
}
x
```

相比单核for循环的39秒，开挂（四核）的速度是12秒（计算量越大，优势越明显）。

### `purrr` package中的`apply`家族函数替代品和进化产物 {#apply-purrr}

这一节需要使用`purrr`, 它是`tidyverse`的一部分。所以我们首先要加载它：

```{r eval=FALSE}
library(tidyverse) # 或library(purrr)
```


#### `map()`, `map_dbl()`, `map_chr()`, ... {#purrr-map-map_dbl}

`map()`的使用方法和`lapply()`几乎一样。`lapply(list(5, 6, 7), rnorm, 3, .1)`用`map()`转写就是`map(list(5, 6, 7), rnorm, 3, .1)`。`map()`（和下面介绍的其他函数）有一个绝招就是简写匿名函数。在第\@ref(apply-lapply)节讲过，`lapply()`的对象默认会被作为函数的第一个参数（`map()`也是如此）。当不想让它作为第一个参数的时候，要使用匿名函数以保证易读性：

```{r eval=FALSE}
lapply(list(5, 6, 7), function(x) rnorm(3, x, .1))
```

用`map()`的简写版本则是：

```{r}
map(list(5, 6, 7), ~ rnorm(3, ., .1))
```

`map_dbl()`, `map_chr()`函数可以把结果化简为一个向量，前提是每次的计算结果的长度都为1（即一个标量），比如这里，`mean(x)`, `mean(y)`, `mean(z)`的结果都是一个标量，所以`map()`的结果可以化简为一个浮点数向量。

```{r}
x = c(1, 2, 3); y = c(10, 20, 30); z = c(5, 60, 115)
map_dbl(list(x, y, z), mean)
```

#### `map2()`和`pmap()系列 {#purrr-map2-pmap}

`map2()`使用两个因变量。

```{r}
map2(.x = c(1, 100, 10000), .y = c(.1, 1, 10), ~ rnorm(5, .x, .y))
```

`pmap()`使用多个因变量。与Base R的`Map()`不同，`pmap()`的第一个参数是对象，第二个才是函数。你可以使用命名列表来指定使用的函数的参数：

```{r}
pmap(list(mean = c(1, 100, 10000), sd = c(.1, 1, 10)), rnorm, n = 3)
```

 下一章会讲到，因为dataframe/tibble的本质是list，上面的操作也可以适用于tibble：
 
```{r}
args <- tibble(mean = c(1, 100, 10000),
               sd = c(.1, 1, 10))
pmap(args, rnorm, 3)
```

## 函数 {#functions}

### R中的函数 {#functions-in-R}

不像很多其他语言的函数（和方法）有`value.func()`和`func value`等格式，R中所有函数的通用格式是这样的：

```{}
function(argument1 = value1, argument2 = value2, ...)
```

比如

```{r}
sample <- c(5.1, 5.2, 4.5, 5.3, 4.3, 5.5, 5.7)
# 根据传统，赋值变量时用`<-`号，赋值函数参数时才用`=`
t.test(x = sample, mu = 4.5)
```

二元运算符和`[`（取子集符号）看起来一点都不像函数，而实际上它们也是函数，因此也可以用通用的格式使用他们，只是需要加上引号或转义符号：

```{r eval=FALSE}
"+"(2, 3)
`+`(2, 3)
## 5
```

```{r collapse=TRUE}
"["(c("四川担担面", "武汉热干面", "兰州牛肉面", "北京炸酱面"), 2)
```

可自定义的二元运算符形式为`%x%`, 其中`x`为任何字符。（见第\@ref(binary-operaters)节）

英语中，“parameter”或“formal argument”二词用于函数定义，“argument”或“actual argument”二词用于调用函数[@Kernighan1988The-C-Programming-La]，中文里分别是“形式参数”和“实际参数”，但是多数场合简称“参数”。

### 调用函数 {#abbr}

根据通用格式（`function(argument1 = value1, argument2 = value2, ...)`）调用函数。对于二元运算符，`a %x% b`等价于`"x"(a, b)`.

从“`function(`”开始到此函数结尾的“`)`”中间为（实际）参数，各参数用逗号隔开，空格和换行会被忽略，“`#`”符号出现之处，那一行之后的内容都会被忽略。这意味着你可以（丧心病狂地）像这样调用一个函数。

```{r}
sum        (
 # 4   
        4 # 我怕不是
,              #疯了
            6
  
  )
```

它实际的好处是，当参数很长或是有嵌套的函数时，可以通过换行和空格使代码更易读，就像其它的编程语言一样。（后面会有很多例子）

函数的参数以`seq`函数为例，通过查看帮助文档（在console执行`?seq`），通常在`Usage`一栏，可以查看它的所有的（形式）参数及其排序：

```{}
## Default S3 method:
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)
```

可以看到第一个参数是`from`，第二个是`to`，第三个是`by`，以此类推。我们执行`seq(0, 50, 10)`的时候，R会理解成`seq(from = 0, to = 50, by = 10)`。而想用指定长度的方法就必须要写清楚是`length.out`等于几。

`length.out`本身也可以简写：

```{r}
seq(0, 25, l = 11)
```

因为参数中只有`length.out`是以`l`开头的，`l`会被理解为`length.out`. 但是这个习惯并不好；自己用用就算了，与别人分享自己的工作时请尽量使用参数名的全称。

对于`seq(0, 50, 10)`，亦可写成`seq(by = 10, 0, 50)`. 这是因为`by`参数先赋值，`0`和`50`是未命名的参数，所以按照剩余的参数的排列顺序来，即`from = 0, to = 50`. 同理，`seq(to = 50, 0, 10)`也是等价的。

### 创建函数 {#create-functions}

#### 普通函数 {#general-functions}

```{r}
函数名 <- function(参数1, 参数2, ...){
  对参数1和参数2
  进行
  一系列
  一行或者多行
  计算
  return(计算结果)
}
```

在R中，函数是作为对象保存的，因此定义函数不需要一套另外的符号/语句，还是用赋值符号`<-`，和`function()`函数。

R自带了计算样本标准差 (standard deviation, $s$)的函数, `sd()`，我们可以根据它写一个计算均值标准差（即“标准误”, standard error）（$SE=s_{\bar{x}}=\frac{s}{\sqrt{n}}$）

```{r}
SE <- function(x) {
  s <- sd(x)
  n <- length(x)
  result <- s/sqrt(n)
  return(result)
}
# 随后，你就可以使用自定义的函数了
SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) 
```

这里其实可以做一些省略。很多时候，最后一“句”的**计算结果**（不是赋值计算）就是我们想`return`的结果。因此，这时`return`可以省略：

```{r}
SE <- function(x) {
  s <- sd(x)
  n <- length(x)
  s/sqrt(n) # 注意不是`result <- s/sqrt(n)`
}
SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) 
```

很多时候，函数内部有复杂流程控制，这时使用`return()`可以很大地增强易读性：

```{r}
# 这是随手写的一个没有意义的函数
myfunc <- function(i){
  k <- 8
  if (i>3) {
    j <- -i
    while(j < 20){
      k <- k + i + j
      j <- j+5
    }
    return(k)
  } else {
    if (i %% 2 == 0) {
      return(5)
    } else return(k*i)
  }
}
myfunc(6)
```

本章剩余的内容，都是比较进阶的了。可以酌情从这里跳转至本章第\@ref(test-base)节。

#### 匿名函数 {#anonymous-functions}

函数不需要名字也可以执行。一般，会与`apply`族函数联用（见第\@ref(apply)节）：

```{r}
sapply(1:5, function(x) x^2)
```

或者用于


#### 二元运算符 {#binary-operaters}

定义二元运算符的方式和定义普通函数的方法极其类似，只是参数必须要有且仅有两个（否则作为“二元”运算符就无意义了），且运算符名称需要用引号包围。

比如我们可以定义一个计算椭圆面积的函数

```{r}
'%el%' <- function(x, y) pi*x*y

2 %el% 5
```

原则上，可自定义的二元运算符不一定要用`%`包围；`+`, `-`, `:`等符号的功能都可以被自定义，但是它们是R自带的，非常常用的函数，重定义它们只会带来麻烦。

#### 闭包 (Closure) {#closure}

函数里可以包含着另一个函数，这就形成了一个闭包：

```{r}
myfunc <- function(){
  a = 5
  function(){
    b = 10
    return(a*b)
  }
}
# 执行myfunc()的时候，默认结果为最后一句/一行，在这里应为内函数：
myfunc()

# 既然`myfunc()`的结果是一个函数，那么在后面再加上一个括号就是执行内函数了；内函数可以使用外函数中所定义的变量（比如这里使用了外函数的`a = 5`）
myfunc()()
```

```{r}

speak <- function(x){
  x()$speak
}

speak(cat)

```

利用闭包，可以使用R中的简易的函数实现伪·OOP（R中的真·OOP是有三种，S3，R6和S4），这是本章末的[挑战题](#test-base-challenge)。

### 关于`...` {#about-dot-dot-dot}

有时候，你想写的函数可能有数量不定的参数，或是有需要传递给另一个函数的“其他参数”（即本函数不需要的参数），这时候可以在函数定义时加入一个名为`...`的参数，然后用`list()`来读取它们。list是进阶内容，在第\@ref(list)节有说明。

比如我写一个很无聊的函数：

```{r}
my_func <- function(arg1, arg2 = 100, ...){
  other_args <- list(...)
  print(arg1)
  print(arg2)
  print(other_args)
}

my_func("foo", cities = c("崇阳", "Αθήνα", "つがる"), nums = c(3,4,6))
```

`arg1`指定了是`"foo"`（通过[简写](#abbr)），因此第一行印出`"foo"`;  `arg2`未指定，因此使用默认值`100`，印在第二行。`cities`和`nums`在形式参数中没有匹配，因此归为"..."，作为list印在第三行及之后。

下面是一个（没有意义的）利用`...`做一个对于向量和列表通用的函数`calc()`，使`calc(data, pow = a, times = b, add = c)`返回与原数据`data`的结构相同，但各元素$x$变为$bx^a+c$的向量/列表（这和OOP有相似之处）：

```{r}
calc_v <- function(v, pow = 1, times = 1, add = 0) {
  v ^ pow * times + add
}

calc_l <- function(L, pow = 1, times = 1, add = 0) {
  rapply(L, function(l) l ^ pow * times + add, how = "list")
}

calc <- function(data, ...) {
  if(is.list(data)) {
    calc_l(data, ...) # 即 calc_l(L = data, ...)
  } else if(is.vector(data)) {
    calc_v(data, ...) # 即 calc_v(v = data, ...)
  }
}
```

```{r}
calc(c(1, 2, 3), pow = 2, add = 1)
calc(list(1, 2, list(10, 20)), pow = 2, times = 2)
```

`pow`, `times`和`add`不是`calc`的参数，它们以`...`的形式被传递给`calc_l()`和`calc_v()`.

在第\@ref(apply-sapply)节讲到，`sapply()`的功能本质上和`lapply()`一致，只是会化简结果。我们看一下`sapply()`函数的结构：

```{r}
sapply
```

可以看到，`answer <- lapply(X = X, FUN = FUN, ...)`这一行把`sapply()`里`...`中的参数传递到了`lapply()`中，使用`lapply()`得到未化解的结果`answer`, 随后仅需要写用来化简结果的代码，而不需要把与`lapply()`里的代码重写一遍。

### 赋值函数外的对象 {#functions-assign-global}

函数内的赋值一般只在函数内有效，比如：

```{r}
x <- 5
fun1 <- function() {
  x <- 100
}
fun1()
x
```

使用`assign()`函数可以在**函数内**赋值任意environment中的对象，其中最常见的是Global environment里的（即等价于在console中直接赋值）。

```{r}
x <- 5
fun1 <- function() {
  assign("x", 100, envir = .GlobalEnv)
}
fun1()
x
```

`<<-`[^super-ass]可用于赋值“上一层”里的对象。当在“第一层”的函数里使用`<<-`时， `.GlobalEnv`里对应的对象就会受到影响，即和`assign("x", value, envir = .GlobalEnv)`等效。

[^super-ass]: `<<-`符号的名字叫做“super assignment”（超级赋值）

```{r}
x <- 5
fun1 <- function() {
  x <<- 100
}
fun1()
x
```

在下面的例子中，`fun2()`赋值了`fun1()`里的`n`, 但`.GlobalEnv`里的`n`不受影响。

```{r}
n <- 1 # `GlobalEnv`里的`n` = 1

fun1 <- function() {
  n <- 10 # `fun1()`里的`n` = 10
  fun2 <- function() {
    n <- 50 # 赋值`fun2()`里的`n`
    n <<- 100 # 重赋值`fun1()`里的`n`为100
  }
  fun2() # 运行`fun2()`
  return(n) # 返回`fun1()`里的`n`
}

fun1() # 10是否变为100?
n # 是否仍然是1？
```

利用这个性质，我们可以使`apply()`族函数进行递归计算，比如求累加和：

```{r}
cum = 0
sapply(1:10, FUN = function(x){
  cum <<- cum + x
  cum
})
```

原则上，这已经不是一个向量化计算了，但是在这个例子中`sapply()`仍然比for循环（见下）速度更快。

```{r eval=FALSE}
cum = 1
  for (i in 2:10000) {
    cum[i] <- cum[i-1] + i
  }
cum
```

### 测速 {#system-time}

当你开始处理复杂，大量的数据时，或是向别人分享自己的代码时，代码执行的速度变得重要。

一段代码/一个函数经常有很多种写法，哪种效率更高呢？实践是检验真理的唯一标准，R提供了一个测速函数：`system.time()`函数。

```{r}
x <- vector('numeric')
system.time(
  for (i in 1:50){
    for (j in 1:100) {
      x <- append(x, i*j)
    }
  }
)
```

其中第三个数字 (`elapsed`)是执行`system.time()`括号内的语句实际消耗的时间。可以使用索引 (`[3]`)抓取。

如果括号内的语句大于一句，像这样：

```{r eval=FALSE}
system.time(
  1 + 1
  2 + 1
)
```

R会报错。就像流程控制里学到的那样，需要用大括号包围多行/多句的语句，就像这样：

```{r eval=FALSE}
system.time({
  1 + 1
  2 + 1
})
```

## 小测 {#test-base}

### 基础 {#test-base-basics}

1. **向量取子集和逻辑运算。**

    ```{r}
x <- c(3, 4, 6, 1, NA, 8, 2, 5, NA, 9, 7)
    ```
    
    `x[-c(1, 3)]`, `x[(length(x)-3):length(x)]`, `x[x < 5]`, `x[!(x < 5)]`的计算结果分别是？如何得到（不包含`NA`的）所有小于5的值的向量？
    
1. **转换年份到世纪。**写一个名为`as.century()`的函数，把存储着年份的向量，比如`years <- c(2014, 1990, 1398, 1290, 1880, 2001)`，转换成对应的世纪（注意，19XX年是20世纪），像这样：

    ```{r include=FALSE}
as.century <- function(x) x%/%100 + 1
    ```

    ```{r}
as.century(c(2014, 1990, 1398, 1290, 1880, 2001))
    ```

1. **分割时间为时和分。**写名为`hour()`, `minute()`的函数，使得：
    ```{r include=FALSE}
hour <- function(x) x%/%100
minute <- function(x) x%%100
    ```

    ```{r}
times <- c(0512, 0719, 2358, 0501)
hour(times)
minute(times)
    ```

1. **斐波那契数列。**
  - **背景：**斐波那契数列是指$F = [1, 1, 2, 3, 5, 8, ...]$[^fibon]，其中：
    - $F_1 = 1$，$F_2 = 1$
    - 从$F_3$开始，$F_i = F_{i-2} + F_{i-1}$ 
  - (也有$F_0=0, F_1=1$的说法，但是为了方便我们不用这个定义)
  - **题目：**创建一个函数名为`fibon()`的函数，使得`fibon(i)`：
    - 当$i\in \mathbb{Z}^+$时，返回向量$[F_1, F_2, \ldots, F_i]$
    - 当$i\notin \mathbb{Z}^+$时，返回`` "请输入一个正整数作为`fibon()`的参数。" `` [^error-warn]
  - **提示：**
    - 虽然在R中整数用`1L`, `2L`等表示，用户在被指示“输入整数”的时候很有可能输入的是`2`而不是`2L`. `2`是否等于`2L`?如果是，如何利用它检测输入的是否是整数？（`2`和`2L`都要被判定为“是整数”）
    - 斐波那契数列前两位是定义，从第三位开始才是计算得出的。
    
[^fibon]: 也有$F_0=0, F_1=1$的说法，但是为了方便我们不用这个定义。
[^error-warn]: 虽然正规的做法是制造一个错误/警告

```{r include=FALSE}
fibon <- function (len = 10) {
  if (len == as.integer(len) & len > 0) { #
    F <- c(1, 1) ## 前两项需要定义
    i <- 3 ## 从第三项开始计算
    while (i <= len) {
      F[i] <- F[i-2] + F[i-1]
      i <- i+1 ## R中不可以使用`i += 1`或者`i++`
    }
    return(F[1:len])
  } else {
    return("请输入一个正整数。")
  }
}
```

使用例：

```{r}
fibon(10); fibon(-5)
```

### 进阶 {#test-base-advanced}

1. `seq(0, 20, 5)`, `seq(by = 5, 0, 20`, 和`seq(by = 5, 0, y = 30, 20)`的结果分别是什么？为什么？（你可能需要参考第\@ref(abbr)节和第\@ref(about-dot-dot-dot)节）

1. 分别用`sapply()`, `rep()`, 和`rapply()`创建第\@ref(apply)节提到的数列：$$x = \left(1\times1\times1, 1\times1\times2\ldots, 40\times50\times59, 40\times50\times60\right)$$

1. **质数表。**创建一个`prime.list()`函数，使`prime.list(i)`得到$(2, 3, 5, 7, 11, ... n)$, 其中`i`为大于或等于`3`的整数，$n$为小于`i`的最大质数。

    ```{r include=FALSE}
prime.list <- function(i){
  primeNumbers <- 2L
  for (num in 3:i) {
    isPrime <- TRUE
    for (pnum in primeNumbers) {
      if (pnum > sqrt(num)) {
        break
      } else if (num %% pnum == 0) {
        isPrime <- FALSE
        break
      }
    }
    if (isPrime) {
      primeNumbers <- c(primeNumbers, num)
    }
  }
  return(primeNumbers)
}
    ```

    ```{r}
prime.list(100)
    ```

    你能想到几种方法？哪一种更快？为什么？
    
1. **判断一个数是否是质数。**写一个函数，判断一个数是否是质数。

### 挑战 {#test-base-challenge}

1. 使用且仅使用`function()`, `c()`, `list()`, `paste()`, `print()`函数，`<-`, `$`, `==`符号，和`if`，实现这样的效果：

    ```{r include=FALSE}
Pet <- function(name = NA, common_name = NA, binomial_name = NA, speak = NA){
  name <- name
  common_name <- common_name
  binomial_name <- binomial_name
  speak <- speak
  greet <- function(time = "not_specified"){
    intro <- paste("I'm a", common_name, "and my name is", name)
    if(time == "morning") print(paste("Good morning,", intro))
    if(time == "afternoon") print(paste("Good afternoon,", intro))
    if(time == "evening") print(paste("Good evening,", intro)) 
    if(time == "not_specified") print(paste("Hi,", intro))
  }
  list(name = name, common_name = common_name, binomial_name = binomial_name, speak = speak, greet = greet)
}


Turtle <- function(name = NA){
  Pet(name, "turtle", "Trachemys scripta elegans") # 实现inheritance # 龟没有叫声
}

Cat <- function(name = NA, sterilized = NA){
  sterilized <- sterilized # 猫可能绝育 # 新增attribute，实现了广义的polymorphism
  PetAaM <- Pet(name, "cat", "Felis catus", "meow")
  CatOnlyAaM <- list(sterilized = sterilized)
  c(PetAaM, CatOnlyAaM)
}

Pigeon <- function(name = NA){
  PetAaM <- Pet(name, "pigeon", "Columba livia", "coo")
}

# 实现了Python语境中的polymorphism
greet <- function(pet, time = "not_specified"){
  pet$greet(time)
}

binomial_name <- function(pet){
  pet$binomial_name
}
    ```

    `Pigeon()`, `Turtle()`, `Cat()`分别创建一只鸽子， 一只乌龟和一只猫（即产生一个list，各自的元素展示如下）：

    ```{r}
Guoguo <- Pigeon("Guoguo")
Felix <- Cat("Felix", "TRUE")
Kazuya <- Turtle("Kazuya")

str(Guoguo)
str(Kazuya)
str(Felix)
    ```

    注意，鸽子，乌龟和猫都有名字 (`name`)，通称 (`common_name`)，学名 (`binomial_name`)，和打招呼函数 (`greet()`)；此外，乌龟没有叫声`speak()`，猫额外地有绝育`sterilized`信息。可以这样查看信息和使用打招呼函数：

    ```{r}
Felix$binomial_name
Kazuya$greet("afternoon")
    ```

    其中`greet()`的参数如果是`morning`, `afternoon`或`evening`，则返回`"Good <时间段> ..."`，否则返回`"Hi ..."`.

    此外，另写两个仅对这些宠物使用的函数`binomial_name()`和`greet()`，使之能够这样使用：

    ```{r}
binomial_name(Kazuya)
greet(Guoguo)
    ```

    **你可能需要的额外信息：**

    鸽子，乌龟和猫的学名分别为*Columba livia*, *Trachemys scripta elegans*, *Felis catus*. 

    `paste()`函数把多个字符串拼接成一个，其中参数`sep`指定连接符号，默认为空格：

    ```{r}
x <- "world"
paste("Hello", x, "Bye", x, sep = "---")
    ```

