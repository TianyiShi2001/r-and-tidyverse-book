[
["index.html", "R与tidyverse——数据分析入门 欢迎", " R与tidyverse——数据分析入门 石天熠 2019-07-17 欢迎 简介 本书为R和tidyverse的入门向教程。教学视频在b站（还没开播，从6月中旬一直跳票到8月初）。附加资源在R-Tutorial-Resources Github仓库。 本书有Gitbook版本 (https://tianyishi2001.github.io/r-and-tidyverse-book/ )和通过XeLaTeX排版的PDF版本。 如果有写得不对的地方，欢迎批判、指正。 Gitbook版本使用说明 左上角的菜单可以选择收起/展开目录，搜索，和外观，字体调整。中文衬线体使用的是思源宋体。 如果你对某一段文字有修改意见，可以选择那段文字，并通过Hypothesis留言（选择“annotate”）。右上角可以展开显示公开的留言。首次使用需要注册。 如果你熟悉Bookdown和Github，可以在此提交pull request. 为什么写本书 在下一个版本中，我会写一个序言，解释我写这本书的原因。 简而言之，是为了实现知识的自由化——我人生的大目标（前提是我还有钱恰饭）——而做的初步探索。这本书并不是我理想中知识自由的世界的产物——事实上，像我写的这种自由获取的教程并不少见——但是我还是有必要亲自体验一下写这类书时遇到的问题，和这类书的局限性。 总之，这本书只是我的一个实验品。相比于其他专业的R教程，可能并没有什么优势。但是，我会对读者负责。如果你对本书的内容有任何意见，我一定会作出回应。 本书的结构 Hadley Wickham写R for Data Science的时候把绘图放在了第一章，随后再讲加减乘除和数据处理，他认为这样可以降低新人被劝退的概率。我虽然很喜欢他的书，但是我是一个比较保守的人，所以我把所有我认为是基础的内容放在了前面。 为了防止劝退，本书的内容分为基础部分和（相对）进阶部分；基础部分的段落中会有“可酌情跳过进阶部分”的提示，以帮助你流畅地看完基础部分。仅阅读基础部分即可学到最重要的知识；如学有余力可阅读进阶部分。 在本书你不会学到： 详细的统计学方法。我本身数学很差，教这个是要谢罪的。 Python (NumPy/SciPy)。在数据挖掘/数据分析领域，Python和R一样是我们的好伙伴，而且它们经常被联合使用。但是本书作为R的入门教程，应当专注于R。 SAS, SPSS, STATA等软件。它们是资本主义的邪恶产物。 版权页 This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 关于编写本书的技术信息 本书以R Markdown格式 (http://rmarkdown.rstudio.com/ )在RStudio (http://www.rstudio.com/ide/ )中编写。 knitr (http://yihui.name/knitr/ )和pandoc (https://pandoc.org/ )把Rmd文件编译成html和tex， LaTeX 将tex排版为PDF；这一系列操作是使用bookdown (https://bookdown.org )自动完成的。 本书的源码，Gitbook和PDF版本的书保存在https://github.com/TianyiShi2001/r-and-tidyverse-book/ ，其中Gitbook和PDF保存在/docs/目录下，由GitHub Pages生成静态网页，通过https://TianyiShi2001.github.io/r-and-tidyverse-book/ 访问。 编写本书使用的R packages，和排版本书时R的sessionInfo显示如下： utils::sessionInfo(c(&quot;tibble&quot;, &quot;dplyr&quot;, &quot;forcats&quot;, &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;, &quot;readr&quot;, &quot;purrr&quot;, &quot;yaml&quot;, &quot;lubridate&quot;, &quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;bookdown&quot;, &quot;doParallel&quot;, &quot;foreach&quot;)) ## R version 3.5.3 (2019-03-11) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS 10.15 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## character(0) ## ## other attached packages: ## [1] tibble_2.1.3 dplyr_0.8.3 forcats_0.4.0 ## [4] ggplot2_3.2.0 stringr_1.4.0 tidyr_0.8.3 ## [7] readr_1.3.1 purrr_0.3.2 yaml_2.2.0 ## [10] lubridate_1.7.4 rmarkdown_1.13.6 knitr_1.23 ## [13] bookdown_0.11 doParallel_1.0.14 foreach_1.4.4 ## ## loaded via a namespace (and not attached): ## [1] compiler_3.5.3 magrittr_1.5 graphics_3.5.3 tools_3.5.3 ## [5] htmltools_0.3.6 rstudioapi_0.10 utils_3.5.3 grDevices_3.5.3 ## [9] Rcpp_1.0.1 stats_3.5.3 datasets_3.5.3 stringi_1.4.3 ## [13] methods_3.5.3 xfun_0.8 digest_0.6.20 base_3.5.3 ## [17] evaluate_0.14 "],
["intro-and-installation.html", "Chapter 1 R和RStudio介绍和安装教程", " Chapter 1 R和RStudio介绍和安装教程 本章内容速览 第1.1节：对R和RStudio进行概念和功能介绍，并介绍安装方式。 第1.2节：很重要的一节。介绍了常用的帮助和学习资源获取方式。 第1.3节：带你快速熟悉RStudio界面和基本操作。 第1.4节：也很重要。介绍packages（包）的概念和功能，并引导安装本书需要使用的packages. "],
["what-is-R.html", "1.1 什么是R", " 1.1 什么是R R (R Core Team 2019)包含R语言和一个有着强大的统计分析及作图功能的软件系统，由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman共同开发。R语言虽然看起来只能做统计，实际上它麻雀虽小，五脏俱全，编程语言该有的特性它基本都有（甚至支持OOP）。 不要看到编程就害怕。使用R不需要懂编程。R语言最重要的特性之一就是，不懂编程的人可以轻松地用R自带的和和其他人编写的packages，实现99.9%他们想要的功能（主要是数据分析）；而懂编程的人可以轻松地使用编程，在R中实现他们想要的剩余的0.1%的功能。同时，R的编程语言非常简单易学，尤其是对于编程0基础的R使用者。像SAS，STATA这些商业软件，只能实现你95%的需求，且剩下的5%很难解决。 安装了R之后，你可以在其自带的“R”软件中使用（也可以直接在命令行使用），但是那个软件对新手的友好度不如RStudio. RStudio (RStudio Team 2015)是广受欢迎的R语言IDE（集成开发环境），它的一系列功能使得编辑，整理和管理R代码和项目方便很多。 了解更多R的优势，请看第1.1.2节 1.1.1 安装R和RStudio 1.1.1.1 安装R https://cran.r-project.org 前往CRAN，根据自己的操作系统（Linux，MacOS或Windows）选择下载安装R. (Linux用户亦可参考此处) 1.1.1.2 安装RStudio https://www.rstudio.com/products/rstudio/download/ 前往RStudio下载页，选择最左边免费的开源版本，然后选择对应自己的操作系统的版本，下载并安装。 1.1.2 为什么使用R，R与其他统计软件的比较1 （这一小节不影响R的学习进度，可以直接跳过到下一章） SAS，SPSS，Prism，R和Python是数据分析和科研作图常用的软件。 SAS，SPSS和Prism都是收费的，而且不便宜。比如SAS第一年需要10000多美元，随后每年要缴纳几千美元的年费。 R是GNU计划的一部分，因此R是一个自由软件 (Libre software)。它不仅免费，还允许用户自由地学习，运行该软件；拷贝，分发，修改并改进该软件，以帮助其他人。你可以 在GNU官网了解更多。 R比各种商业统计软件功能更强大。没错，免费的R比昂贵的商业软件功能更强大。所有SAS中的功能，都能在R中实现，而很多R中的功能无法在SAS中实现2。 R有巨大的用户社群3，其中有很多热心的使用者/开发者在论坛上解答问题，或是编写免费获取的教程。SAS等软件虽然有客户支持，但是如果你用的是盗版…… R（RStudio）非常稳定。闪退率极低，而且就算闪退了，也完全不会丢失上一次工作中的数据，可以无缝衔接上一次的工作。我经常会创建一两个实验用的R script文件，我不需要把它们命名并保存在我的工作目录，重启RStudio的时候仍然可以使用它们。总之，关闭RStudio的时候，你甚至可以什么都不用保存；关闭，重启，无忧无虑地继续工作。设置Git后体验更佳。 R与其它编程语言/数据库之间有很好的接口。 Python（NumPy和SciPy）是近几年兴起的数据分析处理方案。在数据分析的应用中，R比Python历史更悠久，因此积攒了很多很棒的packages（包）。一般来说，python的强项是数据挖掘，而R的强项是数据分析，它们都是强大的工具。不用担心需要在二者之中做选择，因为rpy, reticulate等packages可以让你在python中使用R，在R中使用python，详情请见第??章。无论你是数据分析零基础，还是有python数据分析的经验，都能从本书中获益。 至于Excel，它的定位原本就是办公（而不是学术）软件，数据分析的严谨性，大数据的处理能力，和功能的拓展非常局限。有五分之一的使用了Excel的遗传学论文，数据都出现了偏差 (Ziemann, Eren, and El-Osta 2016)。不是说不能用Excel（或者其它可用的工具），而是要清楚各种工具的优势和局限，物尽其用。比如当需要从PDF文件中提取表格数据时，我会把它们复制到Excel（因为兼容性强）；我也会用Excel做一些数据的初步处理，比如删除数量不多的冗余的行和列，重命名变量名等。 虽然R是自由软件，但是我们要记得感激所有位R贡献智慧的奉献者。出于对知识劳动的尊重和，以及保持R的发展壮大，我呼吁有能力出资的使用者在https://www.r-project.org/foundation/donations.html 对R进行捐赠。 References "],
["getting-help.html", "1.2 获取资源与帮助（重要！）", " 1.2 获取资源与帮助（重要！） 这本书可以帮助你快速学会R和tidyverse的最常用和最重要的操作，但这仅仅是冰山一角。当你在做自己的研究的时候，会用到很多这本书中没有讲到的方法，因此学会获取资源和帮助是很重要的。以下列举几个常用的获取R的帮助的网站/方法： 1.2.1 核心/入门资源 1.2.1.1 论坛类（解答实际操作中的问题） 爆栈网 (StackOverflow)是著名计算机技术问答网站（如果你有其他的编程语言基础，一定对它不陌生）。查找问题的时候加上[R]，这样搜索结果就都是与R相关的了（为了进一步缩小搜索范围，可以加上其他的tag，比如[ggplot], [dplyr])。注意，提问和回答的时候话语尽量精简，不要在任何地方出现与问题无关的话（包括客套话如“谢谢”），了解更多请查看其新手向导。 由谢益辉大佬在2006年（竟然比爆栈网更早！）创建的“统计之都”论坛，是做的最好的一个面向R的中文论坛（但是客观地来说活跃度还是没爆栈网高）同样不要忘记读新手指引。 1.2.1.2 Reference类（查找特定的function/package的用法） 直接在R console中执行?+函数名称或者package名或者其它，比如?t.test，可以查看对应函数的帮助文档（documentation）有一些函数/packages/内容名需要加上引号，比如?&quot;+&quot;, ?&quot;if&quot;。有一个相似的方法，??+&quot;内容&quot;可以根据你输入的内容搜索帮助文档，比如??&quot;probability distrubution&quot;。 RDocumentation上有基础R语言和来自CRAN，GitHub和Bioconductor上的近18000个packages的所有的函数的说明和使用例。 有些packages会在官网或github仓库提供使用说明，比如tidyverse 有些packages会提供vignettes，它们类似于使用指南，相比于函数的帮助文档更为详细且更易读。vignette()（无参数）以查看全部可用vignettes. 试试vignette(&quot;Sweave&quot;)。 1.2.1.3 教程和书籍类（用来系统地学习） R for Data Science by Garrett Grolemund &amp; Hadley Wickham. tidyverse的作者写的一本书，较为详细地介绍了tidyverse的用法以及一些更高深的关于编程的内容。（练习题答案） R for Beginners by Emmanuel Paradis及其中文译本 R的官方Manuals. 是一组严谨，全面但略微枯燥的文档，可能不太适合零基础的新手，但是对于精通R有很大的帮助。部分由丁国徽翻译成中文。 RStudio Resources是RStudio的资源区，有关于R和RStudio的高质量教程，还可以下载很多方便实用的Cheat Sheet. R的官方FAQ（在左侧菜单栏中找到“FAQ”） 存储在CRAN上的中文FAQ（注意这不是英文FAQ的翻译，而是一本独立的R入门教程） 1.2.1.4 速查表 (Cheat sheets)（用来贴墙上） R Reference Card 2.0 by Mayy Baggott &amp; Tom Short以及其第一版的中文翻译 RStudio Cheat Sheets包含了RStudio IDE和常用packages的cheat sheets。2019年版的合集在这里。 1.2.2 进阶资源 The R Book by Michael J. Crawley Advanced R by Hadley Wickham及其练习题答案。 CRC的The R Series Springer的Use R! Series。 Venables &amp; Ripley (2002). S Programming. "],
["interface-basics-project.html", "1.3 RStudio界面介绍，基本操作，和创建新项目", " 1.3 RStudio界面介绍，基本操作，和创建新项目 1.3.1 界面 1.3.1.1 概览 1.3.1.2 左下角：Console（控制台） Console是执行代码的地方。试试在里面输入1 + 1并按回车以执行。 1.3.1.3 左上角：Source（源） Source是写代码的地方。请看第1.3.3.3节。 这个位置也是用来查看文件和数据的地方。试试在console中执行View(airquality)或library(help = &quot;stats&quot;). 1.3.1.4 右上角：Environment（环境） Environment 是一个列表，显示了所有当前工作环境中所有的对象，包括变量（“values”和“data”）和自定义的函数（functions），并简要显示了它们对应的值。 History（历史）和 Connections（连接）不太常使用。 1.3.1.5 右下角：Plots（绘图），Help（帮助），Files（文件）和Packages（包） Plots是预览图像的区域。试试在console中执行hist(rnorm(10000)). Help是查看帮助文档的区域。试试在console中执行?hist或?norm. Files是查看文件的区域，默认显示工作目录 (working directory)。 Packages是安装/查看/更新packages（包）的区域。详情请看第1.4章。 1.3.2 执行代码 1.3.2.1 计算和赋值 我本来不想在开篇就写一小节使用较多的术语的文字，但是R中计算和赋值的概念实在太重要了，我不得不把它放在这里。 几乎所有R中的指令可以归为两种。计算 (evaluation)或者赋值 (assignment).4 没有&lt;-符号的为计算，有&lt;-符号的为赋值。 大多数情况下，计算仅仅会产生效果（或是在console输出结果，或是在plot区产生图像，或是在工作目录新建一个pdf文件），赋值会且仅会改变一个对象（变量）的值（包括新建一个对象），并且不会产生其他的效果。5 首先我们来做一个计算。 在console里输入1 + 1，并按回车以执行。你的console会显示： &gt; 1 + 1 [1] 2 其中2是计算结果， [1]是索引，在第2.1.2节有解释。&gt; 1 + 1是input，[1] 2是output. 还是用1 + 1举例，在本书中，对于input和output的展示格式是这样的： 1+1 ## [1] 2 注意input中的&gt;被省略了，这意味着你可以很方便地直接把代码从本书复制到你的console并按回车执行（因为console本身自带了&gt;)。 再执行以下指令（在RStudio中，可以用Alt+- (Mac是 option+-) 这个快捷键打出这个符号。）： x &lt;- 5*5+1 这是一个赋值指令。计算结果不会显示，但是你新建了一个名为x的变量（准确地说，是“对象”），值为5*5+1的计算结果，即26. 你可以执行x来查看x的值： x ## [1] 26 像一个小箭头的赋值符号（&lt;-）的作用是6，首先计算出其右边的指令（必须是一个计算指令；即同一条指令不可以出现两个&lt;-符号），然后把计算结果的值作为一个拷贝赋予给左边的名字，这样就新建了一个对象 (object)。每个对象有一个名称和一个值。7左右是很重要的；绝大多数其他的编程语言，虽然赋值符号是=，但也是从右往左赋值，R使用&lt;-作为赋值符号更形象，避免新手写出像5 = x之类的指令。当然，如果你喜欢，也可以在R中使用=。8 &lt;-用于给任何对象赋值，包括常用的向量 (vector)，列表 (list)，数据框 (dataframe)和函数 (function)。 谨记，赋值符号只是把右边的计算结果作为一个拷贝赋予给左边，而不会做任何其它的事情9。变化的仅仅是左边的变量（对象），右边的计算中所用到的任何变量（对象）不会改变！ 为什么强调是一个拷贝呢？举个例子，我们现在把x的值赋予给y，不出所料，y的值将为26。那么要是我们在这之后重定义x为40，y的值是多少呢？ y &lt;- x x &lt;- 40 y ## [1] 26 还是26（而不是40）。赋值是一次性的，每次被赋值的对象都将成为独立自主的个体。对象y虽然在被赋值的时候需要用到对象x，但是在那之后y和x半毛钱关系都没有了（除非再次赋值），所以x的变化不会影响y，y的变化也不会影响x。 所有的变化，只可能发生在赋值。 1.3.2.2 计算和函数 所有的计算都是通过函数实现的，包括当你输入x然后按回车时。10像+, -这样的运算符也是函数（参见第2.6.1节）。 函数的标志是小（圆）括号，比如sum(6, 7, 8)是求6, 7和8的和；其中sum()是函数，6, 7, 8是（三个参数）。 函数可以嵌套使用，而且很常见。 prod(sqrt(sum(2, 3, 4)), 2, 5) ## [1] 30 最“内部的”函数先运行，然后把计算结果作为它外面的函数的参数。这里，sum(2, 3, 4)得到9, sqrt(9)得到3, prod(3, 2, 5)得到30. 就像小学的时候学的括号运算规则一样。 更多关于函数的知识请参阅第2.6节。 1.3.3 管理代码 1.3.3.1 创建R Project 试着在console里输入（或者复制）以下代码并执行： attach(airquality) plot(Wind, Ozone, main = &quot;Ozone and Wind in New York City&quot;, pch = 20) model &lt;- lm(Ozone ~ Wind, airquality) abline(model, lwd = 2) 可以看到，在plots区，生成了一副漂亮的图。（先别在意每行代码具体的作用，在之后的章节我会一一讲述） 这时，把RStudio关掉，再重新启动，你会发现你的图没了。因此我们需要记录和管理代码。 初学者经常会在console里写代码，或者从别处复制代码，并执行。这对于一次性的计算（比如写统计学作业时用R来算线性回归的参数）很方便，但是如果你想保存你的工作，你需要把它们记录在R script文件里。如果你的工作比较复杂，比如有一个excel表格作为数据源，然后在R中用不同的方法分析，导出图表，这时候你会希望这些文件都集中在一起。你可以使用R Project来管理它们。 左上角File &gt; New Project 点选New Directory &gt; New Project 输入名称和目录并Create Project 1.3.3.2 使用R Project 在创建R project的文件夹中打开.Rproj文件。或者，RStudio启动的时候默认会使用上一次所使用的R project. 随后，你在RStudio中做的所有工作都会被保存到.Rproj所在的这个文件夹（正规的说法是“工作目录” (working directory)）。比如，在console中执行： pdf(&quot;normalDistrubution.pdf&quot;) curve(dnorm(x),-5,5) dev.off() 一个正态分布的图像便以pdf格式保存在了工作目录。你可以在系统的文件管理器中，或是在RStudio右下角File面板中找到。 1.3.3.3 写/保存/运行R script 在console中运行代码，代码得不到保存。代码需保存在R script文件（后缀为.R）里。 Ctrl+Shift+N（Mac是command+shift+N）以创建新R script. 然后就可以写R script. 合理使用换行可以使你的代码更易读。#是注释符号。每行第一个#以及之后的内容不会被执行。之前的例子，可以写成这样： # 读取数据 attach(airquality) # 绘图 plot(Wind, Ozone, # x轴和y轴 main = &quot;Ozone and Wind in New York City&quot;, # 标题 pch = 20) # 使用实心圆点 model &lt;- lm(Ozone ~ Wind, airquality) # 线性回归模型 abline(model, lwd = 2) # 回归线 点击你想执行的语句，按Ctrl+Enter (command+return)以执行那一“句”语句（比如上面的例子中，从plot(Wind...到pch = 20)有三行，但是它是一“句”），然后光标会跳至下一句开头。 Ctrl+Shift+Enter (command+shift+return)以从头到尾执行所有代码。 通过Ctrl（+Shift）+Enter执行代码时，相关代码相当于是从R script中复制到了console并执行。 试试复制并执行以上代码吧。 Ctrl+S (command+S)以保存R script. 保存后会在工作目录找到你新保存的.R文件。重新启动RStudio的时候，便可以打开对应的R script文件以重复/继续之前的工作。 1.3.4 RStudio的额外福利11 {rstudio-fuli} 1.3.4.1 括号/引号自动补齐；换行自动缩进 在RStudio中，除非你故意，否则很难出现括号不完整的错误。当你打出一个左括号/引号 ((, [, {, &quot;, ')时，对应的右括号/引号会自动补齐，同时光标移动到括号/引号的中间。 当你在括号中间换行时，右括号和光标会移动到正确的位置。举个例子，我打出下面这两段代码的时候不需要手动输入任何空格或者TAB来实现正确的缩进： mklog &lt;- function(x){ function(y){ log(y, x) } } x &lt;- tibble(nums = c(1, 2, 3), chars = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), cplx = c(1+5i, 2+3i, 6+8i)) 1.3.4.2 自动完成/建议提示/快速帮助 (autocomplete) 当你在console或者source区输入三个12或更多字母时，R会提示以这三个字母开头的所有对象（不一定是packages里的函数，也可以自定义的向量，列表，函数等等）。 然后，你可以用键盘的“上”，“下”键去选择，然后按回车键完成（或者用鼠标点选）。如果对象是一个函数，会自动帮你补齐括号。 注意，当你选中一个函数时，右边会有一个黄色的方框，提示这个函数的参数名称和参数选项，以及一段简要说明。如果你这时想查看此函数的帮助文档，按F1即可。 通过$符号取子集的时候，R会自动列举所有可用的子集（用于列表和数据框/tibble）。类似地，在package名后输入::准备调用函数时，R会列举该package所有可用函数（见第1.4.3.2节）。 1.3.5 其他 1.3.5.1 “一句”的概念 一次（一句）计算执行且执行一个函数（不包括里面嵌套着的函数）。 当你通过函数名 + (“开启”一次运算时，从这里开始到这个函数所对应的反括号，即)之前的内容，即使再多，都只是这个函数的参数。 当你在R script里敲击Ctrl+Enter时，光标所在的位置的那一句指令将会被执行（无需在那一句的开头，可以在那一句之中的任何位置）；如果那句命令不完整，很可能会在console中用+提示（见下一小节）。 句与句之间必须换行，或者用分号（;）连接： sum(1, 9) sum(2, 3) # 和 sum(1, 9); sum(2, 3) # 都是可以的，而 sum(1, 9) sum(2, 3) # 不可以，会出错 1.3.5.2 关于换行 Console 中每个命令开头的&gt;叫做prompt（命令提示符），当它出现在你所编辑的那一行的开头时，按下回车的时候那行的命令才会被执行。有时候它会消失，这时候按esc可以将其恢复。 prompt消失的主要原因是你的代码没有写完，比如括号不完整： &gt; 2+(3+4 这时你按回车，它会显示： &gt; 2+(3+4 + +号是在提示代码没写完整。这时你把括号补上再按回车： &gt; 2+(3+4 + ) [1] 9 便可以完成计算。 准确地说，赋值也是一种计算。赋值符号本身就是一个函数，你可以用&quot;&lt;-&quot;(x, 5)把5赋值给x。↩ 有一些计算不支持赋值。当强行赋值的时候，会产生效果，但赋值的值为NULL，比如x &lt;- pdf()会在工作目录新建一个pdf，并新建了对象x，但x的值为NULL. 有一些计算支持赋值，但是同时也会产生效果，比如hist(rnorm(1000))（以list的形式赋值）。↩ 其实你还可以把这个小箭头反过来，试试5 -&gt; x. 但是不建议这么做。代码易读性会变差。↩ 每个对象还可以有一些（可选的）attributes（属性）。↩ 其实可以用=替代&lt;-作为赋值符号，但是更多的R用户还是采用传统的的&lt;-符号，而=则用于给函数的参数赋值。这种区分可以使代码可读性更强（更容易看出哪些语句是赋值，哪些是计算）。当然，如果你真的非常非常想用=符号，也是可以接受的。↩ 一个特例是environment（环境）的赋值。初学者不需要知道。↩ 查看x的值，我们只需要输入x然后按回车，然后我们在console看到了x的值。这其实也是用函数实现的。当一个指令不是赋值时，R默认会对整个指令使用print()函数。因此，2 + 4等同于print(2 + 4), x等同于print(x). 当一个指令是赋值是，R默认会对右边的整个指令使用invisible()函数，因此，y &lt;- x等同于y &lt;- invisible(x).↩ 一切福利都可以在设置中取消。↩ 可以在设置中，自定义所需输入的最少字母和延迟。默认分别为3个字母和250毫秒。↩ "],
["packages.html", "1.4 安装和使用packages (包)", " 1.4 安装和使用packages (包) 1.4.1 Package是什么，为什么使用它们？ Package是别人写好的在R中运行的程序（以及附带的数据和文档），你可以免费安装和使用它们。 Packages可以增加在基础R语言中没有的功能，可以精简你代码的语句，或是提升使用体验。比如有个叫做tikzDevice的package可以将R中的图表导出成tikz语法的矢量图，方便在LaTeX中使用。本书的编写和排版也是使用R中的一个叫做bookdown的package完成的. 这个课程主要是学习tidyverse这个package， 1.4.2 如何安装packages 首先我们安装tidyverse（很重要，本书接下来的部分都要使用这个package）： install.packages(&quot;tidyverse&quot;) 在console中运行以上代码，R就会从CRAN中下载tidyverse并安装到你电脑上的默认位置。因此安装packages需要网络连接。 如果想安装多个packages，你可以一行一行地安装，或是把多个packages的名字合成一列，同时安装，比如： install.packages(c(&quot;nycflights13&quot;, &quot;gapminder&quot;, &quot;Lahman&quot;) 绝大多数的packages都能用这个方法安装，因为它们是被存储在CRAN上的。Bioconductor packages请看第1.4.4.2节。 1.4.3 如何使用packages 1.4.3.1 加载packages 安装packages后，有两种方法使用它们。以tidyverse为例： library(&#39;tidyverse&#39;) 或 require(&#39;tidyverse&#39;) 两者的效果很大程度上都是一样的，都可以用来读取单个package。它们的不同，以及如何通过一行指令读取多个packages，请参看第1.4.4.1节。 每次重启R的时候，上一次使用的packages都会被清空，所以需要重新读取。因此我们要在R script里面记录此script需要使用的packages（这个特性可以帮助你养成好习惯：当你把你的代码分享给别人的时候，要保证在别人的电脑上也能正常运行，就必须要指明要使用哪些packages）.13 1.4.3.2 使用packages里的内容 刚才加载tidyverse的时候，你也许注意到了这样一条提示： ── Conflicts ─────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() 这是因为R本来自带了一个叫做stats的package，有俩函数名曰filter()和lag()，而dplyr（tidyverse的一部分）也有同名的俩函数，把原来的覆盖了。所以它提示你，当你使用filter()和lag()时，使用的是dplyr的版本，而不是原来stats里的。 这不意味着stats里的这两个函数就不能用了。要使用他们，用这个格式就好了： stats::filter() 同样的道理也适用于其他的packages. 你可以通过 dplyr::filter() 使用dplyr版本的filter()。虽然这是个好习惯，但是很少人这么做（除非你是开发者）。Python里每使用一次NumPy里的函数都要加上np_的前缀，虽然严谨，但是麻烦。R的一大便利之处就是使用packages里的内容时，不强制要求指定packages的名称。如果函数/对象名称有重叠，以packages的加载顺序决定优先度；最近（即最后）被加载的package里的函数/对象胜出，而其余的要通过packageName::object的形式调取。 1.4.3.3 更新和卸载packages 更新：update.packages()；卸载：remove.packages()；两者皆可在RStudio右下角的Packages区进行操作。 1.4.4 其它 这小节是一些不重要的内容，因此可酌情跳到下一章（第2章）。 1.4.4.1 library()和require的区别；如何使用一行指令读取多个packages require()会返回一个逻辑值。如果package读取成功，会返回TRUE，反之则返回FALSE. library()如果读取试图读取不存在的package，会直接造成错误(error)，而require()不会造成错误，只会产生一个警告(warning). 这意味着require()可以用来同时读取多个packages： lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, character.only = TRUE) 或者更精简一点， lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, c = T) 1.4.4.2 安装Bioconductor packages Bioconductor是一系列用于生物信息学的R packages. 截止2019年7月2日，共有1741个可用的bioconductor packages. 它们没有被存储在CRAN上，因此需要用特殊的方法安装。首先，安装一系列Bioconductor的核心packages（可能需要几分钟）： source(&quot;http://bioconductor.org/biocLite.R&quot;) biocLite() 然后，通过biocLite()函数安装其它packages，比如： biocLite(&quot;RforProteomics&quot;) 另一个主要原因是，寻找对象时，R需要搜索所有已加载的packages，而且，packages都被加载在RAM里，因此加载过多的packages会使R显著变慢。（虽然有一些开挂的方法）↩ "],
["vectors-logicals-and-functions.html", "Chapter 2 向量，逻辑，循环和函数", " Chapter 2 向量，逻辑，循环和函数 本章内容速览 第2.1节介绍了R中向量的概念，使用方法和优越性。 2.1.1：向量的创建（赋值）和合并 2.1.2：向量的索引（indexing）和取子集（subsetting） 2.1.3：生成有序数列（连续整数，重复数/重复向量， 2.1.4：向量的其它操作 2.1.5：向量的优越性——向量化计算概念基础 第2.2节介绍了R中的数据/对象类型 2.2.1：如何查看数据/对象的类型；最基础的5种（atomic vector所存储的）数据类型；其它常用数据/对象类型 2.2.2：数据类型详解；更多的数据类型 第2.3节介绍了R中的数学规则 2.3.1：数的表达；整数，浮点数，科学计数法 2.3.2：基础的数学运算 2.3.3：基础的统计学计算，包括t分布，t检验，卡方检验 第2.4节介绍了R中逻辑值(TRUE, FALSE, NA)的概念和玩法。 第2.6节介绍了R中的函数的定义和使用。 第2.6.6节介绍了R中列表 (list)的性质和使用方法。 第2.6.7节介绍了R中矩阵 (matrix)和数组 (array)的性质和使用方法。 注意，R中的变量名/自定义函数名不能以数字和特殊符号开头，中间只能使用&quot;_“和”.&quot;作为特殊符号14 如果一定要违反规则，可以使用转义符号\\``，比如可以``4foo%b=a+r` &lt;- 50 ``↩ "],
["vector-section.html", "2.1 向量的概念，操作和优越性", " 2.1 向量的概念，操作和优越性 R没有标量，它通过各种类型的向量 (vector)来存储数据。 2.1.1 创建向量（赋值） 与很多其他的计算机语言不同，在R中，&lt;-（像一个小箭头）用于给向量，数据框和函数赋值（即在每行的开头）。在RStudio中，可以用Alt+- (Mac是 option+-) 这个快捷键打出这个符号。 x &lt;- 2 x ## [1] 2 要创建一个多元素的向量，需要用到c() (concatenate)函数： nums &lt;- c(1,45,78) cities &lt;- c(&quot;Zürich&quot;, &quot;上海&quot;, &quot;Tehrān&quot;) nums ## [1] 1 45 78 cities ## [1] &quot;Zürich&quot; &quot;上海&quot; &quot;Tehrān&quot; 通过length()函数，可以查看向量的长度。 length(nums) ## [1] 3 #如果无后续使用，没必要赋值一个变量；c(...)的计算结果就是一个向量，并直接传给`length()`函数 length(c(&quot;Guten Morgen&quot;)) ## [1] 1 （每个被引号包围的一串字符，都只算做一个元素，因此长度为1；多元素的向量请看第2.1.1节） 还是通过c()函数，可以把多个向量拼接成一个大向量： cities_1 &lt;- c(&quot;Zürich&quot;, &quot;上海&quot;, &quot;Tehrān&quot;) cities_2 &lt;- c(&quot;大阪&quot;, &quot;Poznań&quot;, &quot;Cairo&quot;) cities &lt;- c(cities_1, cities_2, c(&quot;Jyväskylä&quot;, &quot;邯郸&quot;, &quot;札幌่&quot;)) cities ## [1] &quot;Zürich&quot; &quot;上海&quot; &quot;Tehrān&quot; &quot;大阪&quot; &quot;Poznań&quot; &quot;Cairo&quot; ## [7] &quot;Jyväskylä&quot; &quot;邯郸&quot; &quot;札幌่&quot; 2.1.2 索引/取子集/子集重新赋值 (indexing/subsetting) 索引 (index)就是一个元素在向量中的位置。R是从1开始索引的，即索引为1的元素是第一个元素（因此用熟了Python和C可能会有些不适应）。在向量后方使用方括号进行取子集运算（即抓取索引为对应数字的元素；虽然subsetting翻译成“取子集”有点怪，但是没毛病；不知大家有没有更好的翻译方法，或是不翻译更好）。 x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;) x[3] ## [1] &quot;three&quot; 可以在方括号中使用另一个向量抓取多个元素： x[c(2,5,9)] # 第2个，第5个，第9个元素 ## [1] &quot;two&quot; &quot;five&quot; &quot;nine&quot; 我们可以重新赋值子集： x[c(2,5,9)] &lt;- c(&quot;二&quot;, &quot;五&quot;, &quot;九&quot;) x ## [1] &quot;one&quot; &quot;二&quot; &quot;three&quot; &quot;four&quot; &quot;五&quot; &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;九&quot; 经常，我们会抓取几个连续的元素。如果想知道方法，请继续往下看。 2.1.3 生成器 有时候我们需要其元素按一定规律排列的向量，这时，相对于一个个手动输入，有更方便的方法： 2.1.3.1 连续整数 1:10 #从左边的数（包含）到右边的数（包含），即1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 这时，你应该会有个大胆的想法： x[3:6] ## [1] &quot;three&quot; &quot;four&quot; &quot;五&quot; &quot;six&quot; 没错就是这么用的，而且极为常用。 当元素比较多的时候： y &lt;- 7:103 y ## [1] 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## [18] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ## [35] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 ## [52] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ## [69] 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 ## [86] 92 93 94 95 96 97 98 99 100 101 102 103 注意到了左边方括号中的数字了吗？它们正是所对应的那一行第一个元素的索引。 下面的内容可能有点偏，可以酌情从这里跳到第2.1.5节。 2.1.3.2 复读机rep() rep(6, 8) # 把6重复8遍；或rep(6, times = 8) ## [1] 6 6 6 6 6 6 6 6 rep(c(0, 7, 6, 1), 4) # 把(0, 7, 6, 1)重复4遍 ## [1] 0 7 6 1 0 7 6 1 0 7 6 1 0 7 6 1 rep(c(0, 7, 6, 1), each = 4) # 把0, 7, 6, 1各重复4遍 ## [1] 0 0 0 0 7 7 7 7 6 6 6 6 1 1 1 1 rep(c(0, 7, 6, 1), c(1, 2, 3, 4)) # 把0, 7, 6, 1分别重复1, 2, 3, 4遍 ## [1] 0 7 7 6 6 6 1 1 1 1 想一想，rep(8:15, rep(1:5, rep(1:2, 2:3)))的计算结果是什么？ 2.1.3.3 等差数列: seq() 公差确定时： seq(0, 15, 2.5) # 其实是`seq(from = 0, to = 50, by = 5)`的简写 ## [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 长度确定时： seq(0, 50, length.out = 11) # 其实是`seq(from = 0, to = 50, length.out = 11)`的简写 ## [1] 0 5 10 15 20 25 30 35 40 45 50 2.1.3.4 随机数： 连续型均匀分布随机数用runif(n, min, max)，n是数量，min是最小值，max是最大值。默认min为0，max为1。 x_unif &lt;- runif(100000, 40, 60) # 生成100000个40到60之间，连续均匀分布的的随机数 hist(x_unif) # 画直方图 正态分布随机数用rnorm(n, mean, sd), 三个参数分别为数量，平均值，标准差。默认mean为0，sd为1。 x_norm &lt;- rnorm(100000, 250, 20) # 按照平均值为250，标准差为20的正态分布的概率密度函数生成100000个随机数 hist(x_norm) # 画直方图 2.1.4 向量的其他操作 2.1.4.1 创建长度为0的向量 使用循环的时候，经常需要初始化一个长度为0的向量（见第2.5节 有两种方法实现： x &lt;- vector(&quot;numeric&quot;) # 或`vector(&quot;integer&quot;)`, `vector(&quot;character&quot;)`等 class(x) ## [1] &quot;numeric&quot; 或者： x &lt;- integer(0) # 或 x &lt;- integer() # 或`character(0)`, `numeric(0)`等 class(x) ## [1] &quot;integer&quot; 其中后面这种方法亦可用于创建长度为\\(n\\)的向量，把0替换成你想要的长度即可。 2.1.4.2 sort(), rank()和order() x &lt;- c(2, 5, 3, 6, 10, 9, 7, 8, 1, 4) sort(x) rank(x) order(x) rev(sort(x)) # 为方便同框展示，我用的代码是 list(x = x), `sort(x)` = sort(x), `rank(x)` = rank(x), `order(x)` = order(x), `rev(sort(x))` = rev(sort(x))) ## $x ## [1] -10 5 -89 999 84 ## ## $`sort(x)` ## [1] -89 -10 5 84 999 ## ## $`rank(x)` ## [1] 2 3 1 5 4 ## ## $`order(x)` ## [1] 3 1 2 5 4 ## ## $`rev(sort(x))` ## [1] 999 84 5 -10 -89 sort()很好理解，就是把原向量的元素从小到大重新排列。如果要从小到大：rev(sort(x)). rank()是原向量各个元素的（从小到大的）排名。（-10是第2名，5是第3名，-89是第1名，以此类推） order()是一个原向量索引的排序，使得x[order(x)] = sort(x)，即x[order(x)] = x[c(3, 1, 2, 5, 4)] = c(-89, -10, 5, 84, 999) = sort(x) 至于文字向量，英文按a, b, c, d, e, ...排列，中文按笔画排列。 2.1.4.3 元素的命名 scores &lt;- c(ochem = 79, math = 66, mcb = 64, blc = 75, bpc = 72) scores ## ochem math mcb blc bpc ## 79 66 64 75 72 然后便可以额外地用名字抓取元素： scores[c(&quot;math&quot;, &quot;bpc&quot;)] == scores[c(2, 5)] ## math bpc ## TRUE TRUE 2.1.5 R向量的优越性 R中的向量（矩阵和数列也是）的各种计算默认都是逐元素 (elementwise)的。比如： x &lt;- c(4, 9, 25) y &lt;- c(8, 6, 3) x + y ## [1] 12 15 28 x * y # 在matlab中这样乘是不行的，要用`.*`，除法也是 ## [1] 32 54 75 sqrt(x) ## [1] 2 3 5 拥有这种特性的计算也被称为向量化计算 (vectorized computation). 相比于常用的编程语言，向量化计算省去了for循环，计算效率得到极大的提升；相比于matlab的默认矩阵乘法，逐元素乘法在数据处理中更有用。 若想更多地了解向量化计算（比如如何把for循环需要39秒的运算压缩到0.001秒），请看第2.5.4节。 "],
["data-types.html", "2.2 数据/对象类型 (Data/Object Types)", " 2.2 数据/对象类型 (Data/Object Types) 2.2.1 基础的数据/对象类型 2.2.1.1 向量所存储的数据类型 向量所存储的的数据类型有5种： 类型 含义与说明 例子 numeric 浮点数向量 3, 0.5, sqrt(2), NaN, Inf integer 整数向量 3L, 100L character 字符向量；需被引号包围 &quot;1&quot;, &quot;$&quot;, &quot;你好&quot; logical 逻辑向量 TRUE, FALSE, NA complex 复数向量 3+5i, 1i, 1+0i 一个向量的所有元素必须属于同一种类型。如果尝试把不同类型的元素合并成一个向量，其中一些元素的类型会被强制转换 (coerced)。你可以试试c(2, &quot;a&quot;), c(2+5i, 4), c(TRUE, 1+9i)和c(TRUE, 1+9i, &quot;a&quot;)，但是实际操作的时候尽量不要这么做。 2.2.1.2 关于数据类型的简单操作 通过class()函数，可以查看数据/对象的类型。 class(6) # 6是一个（浮点）数，应为&quot;numeric&quot; ## [1] &quot;numeric&quot; 通过is.XXX()函数，可以得到一个逻辑值，指明此数据/对象是否属于某个类型，TRUE为是，FALSE为否。比如： is.numeric(6) ## [1] TRUE is.character(&quot;6&quot;) ## [1] TRUE 通过as.XXX()函数，可以把数据/对象强行转换成另一种类型，比如： as.integer(c(TRUE, FALSE)) ## [1] 1 0 as.character(c(23, 90)) ## [1] &quot;23&quot; &quot;90&quot; 2.2.1.3 NA, Inf, NaN和NULL NA为缺损值，意思是该元素所代表的数值丢失/不确定/不可用。举个例子，当我们统计学生的200m跑成绩时，有一些学生因为身体不适未能参与测试，这时他们的成绩应被记为NA： time_in_sec &lt;- c(29.37, 28.66, 31.32, NA, 27.91, NA) 之前说过，一个向量中，所有的元素都是同一类型的。的确，这里的NA的类型是numeric: class(time_in_sec[4]) ## [1] &quot;numeric&quot; 同理，character向量里的NA，类型也是character，其他类型也是一样的道理。如果只是单个的NA, 它的类型是logical: y &lt;- c(&quot;a&quot;, &quot;b&quot;, NA) class(y[3]) ## [1] &quot;character&quot; class(NA) ## [1] &quot;logical&quot; Inf（无限）NaN（非数）的概念，以及作为numeric的NA的数学计算在第2.3.2.4小节讨论。 作为logical的NA的逻辑运算在第2.4小节讨论。 NULL是“无”，真正的“无”。它几乎一无是处，因此在此不作更多讨论。学有余力者可以自己去了解。 2.2.1.4 其它的数据/对象类型 Dataframe/tibble 是R中存储复杂（多变量）数据的规范格式，从第3.3.1.2章开始将一直占据我们话题的中心。 因子 (factor)有很多向量的特性，尤其是能在dataframe/tibble中作为变量，但是它并不是向量；因子的详细内容在第5.4节。 函数 (function)。我们刚才用c()来创建向量，它就是一个函数：class(c)；函数的详细内容在第2.6节。 list类似于向量，但是一个list可以包含不同类型的元素。性质和使用方法也和向量大相径庭。详细内容在第2.6.6节，算是较为进阶的内容。 矩阵 (matrix)和数组 (array)可以算作是二维和多维的向量，同样只能存储一种类型的数据，详细内容在第2.6.7节，同样是较为进阶的内容。 2.2.2 数据类型（严谨版） 可以酌情跳到第2.3节。 本小节内容没完成，请跳到第2.3节。 2.2.2.1 class, type, mode和storage mode 其实class根本不是基础的数据类型。学过编程的应该猜到了，此class正是OOP里的“类”，是“高层”的类型。你可以随意篡改class： x &lt;- c(&quot;Joe&quot;, &quot;Lynne&quot;, &quot;Pat&quot;) class(x) # 本应为&quot;character&quot; ## [1] &quot;character&quot; class(x) &lt;- c(&quot;high_school&quot;, &quot;student&quot;) # 篡改 class(x) # 新class ## [1] &quot;high_school&quot; &quot;student&quot; 用typeof(), mode(), storage.mode()所获取到的三种属性是不可篡改的“底层”类型。 "],
["math.html", "2.3 数学表达和运算", " 2.3 数学表达和运算 2.3.1 数的表达 2.3.1.1 浮点数 除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其class为numeric。 class(3) ## [1] &quot;numeric&quot; 这会导致一些有趣的现象，比如\\((\\sqrt{3})^2 \\neq 3\\)：（强迫症患者浑身难受） sqrt(3)^2-3 ## [1] -4.440892e-16 浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位；只有当两个非常，非常大且数值相近对数字相减才会出现较大的误差）。 NaN（非数）和Inf（无限大）也是浮点数！ class(NaN) ## [1] &quot;numeric&quot; class(Inf) ## [1] &quot;numeric&quot; 2.3.1.2 科学计数法 在R中可以使用科学计数法(AeB\\(= A \\times 10^B\\))，比如： 3.1e5 ## [1] 310000 -1.2e-4+1.1e-5 ## [1] -0.000109 2.3.1.3 整数 整数的class为integer。有两种常见的方法创建整数： 1）在数后面加上L； class(2) ## [1] &quot;numeric&quot; class(2L) ## [1] &quot;integer&quot; 2）创建数列 1:10 #公差为1的整数向量生成器，包含最小值和最大值 ## [1] 1 2 3 4 5 6 7 8 9 10 class(1:10) ## [1] &quot;integer&quot; seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数 ## [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5,50,5)) #因此产生的是一个浮点数向量 ## [1] &quot;numeric&quot; seq(5L,50L,5L) #可以强制生成整数 ## [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5L,50L,5L)) #是整数没错 ## [1] &quot;integer&quot; 整数最常见的用处是indexing（索引）。 2.3.1.3.1 整数变成浮点数的情况 这一小段讲的比较细，请酌情直接跳到下一节（2.3.2）。 整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(factorial)也是，即便现实中不管怎么阶乘都不可能得到非整数）： class(2L+1L) ## [1] &quot;integer&quot; class(2L-1L) ## [1] &quot;integer&quot; class(2L*3L) ## [1] &quot;integer&quot; class(17L%/%3L) ## [1] &quot;integer&quot; class(17L%%3L) ## [1] &quot;integer&quot; class(1000L/1L) ## [1] &quot;numeric&quot; class(3L^4L) ## [1] &quot;numeric&quot; class(sqrt(4L)) ## [1] &quot;numeric&quot; class(log(exp(5L))) ## [1] &quot;numeric&quot; class(factorial(5L)) ## [1] &quot;numeric&quot; 整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。 另外一个需要注意的地方是，取整函数2.3.2.3并不会产生整数。如果需要的话，要用as.integer()函数。 2.3.2 运算 2.3.2.1 二元运算符号 R中的binary operators（二元运算符）有： 符号 描述 + 加 - 减 * 乘 / 除以 ^或** 乘幂 %/% 求整数商，比如7%%3\\(=2\\) %% 求余数，比如7%%3\\(=1\\) 其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（后面再详细介绍）。 2.3.2.2 \\(e^x\\)和\\(\\log_x{y}\\) exp(x)便是运算\\(e^x\\)。如果想要\\(e=2.71828...\\)这个数： exp(1) ## [1] 2.718282 log(x, base=y)便是运算\\(\\log_y{x}\\)，可以简写成log(x,y)（简写需要注意前后顺序，第2.6.2有解释）。 默认底数为\\(e\\)： log(exp(5)) ## [1] 5 有以10和2为底的快捷函数, log10()和log2() log10(1000) ## [1] 3 log2(128) ## [1] 7 2.3.2.3 近似数（取整，取小数位，取有效数字） 取有效数字用signif()函数；第一个参数是对象，第二个参数是保留的位数；若保留的位数未指定，默认为6. signif(12.3456789, 4) ## [1] 12.35 当对象的有效数字小于你想保留的有效数字位数时，它不会让你乱来（下面round()函数也类似）： signif(12.3, 8) ## [1] 12.3 保留小数位用round()函数。 round(12.3456789, 3) # 保留3个小数位 ## [1] 12.346 若不指定保留多少位，默认为0，即四舍五入地取整： round(13.5) ## [1] 14 此外，还有三种取整函数：floor(), ceiling()和trunc() floor(5.6) # = 5 # “地板”；比x小的最近的整数 ceiling(5.4) # = 6 # “天花板”；比x大的最近的整数 floor(-5.6) # = -6 # 不是-5，因为-6是比-5.6小的最近的整数 ceiling(-5.4) # = -5 # 不是-6；因为-5是比x大的最近的整数 trunc(-5.6) # = -5 # 你可能需要这个；它无视了小数点后面的位数 注意，所有取整函数给出的的结果都并不是整数！ class(ceiling(7.4)) ## [1] &quot;numeric&quot; 虽然浮点数使用起来真没啥不方便的，但是如果你一定需要的话，可以用as.integer()函数把它转换成真·整数。 2.3.2.4 NA, Inf, NaN相关 我不知道张三有几个苹果，我也不知道李四有几个苹果；你问我张三和李四共有几个苹果： NA + NA ## [1] NA 鬼才知道咧！ 类似地，NA - NA, NA/NA, NA*NA, log(NA)都等于NA NA^0等于几？别上当！R的开发者们可没有忘记\\(\\forall x\\in \\mathbb{R:x^0 = 1}\\) Inf, 即\\(\\infty\\), 表示很大的数字（准确地说，大于等于\\(2^{1024}\\)即\\(1.797693\\times10^{308}\\)的数字）它还有个负值，-Inf. 以下是几个结果为Inf的例子： exp(1000) # = Inf; 这个很明显 1/0 # = Inf; 0被当作很小的数 0^(-1) # = 1/(0^1) = 1/0 = Inf log(0) # = -Inf; 0又被当作很小的数 NaN是“非数” (not a number). 运算结果为NaN的例子有： 0/0 # NaN log(-1) # = NaN 0^(3+8i) # = NaN + NaNi Inf-Inf; Inf/Inf # = NaN -NaN # = NaN Inf和NaN的类型是numeric（浮点数）. class(Inf); class(NaN) ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; 2.3.2.5 R中自带的数学函数集合 基础 函数 描述 exp(x) \\(e^x\\) log(x,y) \\(\\log_yx\\) log(x) \\(\\ln(x)\\) sqrt(x) \\(\\sqrt{x}\\) factorial(x) \\(x!=x\\times(x-1)\\times(x-2)\\ldots\\times2\\times1\\) choose(n,k) \\(\\binom{n}{k}=\\frac{n!}{k!(n-k)!}\\)（二项式系数） gamma(z) \\(\\Gamma(z)=\\int_0^\\infty x^{z-1}e^{-x}dx\\)（伽马函数） lgamma(z) \\(\\ln(\\Gamma(z))\\) floor(x), ceiling(x), trunc(x), 取整；见上一小节。 round(x, digits = n) 四舍五入，保留n个小数位，n默认为0 signif(x,digits = n) 四舍五入，保留n个有效数字，n默认为6） sin(x), cos(x), tan(x) 三角函数 asin(x), acos(x), atan(x) 反三角函数 sinh(x), cosh(x), tanh(x) 双曲函数 abs(x) \\(|x|\\)（取绝对值） sum(...), prod(...) 所有元素相加之和/相乘之积 2.3.3 简易的统计学计算 本节简要解释了R中的基础统计学函数，t分布，t检验和\\(\\chi^2\\)检验。统计学方法并不是本书的重点，因此可以酌情跳到下一章。 2.3.3.1 基础 中位数median(); 平均数mean(); 方差var(); 标准差sd(). 2.3.3.2 t分布 众所周知，t分布长这样： 阴影面积为\\(P(t&lt;T)\\)，虚线对应的\\(t\\)为\\(T\\). qt()可以把\\(P(t≤T)\\)的值转化成\\(T\\),pt()则相反。 假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为\\(95\\%\\)，即\\(\\alpha=0.05\\)，degrees of freedom(自由度)为\\(12\\)，那么怎么算\\(t^*\\)呢？ qt(0.975, df = 12) ## [1] 2.178813 为什么是\\(0.975\\)？因为你要把\\(0.05\\)分到左右两边，所对应的t*就等同于t分布中，\\(P(t ≤ T) = 0.975\\)时T的值。 再举一个例子，你在做t检验，双尾的，算出来\\(t=1.345\\)，自由度是\\(15\\)，那么\\(p\\)值怎么算呢？ p &lt;- (1-(pt(2.2, df = 15)))*2 p ## [1] 0.04389558 其中pt(2.2, df = 15)算出阴影面积（\\(P(t≤T)\\)的值），1减去它再乘以2就是对应的双尾t检验的\\(p\\)值。 2.3.3.3 z分布 没有z分布专门的函数。可以直接用t分布代替，把df调到很大（比如999999）就行了。比如我们试一下\\(95\\%\\)置信区间所对应的\\(z*\\)： qt(0.975,9999999) ## [1] 1.959964 （果然是\\(1.96\\)） 2.3.3.4 t检验 t检验分为以下几种： One sample t test （单样本） paired t test（配对） Two sample…（双样本） Unequal variance (Welch) t test（不等方差） Equal variance t test（等方差） 在R中做t检验，很简单，以上这些t检验，都是用t.test 这个函数去完成。 以单样本为例： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31) ## ## One Sample t-test ## ## data: x ## t = -2.0083, df = 12, p-value = 0.06766 ## alternative hypothesis: true mean is not equal to 2.31 ## 95 percent confidence interval: ## 2.257076 2.312155 ## sample estimates: ## mean of x ## 2.284615 可以看到\\(p=0.06766\\)。 R的默认是双尾检验，你也可以设置成单尾的： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31, alternative = &quot;less&quot;) # 检验是否*less* than μ ## ## One Sample t-test ## ## data: x ## t = -2.0083, df = 12, p-value = 0.03383 ## alternative hypothesis: true mean is less than 2.31 ## 95 percent confidence interval: ## -Inf 2.307143 ## sample estimates: ## mean of x ## 2.284615 \\(p\\)值瞬间减半。 双样本/配对: x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) y &lt;- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22) t.test(x, y) ## ## Welch Two Sample t-test ## ## data: x and y ## t = -1.5624, df = 13.65, p-value = 0.1411 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.18460351 0.02921889 ## sample estimates: ## mean of x mean of y ## 2.284615 2.362308 R的默认是non-paired, unequal variance，你可以通过增加paired = TRUE，var.equal = TRUE这两个参数来改变它。 t.test(x, y, paired = TRUE) ## ## Paired t-test ## ## data: x and y ## t = -1.4739, df = 12, p-value = 0.1662 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.19253874 0.03715412 ## sample estimates: ## mean of the differences ## -0.07769231 2.3.3.5 \\(\\chi^2\\) 检验 \\(\\chi^2\\)检验有两种，goodness of fit test（适配度检验）和contigency table test/test of independence（列联表分析/独立性检验）。都是用chisq.test()函数去完成。 2.3.3.5.1 适配度检验 假设我们制造了一个有问题的骰子，使1至6朝上的概率分别为： expected_probs &lt;- c(0.05, 0.1, 0.15, 0.2, 0.2, 0.3) 然后我们投掷了100次，实际1至6朝上的次数分别为： observed_vals &lt;- c(6, 9, 14, 24, 18, 29) 通过chisq.test()，检验实际的1至6朝上概率是否与预期有偏差： chisq.test(observed_vals, p = expected_probs) # 参数p是指概率 ## ## Chi-squared test for given probabilities ## ## data: observed_vals ## X-squared = 1.4, df = 5, p-value = 0.9243 p值很大（远大于0.05），因此结论是骰子各面朝上的概率符合预期。 如果不指定p参数，默认为检测是否所有值相等（即骰子的所有面朝上的概率相等）： chisq.test(observed_vals) ## ## Chi-squared test for given probabilities ## ## data: observed_vals ## X-squared = 23.24, df = 5, p-value = 0.0003037 这时p值小于0.05. 得出“骰子各面朝上的概率不等”的结论。 2.3.3.5.2 列联表分析/独立性检验 假设我们有一组不同年级的学生参加社团的人数数据： (社团参与 &lt;- matrix(c(28,36,40,40,32,33,38,29,36), nrow = 3, dimnames = list(c(&quot;一年级&quot;, &quot;二年级&quot;, &quot;三年级&quot;), c(&quot;棒球&quot;, &quot;足球&quot;, &quot;网球&quot;)))) ## 棒球 足球 网球 ## 一年级 28 40 38 ## 二年级 36 32 29 ## 三年级 40 33 36 我们想知道社团的参与，与所在年级是否是独立事件： chisq.test(社团参与) ## ## Pearson&#39;s Chi-squared test ## ## data: 社团参与 ## X-squared = 3.7587, df = 4, p-value = 0.4396 p值不小于0.05，无法拒绝“社团的参与，与所在年级是独立事件”的虚无假设。 彩蛋：用R代码实现卡方分布的概率密度函数的图像： #其实还可以更精简，但是为了易读性不得不牺牲一点精简度。 Z &lt;- matrix(rep(rnorm(1000000), 6), nrow = 6)^2 X &lt;- Z^2 Q &lt;- matrix(nrow = 6, ncol = 1000000) for (i in (1+1):6) { Q[1,] = Z[1,] Q[i,] = Q[(i-1),] + Z[i,] } plot(NULL, xlim=c(0.23,6), ylim = c(0,1), main = expression(paste(&#39;X ~ &#39;, chi^&#39;2&#39;, &#39;(k)&#39;)), xlab = &quot;x&quot;, ylab= expression(f[k]*&#39;(x)&#39;) ) colors &lt;- c(&#39;blue&#39;, &#39;black&#39;, &#39;red&#39;, &#39;green&#39;, &#39;gray&#39;, &#39;orange&#39;) for (i in 1:6) { lines(density(Q[i,]), col=colors[i], lwd=2) } legend(&#39;topright&#39;,c(&#39;k=1&#39;,&#39;k=2&#39;,&#39;k=3&#39;,&#39;k=4&#39;,&#39;k=5&#39;,&#39;k=6&#39;), fill = colors) 2.3.3.5.3 其他 R自带的检验还有Box.test(), PP.test(), ansari.test(), bartlett.test(), wilcox.test等共31种。查看帮助文件或利用网络资源以了解更多。 "],
["logical-operation.html", "2.4 逻辑", " 2.4 逻辑 2.4.1 逻辑值 {logical-values} 逻辑值有三个。TRUE, FALSE和NA. class(c(TRUE,FALSE,NA)) ## [1] &quot;logical&quot; TRUE为真，FALSE为假，NA为未知（即真假难辨）。 2.4.2 关系运算符和简单的逻辑运算 R中常用的关系运算符有： 符号 描述 == equal to（等于） != equal to（不等于） &lt; less than（小于） &gt; more than（大于） &lt;= less than or equal to（小于等于） &gt;= more than or equal to（大于等于） 这些关系运算符只能用于(atomic) vectors, 不能用于其他类型的R对象；indentical()函数可以用于所有类型的对象，用来确认两者是否完全一致。 使用关系运算符进行计算，会产生逻辑值作为结果。比如： x &lt;- 5 x != 3 #x等于5，所以“x不等于3”为真 ## [1] TRUE 有一些其他的运算符或函数也会返回逻辑值，比如 7 %in% c(1,4,5,6,7) ## [1] TRUE 顾名思义，这个运算符是用来检测一个元素是否在另一个向量中。其它类型的运算符，我在需要用到的时候再讲。 有很多种运算会以NA作为计算结果，在此不一一列举。最重要的一个是： NA == NA ## [1] NA 这看起来像是一个bug，然而仔细想想才发现这个设计很巧妙。假设你问我是否知道我的一些朋友写完了暑假作业。我说我不知道张三是否写完了，也不知道李四是否写完了。你再问我“张三和李四的作业完成情况是一样的吗”？鬼才知道咧！ 这意味着不能直接使用x == NA来判断x是否是NA，而要用is.na()函数： x &lt;- NA is.na(x) ## [1] TRUE 2.4.3 逻辑运算符 以下是最常用的三个逻辑运算符。 符号 描述 &amp; AND（且） | OR（或） ! 反义符号 2.4.3.1 反义符号（!） !使TRUE FALSE颠倒。一般，我们用小括号来包住一个逻辑运算，然后在它的前面加上一个!来反转结果，比如 !(3 &lt; 4) # 这个例子很简单，反义符号意义不大。后面实操的时候才能领略到它的用处。 ## [1] FALSE 2.4.3.2 多个逻辑运算的组合（&amp;（且）和|（或）） &amp;和|可以把多个逻辑运算的结果合并成一个逻辑值。 &amp;判断是否两边运算结果都为TRUE。如果是，才会得到TRUE（即一真和一假得到假）。 |判断两边运算结果是否至少有一个 TRUE，如果是，就会得到TRUE。 不用死记硬背！其实就是“且”和“或”的逻辑。 用脑子想一下以下三条运算的结果，然后复制代码到R console对答案。 1 == 1 &amp; 1 == 2 &amp; 3 == 3 #即：“1等于1且1等于2且3等于3”，是真还是假？ FALSE | FALSE | TRUE # FALSE/TRUE等价于一个运算结果 !(FALSE | TRUE) &amp; TRUE # 注意反义符号 我们可以查看三个逻辑值所有两两通过&amp;组和的计算结果（如果你不感兴趣，可以不关注方法。这里重点是结果）： vals &lt;- c(TRUE, FALSE, NA) names(vals) &lt;- paste(&#39;[&#39;,as.character(vals),&#39;]&#39;,sep = &#39;&#39;) outer(vals, vals, &quot;&amp;&quot;) ## [TRUE] [FALSE] [NA] ## [TRUE] TRUE FALSE NA ## [FALSE] FALSE FALSE FALSE ## [NA] NA FALSE NA 可以看到，FALSE与任何逻辑值组合，结果都是FALSE。这个好理解，因为一旦一个是FALSE，那么不可能两边都是TRUE. TRUE &amp; NA之所以为NA（而不是FALSE），是因为NA的意思是“不能确定真假”，即有可能真也有可能假。因此TRUE &amp; NA也无法辨真假。 再来看|的组合： outer(vals, vals, &quot;|&quot;) ## [TRUE] [FALSE] [NA] ## [TRUE] TRUE TRUE TRUE ## [FALSE] TRUE FALSE NA ## [NA] TRUE NA NA 可以看到，TRUE与任何一个逻辑值组合，都是TRUE，而FALSE | NA为NA。原因一样（因为NA的不确定性）。 "],
["control-flow.html", "2.5 判断和循环（流程控制）", " 2.5 判断和循环（流程控制） 2.5.1 给有编程基础者的快速指南 如果没编程基础，没接触过判断和循环，请看第2.5.2小节。 如果学过其他编程语言，知道判断和循环的作用，只是需要知道在R中的表达，那么请看以下两个例子快速入门，然后跳至第2.6节： m &lt;- 1:100 # 产生一个[1,2,3,...,99,100]的整数向量。上面讲过。 n &lt;- vector(&quot;numeric&quot;) for (i in n) { if (i %% 2 == 0) { n &lt;- append(n, i^2) } else if (i == 51) { break } } n ## numeric(0) logi = TRUE num &lt;- 1 while (num &lt;= 100) { if (logi) { num = num + 10 # R 不支持 num += 5的简写 print(num) logi = FALSE } else { num = num + 20 print(num) logi = TRUE } } ## [1] 11 ## [1] 31 ## [1] 41 ## [1] 61 ## [1] 71 ## [1] 91 ## [1] 101 2.5.2 无编程基础者的快速指南 我认为，举例子比纯粹的概念灌输更容易理解。 2.5.2.1 if, else if, else语句（“如果……”，“或者，如果……”，“否则……”） # 以下代码翻译成英语就是：If 1 + 1 = 2, print &quot;hi&quot;. Else, print &quot;bye&quot;. # 或中文：如果一加一等于二，那么印出“hi”，否则印出“bye”. if (1 + 1 == 2) { # 1 + 1 == 2 的运算结果是TRUE，因此“如果”成真 print(&quot;hi&quot;) # 所以会执行`print(&quot;hi&quot;)` } else { print(&quot;bye&quot;) } ## [1] &quot;hi&quot; # 代码第一行中的FALSE可以替换成任何计算结果为FALSE的运算， # 比如1 + 1 == 3；小括号内的计算过程不重要， # 但运算结果必须为TRUE或FALSE（不可以是NA） if (FALSE) { print(&quot;hi&quot;) } else { # 因为是FALSE，所以`else`里的语句被执行 print(&quot;bye&quot;) } ## [1] &quot;bye&quot; if (FALSE) { # 第一个`if`为FALSE print(&quot;hi&quot;) } else if (FALSE) { # 检查下一个`else if`，也是FALSE print(&quot;yoo&quot;) } else if (TRUE) { # 再检查下一个`else if`，这次是TRUE print(&quot;hey&quot;) # 所以执行`print(&quot;hey&quot;)` } else { print(&quot;bye&quot;) # 而轮不到else } ## [1] &quot;hey&quot; 2.5.2.2 for循环 # 以下代码翻译成英文就是: for every element i in c(2, 4, 6, 8): # assign i^2 to n, then print n # 中文：对c(2, 4, 6, 8)`中的每一个元素i： # 创建一个n使得n等于i的平方，然后印出n for (i in c(2, 4, 6, 8)) { # i可以是任何你想要的名字，比如num n &lt;- i^2 # 如果上一行是 for (num in ..., 这一行就要写成 n &lt;- num^2 print(n) } ## [1] 4 ## [1] 16 ## [1] 36 ## [1] 64 x &lt;- vector(mode = &quot;numeric&quot;) # 创建一个空的numeric vector for (m in 1:10) { if (m %% 2 == 0) { x &lt;- append(x, m) } } x ## [1] 2 4 6 8 10 M &lt;- c(1, 2, 3 ,4 ,5) N &lt;- c(10, 100, 1000) x &lt;- vector(&quot;numeric&quot;) for (m in M) { for (n in N) { # 在一个for循环中嵌入另一个for循环 x &lt;- append(x, m*n) } } x ## [1] 10 100 1000 20 200 2000 30 300 3000 40 400 4000 50 500 ## [15] 5000 实际操作中，要想尽办法避免for循环，尤其是以上这种双层（多层）嵌套的for循环！原因和方法请看第2.5.4节。 2.5.2.3 while循环 x &lt;- 1 while (x &lt; 10) { # 当x&lt;10的时候，执行大括号内的语句 print(x) x &lt;- x + 3 # 一定要让x的值增加，否则会进入无限循环 } ## [1] 1 ## [1] 4 ## [1] 7 2.5.2.4 break 和 next for (i in 1:10) { if (i == 3) { next # 当i == 3时，跳过它，继续（最近的）for循环的下一个回合 } else if (i == 6) { break # 当i == 6时，结束（最近的）for循环 } print(i) # 只有当if和else if里的检验都为FALSE时，`print(i)`才会执行。 } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 M &lt;- c(1, 2, 3, 4, 5) x &lt;- vector(&quot;numeric&quot;) for (m in M) { while (TRUE) { # 原本while(TRUE){}将会是一个无限循环（判定条件永远TRUE） x &lt;- append(x, 2*m) break # break打破了最近的这个while循环，而不影响for循环。 } } x ## [1] 2 4 6 8 10 2.5.3 严谨版 如果看懂了上一节中的例子，并且作为新手不太想深究，完全可以暂时跳过这一节，前往第2.6节。 这里很多内容还没完成，请前往第2.6节。 2.5.3.1 if, else, else if 语句 if else语句长这样： if (something is true) { do something } else { do some other things } 其中小括号内为测试的条件，其运算结果需为TRUE或FALSE（不能是NA！）。如果你还不熟悉关于逻辑值的计算，请看第2.4节。 若运算结果为TRUE：大括号内的语句将会被执行。（如果语句只有一行，大括号可以省略） 如运算结果为FALSE： 如果后面没有else语句：什么都不会发生。 如果后面有else语句：else后（大括号里）的语句将会被执行。 R中没有专门的elseif语句，但用else加上if能实现同样的效果。else if可以添加在if语句之后，顾名思义（“或者如果”），它的作用是，如果前一个if测试的条件为FALSE，那么再新加一个测试条件。一整个if/else/else if代码块里可以包含多个else if. 注意，不能直接用x == NA来判断x是否是NA，而要用is.na(x). 否则会得到NA的结果。 2.5.3.2 for循环 2.5.3.3 while循环 2.5.3.4 repeat循环 2.5.3.5 break和next 2.5.4 如何避免for循环——apply()家族函数 R中的循环效率是很低的，尤其是有多层嵌套。通过system.time()函数，看看你的电脑执行以下运算需要花多少秒：（system.time()函数在第2.6.5小节有介绍） x &lt;- vector(&quot;numeric&quot;) system.time( for (l in 1:40) { for (m in 1:50) { for (n in 1:60) { x &lt;- append(x, l*m*n) } } } ) 我的i5处理器(i5-8259U CPU @ 2.30GHz)花了39秒左右才能算出来，然而看起来计算量并不大： \\[x = \\left(1\\times1\\times1, 1\\times1\\times2\\ldots, 40\\times50\\times59, 40\\times50\\times60\\right)\\] 一共有\\(40\\times50\\times60 = 120000\\)次计算. 一个原因是，无论你的CPU有多少核心，R默认只会使用其中的一个进行计算。在第2.5.5.1节中介绍了开挂使用多核的方法。但是它治标不治本，解决for循环缓慢的终极方案是避免使用for循环，而使用向量化的方法进行计算 (vectorized computation)。在第2.1.5我介绍了简单的（二元）向量化计算。除了二元运算以外，很多时候，复杂的for loop也能用向量化计算实现。我们需要用到apply()家族的一系列函数：apply(), sapply(), lapply(), mapply(), tapply(), vapply(), rapply(), eapply()；此外，像Map(), rep(), seq()等函数也会执行向量化的计算。 在学习它们的用法之前，先来看一个直观的数据： 方法 \\((L,M,N)=(1:40,1:50,1:60)\\) \\((L,M,N)=(1:500,1:600,1:700)\\) 普通（单核）for循环 39秒 等了一小时，无果，遂弃 开挂（四核）for循环 12.304秒；CPU巨热 怕CPU炸，不敢试 sapply() 0.001秒 2.719秒 rep() 0.002秒 2.825秒 mapply() 0.004秒 4.302秒 rapply() 0.003秒 2.094秒 Map() 0.004秒 3.106秒 同样是运算上面那个for循环花了39秒的例子，使用sapply()函数和rep()函数几乎是瞬间完成；而把\\((l,m,n)\\)增至\\((1:500,1:600,1:700)\\)时（计算量为1750倍），它们仍只需不到3秒，而for循环则是不可行的。 （源码在） 2.5.4.1 lapply() lapply() (list apply)有两个参数，第一个是对象（可以是vector或者list），第二个是函数。它的作用是把函数作用于对象中的每一个元素，并返回一个list. 无论对象是vector还是list, 返回的都是一个list: lapply(c(1, 2, 3), function(i) i*10) # vector ## [[1]] ## [1] 10 ## ## [[2]] ## [1] 20 ## ## [[3]] ## [1] 30 lapply(list(1, 2, 3), function(i) i*10) # list ## [[1]] ## [1] 10 ## ## [[2]] ## [1] 20 ## ## [[3]] ## [1] 30 lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) ## [[1]] ## [1] 10 20 ## ## [[2]] ## [1] 40 60 ## ## [[3]] ## [1] 70 90 2.5.4.2 sapply() sapply() (simplified list apply)的功能和lapply()几乎一样。sapply()额外的一个特点是尽可能地化简结果： 当结果只有一个list元素时，sapply()返回一个vector 当结果有多个list元素，但每个list元素只包含一个vector且长度相等时，sapply()会返回一个matrix 试试以下计算： lapply(c(1, 2, 3), function(i) i*10) sapply(c(1, 2, 3), function(i) i*10) lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) sapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) lapply(list(1, 2, 3), function(i) i*c(1, 10, 100)) sapply(list(1, 2, 3), function(i) i*c(1, 10, 100)) lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) sapply(list(c(1, 2, 3), c(4, 6), c(7, 9)), function(i) i*10) 2.5.4.3 mapply()和Map() mapply()的意思是“Map+sapply”，它的计算过程和Map()函数类似，但是会像sapply()一样把结果化简。 简单地说，有些函数把参数中的vector作为一个整体使用，而用mapply()/Map()可以把这些vector逐元素地使用。而且，mapply()/Map()可以对多参数的函数进行向量化计算，因此mapply()的“m”经常被解释为代表“multivariate”. 假设你想创建一个这样的vector： ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 通过复习第2.1.3.2节，很容易得出答案： rep(1:4, each = 3) 粗心的读者可能以为是： rep(1:4, 3) # 即rep(1:4, times = 3) 而实际上它的运算结果是： ## [1] 1 2 3 4 1 2 3 4 1 2 3 4 因为1:4（即c(1, 2, 3, 4)）被作为一个整体使用了。正确的写法是： as.vector(mapply(rep, 1:4, 3)) mapply(rep, 1:4, 3)的第一个参数是所需函数的名字，其它的参数为所需函数的参数。你可以指名道姓：mapply(rep, x = 1:4, times = 3)，或者根据排序键入参数而无需指定参数名（见第2.6.2节）。其中第一个参数 (1:4)不是长度为1的vector，因此它会被mapply()转换成list并执行逐元素运算，即运算过程和结果为： mapply(rep, 1:4, 3) = mapply(rep, c(1, 2, 3, 4), 3) = list(rep(1, 3), rep(2, 3), rep(3, 3), rep(4, 3)) = list(c(1,1,1), c(2,2,2), c(3,3,3), c(4,4,4)) # 等价于 sapply(list(1, 2, 3, 4), function(x) rep(x, 3)) 为什么我们实际上看到的是一个matrix呢？这是因为每个list元素所含的vector的长度相等，因此自动化简为matrix. 若要查看未化简的版本： mapply(rep, 1:4, 3, SIMPLIFY = FALSE) 或者 Map(rep, 1:4, 3) ## [[1]] ## [1] 1 1 1 ## ## [[2]] ## [1] 2 2 2 ## ## [[3]] ## [1] 3 3 3 ## ## [[4]] ## [1] 4 4 4 你可能已经发现，用sapply()函数其实也可以较为简单地实现这个例子：sapply(1:4, function(x) rep(x, 3))；那mapply()/Map()有没有其它特殊的特性呢？有。多参数的向量化运算。对于多参数的函数，sapply()只能使用其中的第一个进行向量化运算，而其他的参数必须为常数。而mapply()/Map()可以这样： Map(seq, c(1, 5, 20), c(5, 25, 100), length.out = 5) ## [[1]] ## [1] 1 2 3 4 5 ## ## [[2]] ## [1] 5 10 15 20 25 ## ## [[3]] ## [1] 20 40 60 80 100 它执行了三次计算：seq(1, 5, length.out = 5), seq(2, 25, length.out = 5)和seq(20, 100, length.out = 5). 想一想，这个结果是否可以化简？如果是，化简结果是什么？用mapply()函数执行同样的计算来验证你的答案。 当对象是一个list的时候， Map(rep, list(c(8, 9), c(6, 7)), 3) ## [[1]] ## [1] 8 9 8 9 8 9 ## ## [[2]] ## [1] 6 7 6 7 6 7 lapply(list(c(8, 9), c(6, 7)), function(x) rep(x, 3)) ## [[1]] ## [1] 8 9 8 9 8 9 ## ## [[2]] ## [1] 6 7 6 7 6 7 想一想，Map(rep, list(c(1,2), list(2,3)), 3)的计算结果是什么？ 2.5.4.4 rep() 还是上一小节中的vector： ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 其实可以仅用rep()函数简洁地实现： rep(1:4, rep(3, 4)) 如果不明白为什么，请复习第2.1.3.2节。 2.5.5 foreach package：for循环的进化版 foreach package相对于base R中的for循环增加了一些特性，不过最实用的是支持多核并行运算： 2.5.5.1 使用多内核进行计算 首先需要安装和使用doParallel，然后才可以使用foreach中的%dopar进行多核并行运算。 查看和设置内核数量： library(doParallel) getDoParWorkers() # 查看R当前使用的内核数量；默认应为1 ## [1] 1 detectCores() # 查看可用内核总数 ## [1] 8 registerDoParallel(4) # 设置内核数量 getDoParWorkers() # 再次检查内核数量 ## [1] 4 设置完之后就可以使用%dopar进行多核并行运算了： x &lt;- foreach(l = 1:40, .combine = &quot;c&quot;) %dopar% { foreach(m = 1:50, .combine = &quot;c&quot;) %dopar% { foreach(n = 1:60, .combine = &quot;c&quot;) %do% { l*m*n } } } x 相比单核for循环的39秒，开挂（四核）的速度是12秒（计算量越大，优势越明显）。 "],
["functions.html", "2.6 函数", " 2.6 函数 2.6.1 R中的函数 不像很多其他语言的函数（和方法）有value.func()和func value等格式，R中所有函数的通用格式是这样的： function(argument1 = value1, argument2 = value2, ...) 比如 sample &lt;- c(5.1, 5.2, 4.5, 5.3, 4.3, 5.5, 5.7) # 根据传统，赋值变量时用`&lt;-`号，赋值函数参数时才用`=` t.test(x = sample, mu = 4.5) ## ## One Sample t-test ## ## data: sample ## t = 3.0308, df = 6, p-value = 0.02307 ## alternative hypothesis: true mean is not equal to 4.5 ## 95 percent confidence interval: ## 4.612840 5.558589 ## sample estimates: ## mean of x ## 5.085714 二元运算符和[（取子集符号）看起来一点都不像函数，而实际上它们也是函数，因此也可以用通用的格式使用他们，只是需要加上引号： &quot;+&quot;(2, 3) ## [1] 5 &quot;[&quot;(c(&quot;四川担担面&quot;, &quot;武汉热干面&quot;, &quot;兰州牛肉面&quot;, &quot;北京炸酱面&quot;), 2) ## [1] &quot;武汉热干面&quot; 可自定义的二元运算符形式为%x%, 其中x为任何字符。（见第2.6.3.3节） （英语中，“parameter”或“formal argument”二词用于函数定义，“argument”或“actual argument”二词用于调用函数(Kernighan and Ritchie 1988)，中文里分别是“形式参数”和“实际参数”，但是多数场合简称“参数”。） 2.6.2 调用函数 根据通用格式（function(argument1 = value1, argument2 = value2, ...)）调用函数。对于二元运算符，a %x% b等价于&quot;x&quot;(a, b). 从“function(”开始到此函数结尾的“)”中间为参数，参数用逗号隔开，空格和换行会被忽略，“#”符号出现之处，那一行之后的内容都会被忽略。这意味着你可以（丧心病狂地）像这样调用一个函数。 sum ( # 4 4 # 我怕不是 , #疯了哦 6 ) ## [1] 10 它实际的好处是，当参数很长或是有嵌套的函数时，可以通过换行和空格使代码更易读，就像其它的编程语言一样。 函数的参数以seq函数为例，通过查看documentation（在console执行?seq）可以查看它的所有的参数： ## Default S3 method: seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL, ...) 可以看到第一个参数是from，第二个是to，第三个是by，以此类推。因此我们执行seq(0, 50, 10)的时候，R会自动理解成seq(from = 0, to = 50, by = 10)。而想用指定长度的方法就必须要写清楚是length.out等于几。 length.out本身也可以简写： seq(0, 25, l = 11) ## [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0 22.5 25.0 因为参数中只有length.out是以l开头的，l会被理解为length.out. 但是这个习惯并不好；自己用用就算了，与别人分享自己的工作时请务必使用标准写法。 2.6.3 创建函数 2.6.3.1 普通函数 函数名 &lt;- function(参数1, 参数2, ...){ 对参数1和参数2 进行 一系列 一行或者多行 计算 return(计算结果) } 在R中，函数是作为对象保存的，因此定义函数不需要一套另外的符号/语句，还是用赋值符号&lt;-，和function()函数。 R自带了计算样本标准差 (standard deviation, \\(s\\))的函数, sd()，我们可以根据它写一个计算均值标准差（即“标准误”, standard error）（\\(SE=s_{\\bar{x}}=\\frac{s}{\\sqrt{n}}\\)） SE &lt;- function(x) { s &lt;- sd(x) n &lt;- length(x) result &lt;- s/sqrt(n) return(result) } # 随后，你就可以使用自定义的函数了 SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) ## [1] 0.3367673 这里其实可以做一些省略。很多时候，最后一“句”的计算结果（不是赋值计算）就是我们想return的结果。因此，这时return可以省略： SE &lt;- function(x) { s &lt;- sd(x) n &lt;- length(x) s/sqrt(n) # 注意不是`result &lt;- s/sqrt(n)` } SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) ## [1] 0.3367673 很多时候，函数内部有复杂流程控制，这时使用return()可以很大地增强易读性： # 这是随手写的一个没有意义的函数 myfunc &lt;- function(i){ k &lt;- 8 if (i&gt;3) { j &lt;- -i while(j &lt; 20){ k &lt;- k + i + j j &lt;- j+5 } return(k) } else { if (i %% 2 == 0) { return(5) } else return(k*i) } } myfunc(6) ## [1] 83 2.6.3.2 无名函数 本章剩余的内容，都是比较进阶的了。可以酌情从这里跳转至本章第2.6.9节。 函数不需要名字也可以执行。一般，会与apply族函数联用（见第2.5.4节）： sapply(1:5, function(x) x^2) ## [1] 1 4 9 16 25 或者用于 2.6.3.3 二元运算符 定义二元运算符的方式和定义普通函数的方法极其类似，只是参数必须要有且仅有两个（否则作为“二元”运算符就无意义了），且运算符名称需要用引号包围。 比如我们可以定义一个计算椭圆面积的函数 &#39;%el%&#39; &lt;- function(x, y) pi*x*y 2 %el% 5 ## [1] 31.41593 原则上，可自定义的二元运算符不一定要用%包围；+, -, :等符号的功能都可以被自定义，但是它们是R自带的，非常常用的函数，重定义它们只会带来麻烦。 2.6.3.4 闭包 (Closure) 函数里可以包含着另一个函数，这就形成了一个闭包： myfunc &lt;- function(){ a = 5 function(){ b = 10 return(a*b) } } # 执行myfunc()的时候，默认结果为最后一句/一行，在这里应为内函数： myfunc() ## function(){ ## b = 10 ## return(a*b) ## } ## &lt;environment: 0x7f97a2297320&gt; # 既然`myfunc()`的结果是一个函数，那么在后面再加上一个括号就是执行内函数了；内函数可以使用外函数中所定义的变量（比如这里使用了外函数的`a = 5`） myfunc()() ## [1] 50 speak &lt;- function(x){ x()$speak } speak(cat) ## NULL 2.6.3.5 伪·OOP 我貌似，捣鼓出了一种完全使用R中的简易函数实现伪·OOP的方法（R中的真·OOP是有三种，S3，R6和S4）： Cat &lt;- function(name){ name = name binomial_name &lt;- &quot;Felis catus&quot; speak &lt;- &quot;Meow&quot; greet &lt;- function(time = &quot;not_specified&quot;){ intro &lt;- paste(&quot;my name is&quot;, name) if(time == &quot;morning&quot;) print(paste(&quot;Good morning,&quot;, intro)) if(time == &quot;afternoon&quot;) print(paste(&quot;Good afternoon,&quot;, intro)) if(time == &quot;evening&quot;) print(paste(&quot;Good evening,&quot;, intro)) if(time == &quot;not_specified&quot;) print(paste(&quot;Hi,&quot;, intro)) } paste(&quot;Hi, my name is &quot;, name) list(name = name, binomial_name = binomial_name, speak = speak, greet = greet) } Felix &lt;- Cat(&quot;Felix&quot;) Felix$name ## [1] &quot;Felix&quot; Felix$greet(&quot;morning&quot;) ## [1] &quot;Good morning, my name is Felix&quot; inheritance和polymorphism的实现 Pet &lt;- function(name = NA, common_name = NA, binomial_name = NA, speak = NA){ name &lt;- name common_name &lt;- common_name binomial_name &lt;- binomial_name speak &lt;- speak greet &lt;- function(time = &quot;not_specified&quot;){ intro &lt;- paste(&quot;I&#39;m a&quot;, common_name, &quot;and my name is&quot;, name) if(time == &quot;morning&quot;) print(paste(&quot;Good morning,&quot;, intro)) if(time == &quot;afternoon&quot;) print(paste(&quot;Good afternoon,&quot;, intro)) if(time == &quot;evening&quot;) print(paste(&quot;Good evening,&quot;, intro)) if(time == &quot;not_specified&quot;) print(paste(&quot;Hi,&quot;, intro)) } paste(&quot;Hi, my name is &quot;, name) list(name = name, common_name = common_name, binomial_name = binomial_name, speak = speak, greet = greet) } Turtle &lt;- function(name = NA){ Pet(name, &quot;turtle&quot;, &quot;Trachemys scripta elegans&quot;) # 实现inheritance # 龟没有叫声 } Cat &lt;- function(name = NA, sterilized = NA){ sterilized &lt;- sterilized # 猫可能绝育 # 新增attribute，实现了广义的polymorphism PetAaM &lt;- Pet(name, &quot;cat&quot;, &quot;Felis catus&quot;, &quot;Meow&quot;) CatOnlyAaM &lt;- list(sterilized = sterilized) c(PetAaM, CatOnlyAaM) } # 实现了Python语境中的polymorphism greet &lt;- function(pet, time = &quot;not_specified&quot;){ pet$greet(time) } binomial_name &lt;- function(pet){ pet$binomial_name } 使用例： Felix &lt;- Cat(&quot;Felix&quot;, &quot;TRUE&quot;) Kazuya &lt;- Turtle(&quot;Kazuya&quot;) Felix$binomial_name ## [1] &quot;Felis catus&quot; Kazuya$greet(&quot;afternoon&quot;) ## [1] &quot;Good afternoon, I&#39;m a turtle and my name is Kazuya&quot; greet(Felix, &quot;morning&quot;) ## [1] &quot;Good morning, I&#39;m a cat and my name is Felix&quot; sapply(list(Kazuya, Felix), binomial_name) ## [1] &quot;Trachemys scripta elegans&quot; &quot;Felis catus&quot; 没有class，没有self，没有__init__，it just works. 2.6.4 关于... 有时候，你想写的函数可能有数量不定的参数，或是有需要传递给另一个函数的“其他参数”（即本函数不需要的参数），这时候可以在函数定义时加入一个名为...的参数，然后用list()来读取它们。list是进阶内容，在第2.6.6节有说明。 比如我写一个很无聊的函数： my_func &lt;- function(arg1, arg2 = 100, ...){ other_args &lt;- list(...) print(arg1) print(arg2) print(other_args) } my_func(&quot;foo&quot;, cities = c(&quot;崇阳&quot;, &quot;Αθήνα&quot;, &quot;つがる&quot;), nums = c(3,4,6)) ## [1] &quot;foo&quot; ## [1] 100 ## $cities ## [1] &quot;崇阳&quot; &quot;Αθήνα&quot; &quot;つがる&quot; ## ## $nums ## [1] 3 4 6 arg1指定了是&quot;foo&quot;（通过简写），因此第一行印出&quot;foo&quot;; arg2未指定，因此使用默认值100，印在第二行。cities和nums在形式参数中没有匹配，因此归为“…”，作为list印在第三行及之后。 2.6.5 测速 当你开始处理复杂，大量的数据时，或是向别人分享自己的代码时，代码执行的速度变得重要。 一段代码/一个函数经常有很多种写法，哪种效率更高呢？实践是检验真理的唯一标准，R提供了一个测速函数：system.time()函数。 x &lt;- vector(&#39;numeric&#39;) system.time( for (i in 1:50){ for (j in 1:100) { x &lt;- append(x, i*j) } } ) ## user system elapsed ## 0.045 0.021 0.066 其中第三个数字 (elapsed)是执行system.time()括号内的语句实际消耗的时间。可以使用索引 ([3])抓取。 如果括号内的语句大于一句，像这样： system.time( 1 + 1 2 + 1 ) R会报错。就像流程控制里学到的那样，需要用大括号包围多行/多句的语句，就像这样： system.time({ 1 + 1 2 + 1 }) 2.6.6 列表 (list) R中的list是一种特殊的数据存储形式。使用list()函数来创建lists. 尝试对lists和vectors使用is.vector(), is.list(), is.atomic()和is.recursive()函数，你会发现list虽然也是“vector”，但我们一般说的“vector”都是指只能存储一种数据类型的atomic vector；而lists是recursive vector. 这意味着一个list能存储多种类型的数据，且可以包含子list。list中的每个元素可以是任何R中的对象 (object)：除了常用的 (atomic) vector和另外一个（子）list以外，还可以有dataframe/tibble和函数： y &lt;- list(1, c(&quot;a&quot;,&quot;あ&quot;), list(1+3i, c(FALSE, NA, TRUE)), tibble(x = c(&quot;阿拉木图&quot;, &quot;什切青&quot;), y = c(2, 3)), t.test) y ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; &quot;あ&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 1+3i ## ## [[3]][[2]] ## [1] FALSE NA TRUE ## ## ## [[4]] ## # A tibble: 2 x 2 ## x y ## &lt;chr&gt; &lt;dbl&gt; ## 1 阿拉木图 2 ## 2 什切青 3 ## ## [[5]] ## function (x, ...) ## UseMethod(&quot;t.test&quot;) ## &lt;bytecode: 0x7f979e9c1e20&gt; ## &lt;environment: namespace:stats&gt; 2.6.6.1 list的索引/取子集 使用上面的例子： y[2] # 使用单方括号，得到的是一个只有一个list元素的list ## [[1]] ## [1] &quot;a&quot; &quot;あ&quot; y[[2]] # 使用双方括号，得到的是一个vector ## [1] &quot;a&quot; &quot;あ&quot; y[[3]][[2]] # 得到的也是一个vector；父list的索引在前，子list的在后 ## [1] FALSE NA TRUE y[[3]] # 这个位置包含两个子list，因此得到一个有两个list元素的list ## [[1]] ## [1] 1+3i ## ## [[2]] ## [1] FALSE NA TRUE y[[3]][[2]][2] # 得到vector时，直接在后面用单方括号 ## [1] NA list里的元素可以有名字；被命名的元素可以通过$符号抓取： z &lt;- list(c(1, 3), z2 = c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;)) z # `[[2]]`被`$z2`所取代 ## [[1]] ## [1] 1 3 ## ## $z2 ## [1] 4 5 6 ## ## [[3]] ## [1] &quot;a&quot; &quot;b&quot; z$z2 == z[[2]] # `z[[2]]`仍然是可用的，结果和`z$z2`一样 ## [1] TRUE TRUE TRUE 2.6.6.2 合并与拆解 通过c()函数来合并多个列表。 c(list(1, 2), list(3, 4, list(5,6))) # 将等同于list(1, 2, 3, 4, list(5,6)) 也许你想把需要“合并”的列表作为子列表放在另一个列表里；这也很简单，在本节一开始就讲了： list(list(1, 2), list(3, 4)) ## [[1]] ## [[1]][[1]] ## [1] 1 ## ## [[1]][[2]] ## [1] 2 ## ## ## [[2]] ## [[2]][[1]] ## [1] 3 ## ## [[2]][[2]] ## [1] 4 通过unlist()函数来拆解列表中的子列表。若参数recursive为TRUE（默认值），将一直拆解至无子列表的列表，如果此最简列表的元素都属于五种atomic vector中的数据15，此列表还会被进一步化简成向量。若recursive = FALSE，最“靠外”的一级列表（可能是多个）将会被拆解。 unlist(list(1, list(2, list(3, 4)), list(5, 6), 7, 8, 9)) # 将等同于c(1, 2, 3, 4, 5, 6, 7, 8, 9) # 注意被化简成了向量 unlist(list(1, list(2, list(&quot;a&quot;, 4)), list(5, TRUE), 7L, 8, 9+0i)) # 将等同于c(&quot;1&quot;, &quot;2&quot;, &quot;a&quot;, 4, 5, &quot;TRUE&quot;, &quot;7&quot;, 8, &quot;9+0i&quot;) # 化简成向量时，非字符元素被强制转换成字符了 unlist(list(1, list(2, list(t.test, 4)), list(5, TRUE), 7L, x, 9+0i)) # t.test无法存储于向量中，因此最简结果为一个list： # list(1, 2, t.test, 4, 5, TRUE, 7L, x, 9+0i) unlist(list(1, list(2, 3, list(4, 5)), list(6, 7), 8, 9), recursive = FALSE) # 将等同于list(1, 2, 3, list(4, 5), 6, 7, 8, 9) 因此，当A, B为列表，unlist(list(A, B), recursive = FALSE)等同于c(A, B). 2.6.6.3 其他性质和操作 上面说到unlist(list(A, B), recursive = FALSE)等同于c(A, B)，你可能很想用==验证一下。很不幸，你会得到一条错误信息： comparison of these types is not implemented 在第2.4.2节讲过，==只能用于atomic vectors；对于列表（和其他对象）可以用identical()函数确认两者是否完全一致。 A &lt;- list(&quot;a&quot;, 1, TRUE); B &lt;- list(5+8i, NA, 4L) C1 &lt;- unlist(list(A, B), recursive = FALSE); C2 &lt;- c(A, B) identical(C1, C2) ## [1] TRUE 2.6.7 array（数组）和matrix（矩阵）简介 Vector是一维的数据。Array是多维的数据。Matrix是二维的数据，因此matrix是array的一种特殊情况。 Dataframe不是matrix（虽然都是方的）. Matrix是二维的，仅包含数字的array. Dataframe是一个二维的list，不同列（即list元素）可以存储不同的数据类型。 我们可以用dim()来创建arrays： A &lt;- 1:48 #创建一个(1,2,3,...24)的numeric vector dim(A) &lt;- c(6,8) #给A assign一个6乘4的dimensions A ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 7 13 19 25 31 37 43 ## [2,] 2 8 14 20 26 32 38 44 ## [3,] 3 9 15 21 27 33 39 45 ## [4,] 4 10 16 22 28 34 40 46 ## [5,] 5 11 17 23 29 35 41 47 ## [6,] 6 12 18 24 30 36 42 48 可以看到我们创建了一个二维的，array, 因此它也是一个（4行6列的）matrix。 is.array(A) ## [1] TRUE is.matrix(A) ## [1] TRUE 注意24个数字排列的方式。第一个维度是行，所以先把4行排满，随后再使用下一个维度（列），使用第2列继续排4行，就像数字一样，（十进制中）先把个位从零数到9，再使用第二个位数（十位），以此类推。下面三维和四维的例子可能会更清晰。 同时注意最左边和最上边的[1,], [,3]之类的标记。你应该猜出来了，这些是index. 假设你要抓取第五行第三列的数值： A[5,3] ## [1] 17 或者第三行的全部数值： A[3,] ## [1] 3 9 15 21 27 33 39 45 或者第四列的全部数值： A[,4] ## [1] 19 20 21 22 23 24 接下来我们再看一个三维的例子（还是用1-48）： dim(A) &lt;- c(2,8,3) A ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 3 5 7 9 11 13 15 ## [2,] 2 4 6 8 10 12 14 16 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 17 19 21 23 25 27 29 31 ## [2,] 18 20 22 24 26 28 30 32 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 33 35 37 39 41 43 45 47 ## [2,] 34 36 38 40 42 44 46 48 它生成了三个二维的矩阵。在每个2*8的矩阵存储满16个元素后，第三个维度就要加一了。每个矩阵开头的, , x正是第三个维度的值。同理，我们可以生成四维的array： dim(A) &lt;- c(3,4,2,2) A ## , , 1, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## ## , , 2, 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 13 16 19 22 ## [2,] 14 17 20 23 ## [3,] 15 18 21 24 ## ## , , 1, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 25 28 31 34 ## [2,] 26 29 32 35 ## [3,] 27 30 33 36 ## ## , , 2, 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 37 40 43 46 ## [2,] 38 41 44 47 ## [3,] 39 42 45 48 观察每个矩阵开头的, , x, y. x是第三个维度，y是第四个维度。每个二位矩阵存满后，第三个维度（x）加一。x达到上限后，第四个维度（y）再加一。 类似二维矩阵，你可以通过index任意抓取数据，比如： A[ ,3 , , ] #每个矩阵第3列的数据，即所有第二个维度为3的数值 ## , , 1 ## ## [,1] [,2] ## [1,] 7 19 ## [2,] 8 20 ## [3,] 9 21 ## ## , , 2 ## ## [,1] [,2] ## [1,] 31 43 ## [2,] 32 44 ## [3,] 33 45 2.6.8 给matrices和arrays命名 假设我们记录了3种药物（chloroquine, artemisinin, doxycycline) 对5种疟原虫(P. falciparum, P. malariae, P. ovale, P. vivax, P. knowlesi)的疗效，其中每个药物对每种疟原虫做6次实验。为了记录数据，我们可以做3个6*5的矩阵：（这里只是举例子，用的是随机生成的数字） B &lt;- runif(90, 0, 1) #从均匀分布中取100个0到1之间的数 dim(B) &lt;- c(6, 5, 3) #注意顺序 B ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.1861744 0.5000165 0.44551437 0.05892448 0.3164979 ## [2,] 0.3900032 0.1596277 0.80534495 0.64744073 0.5922818 ## [3,] 0.4882810 0.6280302 0.55634760 0.92535151 0.7957400 ## [4,] 0.6990868 0.4189019 0.19209617 0.84702550 0.8954517 ## [5,] 0.6850176 0.2461251 0.94373407 0.78226857 0.2558703 ## [6,] 0.5670890 0.6134390 0.01603388 0.33881476 0.2497919 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.6416063 0.9533924 0.55560448 0.9404194 0.3124226 ## [2,] 0.3844143 0.9562934 0.86280331 0.6544235 0.7339915 ## [3,] 0.5754016 0.7807161 0.53677911 0.7216236 0.7288141 ## [4,] 0.8415234 0.4881054 0.07280601 0.8243038 0.6576248 ## [5,] 0.0664043 0.6128357 0.05512132 0.5211947 0.7068323 ## [6,] 0.9549221 0.5074162 0.30353022 0.3574190 0.7052563 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.075424019 0.8312364 0.9286026 0.89367914 0.0292949229 ## [2,] 0.415054445 0.5941399 0.6575068 0.78341988 0.4688914833 ## [3,] 0.156175746 0.9815647 0.5535530 0.90773021 0.1752072817 ## [4,] 0.858968162 0.8522387 0.8290824 0.15486727 0.4415367201 ## [5,] 0.746419420 0.1610471 0.1128177 0.09782018 0.3813265013 ## [6,] 0.006982461 0.5823524 0.3175556 0.89822046 0.0005802356 然后我们用dimnames()来命名： dimnames(B) &lt;- list(paste(&quot;trial.&quot;, 1:6), c(&#39;P. falciparum&#39;, &#39;P. malariae&#39;, &#39;P. ovale&#39;, &#39;P. vivax&#39;, &#39;P. knowlesi&#39;), c(&#39;chloroquine&#39;, &#39;artemisinin&#39;, &#39;doxycycline&#39;)) B ## , , chloroquine ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.1861744 0.5000165 0.44551437 0.05892448 0.3164979 ## trial. 2 0.3900032 0.1596277 0.80534495 0.64744073 0.5922818 ## trial. 3 0.4882810 0.6280302 0.55634760 0.92535151 0.7957400 ## trial. 4 0.6990868 0.4189019 0.19209617 0.84702550 0.8954517 ## trial. 5 0.6850176 0.2461251 0.94373407 0.78226857 0.2558703 ## trial. 6 0.5670890 0.6134390 0.01603388 0.33881476 0.2497919 ## ## , , artemisinin ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.6416063 0.9533924 0.55560448 0.9404194 0.3124226 ## trial. 2 0.3844143 0.9562934 0.86280331 0.6544235 0.7339915 ## trial. 3 0.5754016 0.7807161 0.53677911 0.7216236 0.7288141 ## trial. 4 0.8415234 0.4881054 0.07280601 0.8243038 0.6576248 ## trial. 5 0.0664043 0.6128357 0.05512132 0.5211947 0.7068323 ## trial. 6 0.9549221 0.5074162 0.30353022 0.3574190 0.7052563 ## ## , , doxycycline ## ## P. falciparum P. malariae P. ovale P. vivax P. knowlesi ## trial. 1 0.075424019 0.8312364 0.9286026 0.89367914 0.0292949229 ## trial. 2 0.415054445 0.5941399 0.6575068 0.78341988 0.4688914833 ## trial. 3 0.156175746 0.9815647 0.5535530 0.90773021 0.1752072817 ## trial. 4 0.858968162 0.8522387 0.8290824 0.15486727 0.4415367201 ## trial. 5 0.746419420 0.1610471 0.1128177 0.09782018 0.3813265013 ## trial. 6 0.006982461 0.5823524 0.3175556 0.89822046 0.0005802356 清清楚楚，一目了然。 2.6.9 小测 转换年份到世纪。写一个名为as.century的函数，把存储着年份的向量，比如years &lt;- c(2014, 1990, 1398, 1290, 1880, 2001)，转换成对应的世纪（注意，19XX年是20世纪）。 斐波那契数列。 背景：斐波那契数列是指\\(F = [1, 1, 2, 3, 5, 8, ...]\\)，其中： \\(F_1 = 1\\)，\\(F_2 = 1\\) 从\\(F_3\\)开始，\\(F_i = F_{i-2} + F_{i-1}\\) (也有\\(F_0=0, F_1=1\\)的说法，但是为了方便我们不用这个定义) 题目：创建一个函数名为fibon()的函数，使得fibon(i)： 当\\(i\\in \\mathbb{Z}^+\\)时，返回向量\\([F_1, F_2, \\ldots, F_i]\\) 当\\(i\\notin \\mathbb{Z}^+\\)时，返回&quot;请输入一个正整数作为`fibon()`的参数。&quot; 提示： 虽然在R中整数用1L, 2L等表示，用户在被指示“输入整数”的时候很有可能输入的是2而不是2L. 2是否等于2L?如果是，如何利用它检测输入的是否是整数？（2和2L都要被判定为“是整数”） 斐波那契数列前两位是定义，从第三位开始才是计算得出的。 References "],
["tibble.html", "Chapter 3 dataframe和tibble；简单的数据分析 ", " Chapter 3 dataframe和tibble；简单的数据分析 "],
["tibble-view.html", "3.1 查看dataframe/tibble并了解它们的结构", " 3.1 查看dataframe/tibble并了解它们的结构 3.1.1 dataframe/tibble的基本概念 dataframe是R中存储复杂（多变量）数据的规范格式，它直观易操作。tibble是tidyverse的一部分，它是dataframe的进化版，功能更强大，更易操作。 我们来看个例子： 首先加载tidyverse： require(tidyverse) 以后每次跟着本书使用R的时候，都要先加载tidyverse，不再重复提醒了。 tidyverse中自带一些范例数据，比如我们输入： mpg 这张图是重中之重。一个正确的dataframe/tibble，每一行代表的是一个observation（硬翻译的话是“观测单位”，但是我觉得这个翻译不好），每一列代表的是一个variable（变量），且同一个变量的数据类型必须一样。像这样的数据被称为“tidy data”（“整齐的数据”）。虽然看起来简单，直观，理所当然，但是现实中上人们经常会做出“不整齐”的数据。把不整齐的数据弄整齐是下一章的重点。 3.1.2 查看更多数据 R默认显示dataframe/tibble的前10行。如果想看最后6行，可以使用tail()函数，比如： tail(mpg) ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 volkswagen passat 1.8 1999 4 auto… f 18 29 p mids… ## 2 volkswagen passat 2 2008 4 auto… f 19 28 p mids… ## 3 volkswagen passat 2 2008 4 manu… f 21 29 p mids… ## 4 volkswagen passat 2.8 1999 6 auto… f 16 26 p mids… ## 5 volkswagen passat 2.8 1999 6 manu… f 18 26 p mids… ## 6 volkswagen passat 3.6 2008 6 auto… f 17 26 p mids… 若要从头到尾查看全部数据，可以使用View函数： View(mpg) "],
["tibble-basics.html", "3.2 tibble的创建和基础操作", " 3.2 tibble的创建和基础操作 3.2.1 创建tibble 3.2.1.1 手动输入数据以创建tibble 使用tibble函数，按以下格式创建tibble. 换行不是必须的，但是换行会看得更清楚。如果换行，不要忘记行末的逗号。 my_tibble_1 &lt;- tibble( nums = c(4, 5, 6), chars = c(&quot;hej&quot;, &quot;你好&quot;, &quot;こんにちは&quot;), cplxnums = c(&quot;4+8i&quot;, &quot;3+5i&quot;, &quot;3+4i&quot;) ) my_tibble_1 ## # A tibble: 3 x 3 ## nums chars cplxnums ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 4 hej 4+8i ## 2 5 你好 3+5i ## 3 6 こんにちは 3+4i 类似地，可以从现有的vector创建。所有的变量长度必须一样。 x &lt;- c(1,4,5) y &lt;- c(211,23,45) z &lt;- c(20,32) my_tibble_2 &lt;- tibble(v1 = x, v2 = y) my_tibble_2 ## # A tibble: 3 x 2 ## v1 v2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 211 ## 2 4 23 ## 3 5 45 而试图把x和z做成tibble就会报错： my_tibble_3 &lt;- tibble(w1 = x, w2 = z) # Error: Tibble columns must have consistent lengths, only values of length one are recycled: * Length 2: Column `w2` * Length 3: Column `w1` 3.2.1.2 把dataframe转换成一个tibble d1 &lt;- as_tibble(d) #其中d是一个dataframe 3.2.1.3 从外部数据创建tibble 参见第5.2.1节（数据的导入） "],
["data-transformation.html", "3.3 数据转换 (Data Transformation)", " 3.3 数据转换 (Data Transformation) 数据转换，简而言之，就是对原有数据的展示形式做一些改动，因而把最有意义的数值以易读的形式展示出来，或是为绘图做准备。 3.3.1 取子集（抓取行，列）{tbl-subsetting} 本小节介绍了如何使用dplyr package提供的select(), filter(), slice取子集方法 更详细的解释请看第3.4.1.2节。 3.3.1.1 抓取单列 抓取单列很简单，也很常用（比如我们只想从一个大的tibble中抓两个变量研究它们之间的关系）。 有两个符号可以用于抓取列，$（仅用于变量名称）与[[]]（变量名称或索引）。还是以mpg为例，假设我们要抓取第3列 (displ)： ######################## #通过变量名称抓取： mpg[[&quot;displ&quot;]] #或 mpg$displ #一般，在RStudio中此方法最方便，因为打出“$”之后会自动提示变量名。 ######################## #通过索引抓取： mpg[[3]] 以上三种方法都应得到同样的结果（是一个vector）： ## [1] 1.8 1.8 2.0 2.0 2.8 2.8 3.1 1.8 1.8 2.0 2.0 2.8 2.8 3.1 3.1 2.8 3.1 ## [18] 4.2 5.3 5.3 一般我们抓取单列是为了在tibble中新建一个与那一列相关的变量，或是建一个新tibble，或是做统计学分析。以上三种情况（是绝大多数的情况）用vector进行操作很方便。 假设你在写一个复杂的函数，且需要保持数据的完整性和一致性，可以使用单方括号[；这样得到的是一个tibble（试试mpg[3]）这个特性在第3.4.1.2节中有解释。 3.3.1.2 抓取多列并返回一个tibble 有时候，一个tibble中含有很多冗余信息，我们可能想把感兴趣的几个变量抓出来做一个新tibble. 这时select()函数最为方便。可以用变量名称或者索引来抓取。比如： mpg_new &lt;- select(mpg, 3:5, 8, 9) #等同于 mpg_new &lt;- select(mpg, displ, year, cyl, cty, hwy) mpg_new ## # A tibble: 234 x 5 ## displ year cyl cty hwy ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1.8 1999 4 18 29 ## 2 1.8 1999 4 21 29 ## 3 2 2008 4 20 31 ## 4 2 2008 4 21 30 ## 5 2.8 1999 6 16 26 ## 6 2.8 1999 6 18 26 ## 7 3.1 2008 6 18 27 ## 8 1.8 1999 4 18 26 ## 9 1.8 1999 4 16 25 ## 10 2 2008 4 20 28 ## # … with 224 more rows 显然，使用变量名抓取列比使用索引更好。虽然打字较多，但是易读性比使用索引强太多了。在向其他人展示或者分享你的工作时，易读性尤为重要。 3.3.1.3 通过filter()，抓取满足某条件的行 通过filter()，我们可以过滤出某个或多个变量满足某种条件的observations. 如果你还不熟悉逻辑运算，请看第2.4节 假设我们只想看mpg中的奥迪品牌的，排量大于等于2且小于4的车辆的数据： mpg_audi_displ2to4 &lt;- filter(mpg, manufacturer == &quot;audi&quot;, displ &gt;= 2.5 &amp; displ &lt; 4) mpg_audi_displ2to4 ## # A tibble: 9 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 2 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 3 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 4 audi a4 qu… 2.8 1999 6 auto… 4 15 25 p comp… ## 5 audi a4 qu… 2.8 1999 6 manu… 4 17 25 p comp… ## 6 audi a4 qu… 3.1 2008 6 auto… 4 17 25 p comp… ## 7 audi a4 qu… 3.1 2008 6 manu… 4 15 25 p comp… ## 8 audi a6 qu… 2.8 1999 6 auto… 4 15 24 p mids… ## 9 audi a6 qu… 3.1 2008 6 auto… 4 17 25 p mids… 3.3.1.4 用slice()，通过行数（索引）抓取行。 mpg_1to6 &lt;- slice(mpg, 21:26) # 抓取mpg的第21行至26行 mpg_1to6 ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet c1500… 5.3 2008 8 auto… r 14 20 r suv ## 2 chevrolet c1500… 5.7 1999 8 auto… r 13 17 r suv ## 3 chevrolet c1500… 6 2008 8 auto… r 12 17 r suv ## 4 chevrolet corve… 5.7 1999 8 manu… r 16 26 p 2sea… ## 5 chevrolet corve… 5.7 1999 8 auto… r 15 23 p 2sea… ## 6 chevrolet corve… 6.2 2008 8 manu… r 16 26 p 2sea… slice()更实际的用途是随机选择个体： mpg_random4 &lt;- slice(mpg, sample(length(mpg[[1]]), 4)) # 随机四辆车 mpg_random4 ## # A tibble: 4 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 mercury mount… 4 2008 6 auto… 4 13 19 r suv ## 2 toyota corol… 1.8 1999 4 manu… f 26 35 r comp… ## 3 toyota 4runn… 2.7 1999 4 auto… 4 16 20 r suv ## 4 toyota toyot… 3.4 1999 6 auto… 4 15 19 r pick… 3.3.2 用mutate()修改或新增变量 mutate()函数用于新增一列数据（即新增一个变量）。 这里用R自带的一组数据举例，因为它是以dataframe格式存储的，首先我们需要把它转换成tibble. women &lt;- as_tibble(datasets::women) women ## # A tibble: 15 x 2 ## height weight ## &lt;dbl&gt; &lt;dbl&gt; ## 1 58 115 ## 2 59 117 ## 3 60 120 ## 4 61 123 ## 5 62 126 ## 6 63 129 ## 7 64 132 ## 8 65 135 ## 9 66 139 ## 10 67 142 ## 11 68 146 ## 12 69 150 ## 13 70 154 ## 14 71 159 ## 15 72 164 它展示了两个变量，身高和体重。根据这两个变量我们可以算出BMI. 但是，首先，我们的单位正确吗？通过观察，身高的值在64左右，体重的值在140左右，显然不像是标准单位（千克和米）。这时，第一个寻求帮助的地方应该是帮助文档，通过?women打开。帮助文档中写道： [,1] height numeric Height (in) [,2] weight numeric Weight (lbs) 原来分别是以英寸和磅做单位的。根据1 m = 39.370 in, 1 kg = 2.204 lbs： women1 &lt;- mutate(women, height_in_m = height/39.37, weight_in_kg = weight/2.204) women1 ## # A tibble: 15 x 4 ## height weight height_in_m weight_in_kg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 58 115 1.47 52.2 ## 2 59 117 1.50 53.1 ## 3 60 120 1.52 54.4 ## 4 61 123 1.55 55.8 ## 5 62 126 1.57 57.2 ## 6 63 129 1.60 58.5 ## 7 64 132 1.63 59.9 ## 8 65 135 1.65 61.3 ## 9 66 139 1.68 63.1 ## 10 67 142 1.70 64.4 ## 11 68 146 1.73 66.2 ## 12 69 150 1.75 68.1 ## 13 70 154 1.78 69.9 ## 14 71 159 1.80 72.1 ## 15 72 164 1.83 74.4 mutate()的第一个参数是dataframe/tibble的名称，接下来的参数都是变量名和它们所对应的值；可以直接在计算它们的值的表达式中使用tibble中原有的变量名，如height, weight。 当然你可以引用tibble外部的vector或者其它tibble的数据： h &lt;- women1$height_in_m women2 &lt;- mutate(women, height_in_m = h, # 引用外部vector weight_in_kg = women1$weight_in_kg) # 引用`women1`里的数据 identical(women2 ,women1) # 和`women1`是相同的 ## [1] TRUE mutate()也可以用来重新赋值原有变量。假设我们根本不再需要以英寸和磅作为单位的数据，我们可以： women3 &lt;- mutate(women, height = height/39.37, weight = weight/2.204) head(women3, 3) ## # A tibble: 3 x 2 ## height weight ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1.47 52.2 ## 2 1.50 53.1 ## 3 1.52 54.4 接下来我们可以愉快地算BMI了： women_bmi_1 &lt;- mutate(women3, BMI = weight/height^2) head(women_bmi_1, 4) ## # A tibble: 4 x 3 ## height weight BMI ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.47 52.2 24.0 ## 2 1.50 53.1 23.6 ## 3 1.52 54.4 23.4 ## 4 1.55 55.8 23.2 如果你在创建新变量后，不想保留原有变量，可以用transmute()函数： women_bmi_2 &lt;- transmute(women3, BMI = weight/height^2) head(women_bmi_2, 4) ## # A tibble: 4 x 1 ## BMI ## &lt;dbl&gt; ## 1 24.0 ## 2 23.6 ## 3 23.4 ## 4 23.2 这意味着transmute()函数也可以用于重命名变量： women_bmi_3 &lt;- transmute(women_bmi_2, body_mass_index = BMI) head(women_bmi_3, 3) ## # A tibble: 3 x 1 ## body_mass_index ## &lt;dbl&gt; ## 1 24.0 ## 2 23.6 ## 3 23.4 3.3.3 %&gt;%符号 (Pipe Operator) 通过上面学习的方法，我们来初步处理一个叫做Aids2的数据；首先，把它做成tibble并重命名为更简洁的aids aids &lt;- as_tibble(MASS::Aids2) aids ## # A tibble: 2,843 x 7 ## state sex diag death status T.categ age ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 NSW M 10905 11081 D hs 35 ## 2 NSW M 11029 11096 D hs 53 ## 3 NSW M 9551 9983 D hs 42 ## 4 NSW M 9577 9654 D haem 44 ## 5 NSW M 10015 10290 D hs 39 ## 6 NSW M 9971 10344 D hs 36 ## 7 NSW M 10746 11135 D other 36 ## 8 NSW M 10042 11069 D hs 31 ## 9 NSW M 10464 10956 D hs 26 ## 10 NSW M 10439 10873 D hsid 27 ## # … with 2,833 more rows 你要如何知道，各个变量代表什么意思？假设我们只想知道这些艾滋病人从被确诊到死亡的时间，而对其他的变量都不感兴趣，我们要去如何裁剪和转换这个tibble？ 问题看起来很简单，你也许不假思索地就这么做了： aids1 &lt;- select(aids, diag, death) aids2 &lt;- mutate(aids1, span = death-diag) aids2 ## # A tibble: 2,843 x 3 ## diag death span ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 10905 11081 176 ## 2 11029 11096 67 ## 3 9551 9983 432 ## 4 9577 9654 77 ## 5 10015 10290 275 ## 6 9971 10344 373 ## 7 10746 11135 389 ## 8 10042 11069 1027 ## 9 10464 10956 492 ## 10 10439 10873 434 ## # … with 2,833 more rows 错！ 切记，不要自作主张地推测变量的含义！一定要看作者的说明（帮助文档）！对于这个数据，在R中使用?Aids2便可以查看帮助文档，但如果数据来源于其他地方，帮助文档放置的位置多种多样（虽然一般都作为README文件与数据共同打包下载），这时需要随机应变。 即使你猜对了diag和death是两个日期，你万万不会想到death并不一定是死亡日期。实际上，它是“死亡日期”或“观察结束日期”，而status变量指示的是观察结束时患者的生/死(&quot;A&quot;/&quot;D&quot;). 所以我们实际上应该这么做： aids1 &lt;- filter(aids, status == &quot;D&quot;) # 只关注在观察期间死亡的病人 aids2 &lt;- select(aids1, diag, death) # 只关注确诊时间和死亡时间 aids_span1 &lt;- mutate(aids2, span = death-diag) # 计算时间间隔 aids_span1 ## # A tibble: 1,761 x 3 ## diag death span ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 10905 11081 176 ## 2 11029 11096 67 ## 3 9551 9983 432 ## 4 9577 9654 77 ## 5 10015 10290 275 ## 6 9971 10344 373 ## 7 10746 11135 389 ## 8 10042 11069 1027 ## 9 10464 10956 492 ## 10 10439 10873 434 ## # … with 1,751 more rows 这次我们得到了正确的数据，但是源代码非常繁琐：每进行一步操作，我们都要创建一个新的变量，然后再下一步中引用上一步创建的新变量。事实上，我们可以利用函数的嵌套把它化简： aids_span2 &lt;- mutate( select( filter(aids, status == &quot;D&quot;), diag, death ), span = death-diag ) # 验证两种方法的结果一致 identical(aids_span1, aids_span2) ## [1] TRUE 虽然字数减少了，但是这种表达产生了新的问题：它既难读又难写。难读是很明显的，你要从最内部读到最外部（而不是从头读到尾），而且需要好的眼力才能把函数和参数对上号。至于难写，是因为逻辑和书写不一致：逻辑是先filter()再select()最后mutate()，而写的时候，需要不断往周围加括号，很难一气呵成。 使用%&gt;%可以极大地增强多步骤指令的易读性和易写性。上面的代码可以改写成这样（换行不是必须的）： aids_span3 &lt;- aids %&gt;% filter(status == &quot;D&quot;) %&gt;% select(diag, death) %&gt;% mutate(span = death-diag) # 验证和方法二的结果一致（即和方法一一致） identical(aids_span2, aids_span3) ## [1] TRUE 清清楚楚，一目了然。第一行是操作的对象 (aids)，下面每一行是一次操作，与逻辑顺序一致，而且不需要每进行一次操作就赋值/重新引用新的数据，每个函数的第一个参数（dataframe/tibble名称）被省略了。事实上，%&gt;%符号做的事情，本质上就是把它左边的运算结果作为右边函数的第一个参数，然后再根据使用者提供的其它参数计算右边的函数。 %&gt;%的名称是“pipe operator”，和赋值符号“&lt;-”一样有快捷键，默认是Ctrl(command)+shift+M，不过可以在Tools &gt; Modify Keyboard Shortcut中自定义（在它的面板中搜索pipe operator ），我喜欢设置成Alt(option)+.。 3.3.4 group_by与summarise 这是两个经常被放在一起使用的，实用且强大的函数。这次我们用到的数据是datasets::warpbreaks. wb &lt;- as_tibble(datasets::warpbreaks) wb ## # A tibble: 54 x 3 ## breaks wool tension ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 26 A L ## 2 30 A L ## 3 54 A L ## 4 25 A L ## 5 70 A L ## 6 52 A L ## 7 51 A L ## 8 26 A L ## 9 67 A L ## 10 18 A M ## # … with 44 more rows 通过查看帮助文档，得知这组数据是在描述羊毛类型（A或B）和张力（L, M, H, 即低，中，高）对每个织机的经纱断裂数量 (breaks)的影响。首先通过group_by函数，我们把数据首先根据wool再根据tension分组。 wb_grouped &lt;- group_by(wb, wool, tension) 这时，如果你查看wb_grouped，你很难发现它与原来的wb的区别（除了第二行的# Groups: wool, tension [6]）；但是通过summarise()函数，你可以根据分组计算相应的数据： wb_summary &lt;- summarise(wb_grouped, n = n(), MEAN = mean(breaks)) wb_summary ## # A tibble: 6 x 4 ## # Groups: wool [2] ## wool tension n MEAN ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 A L 9 44.6 ## 2 A M 9 24 ## 3 A H 9 24.6 ## 4 B L 9 28.2 ## 5 B M 9 28.8 ## 6 B H 9 18.8 这里，你要想象原来的54行（54个observations）被分成6组，每组代表不同的wool和tension的组合。然后，对于每组，我们先用n()函数计算出每组的行数（多少个observations），并把它赋值给n；再通过mean(breaks)计算每组数据的breaks变量的平均值，并把它赋值给MEAN；最后，对于每组，我们都有了行数和平均值，于是返回一个新的tibble反映这些数据。 类似地，我们可以更进一步，把\\(95%\\)置信区间算出来： wb_summary &lt;- summarise(wb_grouped, n = n(), MEAN = mean(breaks), SE = sd(breaks)/sqrt(n), t = qt(0.975, n-1), upper = MEAN + t*SE, lower = MEAN - t*SE) 注意，在summarise()函数中创建的变量，如n和MEAN，可以在赋值后面的变量时直接引用，比如SE = sd(breaks)/sqrt(n)中引用了n, upper = MEAN + t*SE中引用了前面刚创建的MEAN, t, SE. 根据这些数据，我们可以很方便地用ggplot绘一个柱状图（在下一章详细讲）： ggplot(wb_summary, aes(tension, fill = wool))+ geom_col(aes(y = MEAN), position = position_dodge())+ geom_errorbar(aes(ymax = upper, ymin = lower), position = position_dodge((width=1)), width = 0.2, size = 0.4)+ theme_light() 再用我们的老朋友mpg举一个例子： mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows 你要如何根据manufacturer分组，查看每组中cty和hwy的平均值和标准误呢？自己尝试一下，然后对答案： mpg_summary &lt;- mpg %&gt;% group_by(manufacturer) %&gt;% summarise(n = n(), cty_mean = mean(cty), cty_SE = sd(cty)/sqrt(n), hwy_mean = mean(hwy), hwy_SE = sd(hwy)/sqrt(n)) mpg_summary ## # A tibble: 15 x 6 ## manufacturer n cty_mean cty_SE hwy_mean hwy_SE ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 audi 18 17.6 0.465 26.4 0.513 ## 2 chevrolet 19 15 0.671 21.9 1.17 ## 3 dodge 37 13.1 0.409 17.9 0.588 ## 4 ford 25 14 0.383 19.4 0.666 ## 5 honda 9 24.4 0.648 32.6 0.852 ## 6 hyundai 14 18.6 0.401 26.9 0.582 ## 7 jeep 8 13.5 0.886 17.6 1.15 ## 8 land rover 4 11.5 0.289 16.5 0.866 ## 9 lincoln 3 11.3 0.333 17 0.577 ## 10 mercury 4 13.2 0.25 18 0.577 ## 11 nissan 13 18.1 0.950 24.6 1.41 ## 12 pontiac 5 17 0.447 26.4 0.510 ## 13 subaru 14 19.3 0.244 25.6 0.309 ## 14 toyota 34 18.5 0.694 24.9 1.06 ## 15 volkswagen 27 20.9 0.877 29.2 1.02 最终我们可以利用这些数据绘图（这将是下一章的练习）： "],
["tibble-misc.html", "3.4 其它", " 3.4 其它 3.4.1 list和dataframe/tibble 3.4.1.1 Dataframe和tibble的本质 聪明的你也许已经注意到了，dataframe/tibble抓取单列的方法和list的取子集2.6.6.1惊人地相似。事实上，dataframe的本质正是list，而tibble也是dataframe（只是进化了一些功能）： is.list(mpg) ## [1] TRUE class(mpg) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 3.4.1.2 Dataframe/tibble的取子集 Dataframe/tibble既有list的特征，也有matrix的特征。 当使用一个参数取子集的时候，比如mpg[[3]]，mpg[[&quot;displ&quot;]]或mpg$displ，tibble表现得像list，其中每一列是一个有命名的list element； 当使用两个参数取子集的时候，比如mpg[3,4], mpg[3, ], mpg[ ,4]，tibble表现得像matrix mpg[3, ] ## # A tibble: 1 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 2 2008 4 manua… f 20 31 p comp… 3.4.2 Tidyverse tibble相对于Base R dataframe的优势 你可以把mpg转换成dataframe，命名为mpg1，探索两者的区别。 mpg1 &lt;- as.data.frame(mpg) 3.4.2.1 信息的显示 首先，查看print()结果（直接输入mpg1或者print(mpg1)） 对于行数/列数较多的数据，dataframe的显示结果很乱，而且信息量小。当行数较多时，你需要往上划才能看见变量名；当你的console比较窄或者变量名太多时，dataframe会先显示一部分变量（列），再把剩余的变量（列）显示在后面。这时你需要往上划查看一部分变量，再往上划查看另一部分变量。 tibble的显示结果一致性强，信息量大。它永远只显示前10行，因此不用往上划就能看到显示的所有信息。它指明了行数和列数，变量的数据类型；当变量较多时，不会影响显示，而是在末尾指明其余的变量名字和数据类型。 3.4.2.2 tibble不会自作主张地化简结果 Base R dataframe自带的取子集函数在一些情况下不会化简结果，而在另一些情况下会自动化简结果16，这经常会造成意想不到而且很难察觉的错误，尤其对于开发者来说简直是噩梦(Gentleman 2009, 33; Wickham 2019)。对tibble取子集，永远会返回一个tibble；这样可以提高代码的一致性，降低发生错误的可能性。 请查看Advanced R了解更多。 3.4.2.3 tibble与其它tidyverse中的功能兼容性更强 很多tidyverse中的神器，如group_by，只能在tibble上使用。 References "],
["graphics.html", "Chapter 4 使用ggplot绘图", " Chapter 4 使用ggplot绘图 若要了解更多，请阅读ggplot开发者本人所编写的ggplot2: Elegand Graphics for Data Analysis(Wickham 2015)。 References "],
["g-phil.html", "4.1 哲理", " 4.1 哲理 "],
["g-basics.html", "4.2 基础", " 4.2 基础 4.2.1 基本语法 4.2.2 图像类型 "],
["g-intermediate.html", "4.3 进阶", " 4.3 进阶 4.3.1 逐层作图 4.3.2 尺寸，轴，和图例 4.3.3 位置 4.3.4 背景/主题的修改 4.3.5 与ggplot编程 "],
["g-base.html", "4.4 附：Base R中的作图", " 4.4 附：Base R中的作图 "],
["wrangle.html", "Chapter 5 数据处理 ", " Chapter 5 数据处理 "],
["untidy-to-tidy.html", "5.1 把“untidy data”整成“tidy data”", " 5.1 把“untidy data”整成“tidy data” 5.1.1 “untidy data”的主要问题 5.1.2 解决方案 "],
["import-export.html", "5.2 数据的导入和导出", " 5.2 数据的导入和导出 5.2.1 导入 5.2.1.1 csv 5.2.1.2 excel 5.2.1.3 其它 5.2.2 导出 "],
["strings.html", "5.3 字符串的处理", " 5.3 字符串的处理 Base R中有一些用于操作字符串的函数，但是因为各种原因它们很难用。因此我们使用一系列stringr中的函数（stringr是tidyverse的一部分）。stringr的函数都以str_开头。 5.3.1 基础 5.3.1.1 引号的使用 字符串可以用单引号和双引号包围。在双引号包围的环境下，可以很容易打出英澳常用的单引号和欧洲语言中的“撇”；在单引号包围的环境下，可以很容易打出北美和中国常用的双引号。否则需要使用转义字符 (escape character), \\. 以下是几个正确的例子。 &quot;&#39;The unexamined life is not worth living&#39; —Socrates&quot; ## [1] &quot;&#39;The unexamined life is not worth living&#39; —Socrates&quot; &quot;La science n&#39;a pas de patrie.&quot; ## [1] &quot;La science n&#39;a pas de patrie.&quot; &#39;&quot;老子曰：“知不知，尚矣；不知知，病矣。&quot;&#39; ## [1] &quot;\\&quot;老子曰：“知不知，尚矣；不知知，病矣。\\&quot;&quot; &#39;l\\&#39;homme&#39; ## [1] &quot;l&#39;homme&quot; 5.3.1.2 换行符和制表符 假设你想显示以下效果： ## Guten ## ## Morgen. 即“Guten”后有两次换行，第三行开头有一个制表符 (TAB) 你需要的源代码是： &quot;Guten\\n\\n\\tMorgen.&quot; \\n (newline)为换行符，\\t (tab)为制表符。所有可用的通过\\实现的符号请参见help(&quot;'&quot;)（关于引号的帮助）. 5.3.1.3 print()和writeLines() print()只显示源码，writeLines()显示真实效果。 print(c(&quot;Guten\\n\\n\\tMorgen.&quot;, &quot;Guten\\n\\n\\tTag&quot;)) ## [1] &quot;Guten\\n\\n\\tMorgen.&quot; &quot;Guten\\n\\n\\tTag&quot; writeLines(c(&quot;Guten\\n\\n\\tMorgen.&quot;, &quot;Guten\\n\\n\\tTag&quot;)) ## Guten ## ## Morgen. ## Guten ## ## Tag 索引和引号消失了，不同的元素之间有换行。 5.3.2 使用str_sub()取子集 A &lt;- &quot;D. rerio&quot; str_sub(A, 1, 5) # 第1到第5个字母。计入符号和空格。 ## [1] &quot;D. re&quot; str_sub(A, 4, 4) # 抓取一个字母 ## [1] &quot;r&quot; str_sub(A, -4, -2) # 倒数第4至倒数第2 ## [1] &quot;eri&quot; 我们还可以通过索引修改某个位置的字符： W &lt;- &quot;D. Rerio&quot; str_sub(W, 4, 4) &lt;- str_to_lower(str_sub(W, 4, 4)) W ## [1] &quot;D. rerio&quot; 和str_to_lower()相关的函数还有str_to_upper(), str_to_title()和str_to_sentence(). 它们的作用都顾名思义。 5.3.3 使用str_c()进行字符串的合并 一个简单的例子： str_c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;&quot;) ## [1] &quot;abc&quot; 其中参数sep是被合并的字符串之间的连接字符；它可以是任何字符，包括空格和无（比如上面的例子；用sep = &quot;&quot;表示无连接字符）。 当需要合并的字符串保存在一个向量里时，用collapse而不是sep： str_c(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), collapse = &quot;[x@&quot;) ## [1] &quot;a[x@b[x@c&quot; str_c()可以执行向量化运算： str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) ## [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 所以我们可以这么玩： 混沌在各地的称呼 &lt;- str_c( str_c( &quot;地区&quot;, c(&quot;北京&quot;, &quot;湖北&quot;, &quot;巴蜀&quot;, &quot;两广&quot;, &quot;闽台&quot;), sep = &quot;：&quot; ), str_c( &quot;称呼&quot;, c(&quot;混沌&quot;, &quot;包面&quot;, &quot;抄手&quot;, &quot;云吞&quot;, &quot;扁食&quot;), sep = &quot;：&quot; ), sep = &quot; &quot; ) writeLines(混沌在各地的称呼) ## 地区：北京 称呼：混沌 ## 地区：湖北 称呼：包面 ## 地区：巴蜀 称呼：抄手 ## 地区：两广 称呼：云吞 ## 地区：闽台 称呼：扁食 它还可以和if语句联用： win &lt;- 2 score &lt;- str_c( &quot;张三&quot;, if (win == 1) &quot;赢\\n&quot; else &quot;输\\n&quot;, &quot;李四&quot;, if (win == 2) &quot;赢&quot; else &quot;输&quot;, sep = &quot;&quot; ) writeLines(score) ## 张三输 ## 李四赢 5.3.4 使用str_view()来查找特定的字符组合 5.3.5 str_detect() suomi &lt;- &quot;Suomen kieli on uralilaisten kielten itämerensuomalaiseen ryhmään kuuluva kieli.&quot; "],
["factors.html", "5.4 Factors", " 5.4 Factors 5.4.1 基础 有时候，我们的变量是以文字的形式呈现，但是它们不是单纯的文字，而是有大小的差别，或是能以一定顺序排列，比如十二个月份 (Jan, Feb, …)，成绩的“优、良、中、差”，衣服的尺寸 (XS, S, M, XL, …). 假设我们在做客户满意度调查，七位客户的反馈是 满意度_v &lt;- c(&quot;满意&quot;, &quot;非常满意&quot;, &quot;满意&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常不满&quot;, &quot;不满意&quot;) 我们试图用sort()把七个反馈按满意度从小到大排列： sort(满意度_v) ## [1] &quot;不满意&quot; &quot;不满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;非常不满&quot; ## [7] &quot;非常满意&quot; 可见其排序并不是有意义的。（因为默认英语根据’abcde…’排序，中文根据笔画排序） 我们可以把这个vector做成factor，并用参数levels规定排序顺序： # 按照惯例，小的值在前，大的在后；“非常不满”应为满意度最低的值。 满意度_f &lt;- factor(满意度_v, levels = c(&quot;非常不满&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常满意&quot;)) sort(满意度_f) ## [1] 非常不满 不满意 不满意 满意 满意 满意 非常满意 ## Levels: 非常不满 不满意 满意 非常满意 这样排序就是正确的了。 class(满意度_f) # &quot;factor&quot; is.vector(满意度_f) # FALSE 5.4.2 在绘图中的应用 5.4.3 高端操作 "],
["dttm.html", "5.5 日期和时间", " 5.5 日期和时间 日期和时间是一个很令人头疼的话题。不是所有的年都是365天，不是每天都是24小时，不是每分钟都是60秒17。 R自带的日期/时间方法不太好用，因此我们用一个叫做lubridate的package. install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) 5.5.1 ISO标准 日期/时间的ISO标准格式是这样的： now() ## [1] &quot;2019-07-17 17:05:42 CST&quot; 最后三个字母是时区。 5.5.2 创建日期/时间 5.5.2.1 现在的日期/时间 today() ## [1] &quot;2019-07-17&quot; now() ## [1] &quot;2019-07-17 17:05:42 CST&quot; 5.5.2.2 通过字符串转换 date()函数可以把ISO标准格式的日期，从字符串转换成日期的数据类型。 class(&quot;2001-02-01&quot;) ## [1] &quot;character&quot; date(&quot;2001-02-01&quot;); class(date(&quot;2001-02-01&quot;)) ## [1] &quot;2001-02-01&quot; ## [1] &quot;Date&quot; ymd(), mdy(), dmy()这三个函数可以很智能地把各种格式的日期转换成ISO标准的日期。 X &lt;- date(&quot;2001-02-01&quot;) A &lt;- ymd(010201) B &lt;- mdy(&quot;February the 1st, 2001&quot;) C &lt;- dmy(&quot;01/FEB/01&quot;) # 验证A, B, C全部等于X sapply(list(A, B, C), identical, X) ## [1] TRUE TRUE TRUE 如果想加上时间，使用有_h, _hm, _hms后缀的版本的函数： dmy_h(&quot;01-Feb-2001 17&quot;) ## [1] &quot;2001-02-01 17:00:00 UTC&quot; ymd_hms(010201173245) ## [1] &quot;2001-02-01 17:32:45 UTC&quot; 5.5.3 计算 5.5.4 在绘图中的应用 闰年为366天；夏令时开始时的那一天只有23小时，结束时为25小时；地球的自转速度在缓慢下降，因此会有“闰秒”。↩ "],
["python.html", "Chapter 6 与Python的联合使用 ", " Chapter 6 与Python的联合使用 "],
["reticulate.html", "6.1 在R中使用Python: reticulate", " 6.1 在R中使用Python: reticulate "],
["rpy.html", "6.2 在Python中使用R: rpy", " 6.2 在Python中使用R: rpy "],
["beaker.html", "6.3 Beaker Notebook", " 6.3 Beaker Notebook https://decisionstats.com/2015/12/07/decisionstats-interview-scott-draves-beaker-notebook/ Inspired by Jupyter, Beaker Notebook allows you to switch from one language in one code block to another language in another code block in a streamlined way to pass shared objects (data) "],
["References.html", "References", " References "]
]
