[
["index.html", "R与tidyverse——数据分析入门 欢迎", " R与tidyverse——数据分析入门 石天熠 2019-07-29 欢迎 简介 本书为R和tidyverse的入门向教程。教学视频在b站（还没开播，从6月中旬一直跳票到8月初）。附加资源在R-Tutorial-Resources Github仓库。 本书有Gitbook版本 (https://tianyishi2001.github.io/r-and-tidyverse-book/ )和通过XeLaTeX排版的PDF版本。 如果有写得不对的地方，欢迎批判、指正。 Gitbook版本使用说明 左上角的菜单可以选择收起/展开目录，搜索，和外观，字体调整。中文衬线体使用的是思源宋体。 如果你对某一段文字有修改意见，可以选择那段文字，并通过Hypothesis留言（选择“annotate”）。右上角可以展开显示公开的留言。首次使用需要注册。 如果你熟悉Bookdown和Github，可以在此提交pull request. 为什么写本书 在下一个版本中，我会写一个序言，解释我写这本书的原因。 简而言之，是为了实现知识的自由化——我人生的大目标（前提是我还有钱恰饭）——而做的初步探索。这本书并不是我理想中知识自由的世界的产物——事实上，像我写的这种自由获取的教程并不少见——但是我还是有必要亲自体验一下写这类书时遇到的问题，和这类书的局限性。 总之，这本书只是我的一个实验品。相比于其他专业的R教程，可能并没有什么优势。但是，我会对读者负责。如果你对本书的内容有任何意见，我一定会作出回应。 本书的结构 Hadley Wickham写R for Data Science的时候把绘图放在了第一章，随后再讲加减乘除和数据处理，他认为这样可以降低新人被劝退的概率。我虽然很喜欢他的书，但是我是一个比较保守的人，所以我把所有我认为是基础的内容放在了前面。 为了防止劝退，本书的内容分为基础部分和（相对）进阶部分；基础部分的段落中会有“可酌情跳过进阶部分”的提示，以帮助你流畅地看完基础部分。仅阅读基础部分即可学到最重要的知识；如学有余力可阅读进阶部分。 在本书你不会学到： 详细的统计学方法。我本身数学很差，教这个是要谢罪的。 Python (NumPy/SciPy)。在数据挖掘/数据分析领域，Python和R一样是我们的好伙伴，而且它们经常被联合使用。但是本书作为R的入门教程，应当专注于R。 SAS, SPSS, STATA等软件。它们是资本主义的邪恶产物。 版权页 This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. 本作品采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 关于编写本书的技术信息 本书以R Markdown格式 (http://rmarkdown.rstudio.com/ )在RStudio (http://www.rstudio.com/ide/ )中编写。 knitr (http://yihui.name/knitr/ )和pandoc (https://pandoc.org/ )把Rmd文件编译成html和tex， LaTeX 将tex排版为PDF；这一系列操作是使用bookdown (https://bookdown.org )自动完成的。 本书的源码，Gitbook和PDF版本的书保存在https://github.com/TianyiShi2001/r-and-tidyverse-book/ ，其中Gitbook和PDF保存在/docs/目录下，由GitHub Pages生成静态网页，通过https://TianyiShi2001.github.io/r-and-tidyverse-book/ 访问。 编写本书使用的R packages，和排版本书时R的sessionInfo显示如下： utils::sessionInfo(c(&quot;tibble&quot;, &quot;dplyr&quot;, &quot;forcats&quot;, &quot;ggplot2&quot;, &quot;stringr&quot;, &quot;tidyr&quot;, &quot;readr&quot;, &quot;purrr&quot;, &quot;yaml&quot;, &quot;lubridate&quot;, &quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;bookdown&quot;, &quot;doParallel&quot;, &quot;foreach&quot;)) #&gt; R version 3.5.3 (2019-03-11) #&gt; Platform: x86_64-apple-darwin15.6.0 (64-bit) #&gt; Running under: macOS 10.15 #&gt; #&gt; Matrix products: default #&gt; BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib #&gt; LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib #&gt; #&gt; locale: #&gt; [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 #&gt; #&gt; attached base packages: #&gt; character(0) #&gt; #&gt; other attached packages: #&gt; [1] tibble_2.1.3 dplyr_0.8.3 forcats_0.4.0 #&gt; [4] ggplot2_3.2.0 stringr_1.4.0 tidyr_0.8.3 #&gt; [7] readr_1.3.1 purrr_0.3.2 yaml_2.2.0 #&gt; [10] lubridate_1.7.4 rmarkdown_1.13.6 knitr_1.23 #&gt; [13] bookdown_0.11 doParallel_1.0.14 foreach_1.4.4 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] tidyselect_0.2.5 xfun_0.8 haven_2.1.1 lattice_0.20-38 #&gt; [5] colorspace_1.4-1 generics_0.0.2 htmltools_0.3.6 grDevices_3.5.3 #&gt; [9] rlang_0.4.0 pillar_1.4.2 glue_1.3.1 withr_2.1.2 #&gt; [13] tidyverse_1.2.1 modelr_0.1.4 readxl_1.3.1 munsell_0.5.0 #&gt; [17] gtable_0.3.0 cellranger_1.1.0 rvest_0.3.4 codetools_0.2-16 #&gt; [21] evaluate_0.14 parallel_3.5.3 broom_0.5.2 methods_3.5.3 #&gt; [25] Rcpp_1.0.1 scales_1.0.0 backports_1.1.4 jsonlite_1.6 #&gt; [29] stats_3.5.3 datasets_3.5.3 graphics_3.5.3 hms_0.4.2 #&gt; [33] digest_0.6.20 stringi_1.4.3 grid_3.5.3 cli_1.1.0 #&gt; [37] tools_3.5.3 magrittr_1.5 lazyeval_0.2.2 crayon_1.3.4 #&gt; [41] pkgconfig_2.0.2 xml2_1.2.0 utils_3.5.3 assertthat_0.2.1 #&gt; [45] base_3.5.3 httr_1.4.0 rstudioapi_0.10 iterators_1.0.10 #&gt; [49] R6_2.4.0 nlme_3.1-140 compiler_3.5.3 "],
["intro-and-installation.html", "Chapter 1 R与RStudio安装与基础操作", " Chapter 1 R与RStudio安装与基础操作 本章内容速览 第1.1节：对R和RStudio进行概念和功能介绍，并介绍安装方式。 第1.2节：很重要的一节。介绍了常用的帮助和学习资源获取方式。 第1.3节：带你快速熟悉RStudio界面和基本操作。 第1.4节：也很重要。介绍packages（包）的概念和功能，并引导安装本书需要使用的packages. "],
["what-is-R.html", "1.1 什么是R", " 1.1 什么是R R (R Core Team 2019)包含R语言和一个有着强大的统计分析及作图功能的软件系统，由新西兰奥克兰大学的Ross Ihaka和Robert Gentleman共同开发。R语言虽然看起来只能做统计，实际上它麻雀虽小，五脏俱全，编程语言该有的特性它基本都有（甚至支持OOP）。 不要看到编程就害怕。使用R不需要懂编程。R语言最重要的特性之一就是，不懂编程的人可以轻松地用R自带的和和其他人编写的packages，实现99.9%他们想要的功能（主要是数据分析）；而懂编程的人可以轻松地使用编程，在R中实现他们想要的剩余的0.1%的功能。同时，R的编程语言非常简单易学，尤其是对于编程0基础的R使用者。像SAS，STATA这些商业软件，只能实现你95%的需求，且剩下的5%很难解决。 安装了R之后，你可以在其自带的“R”软件中使用（也可以直接在命令行使用），但是那个软件对新手的友好度不如RStudio. RStudio (RStudio Team 2015)是广受欢迎的R语言IDE（集成开发环境），它的一系列功能使得编辑，整理和管理R代码和项目方便很多。 了解更多R的优势，请看第1.1.2节 1.1.1 安装R和RStudio 1.1.1.1 安装R https://cran.r-project.org 前往CRAN，根据自己的操作系统（Linux，MacOS或Windows）选择下载安装R. (Linux用户亦可参考此处) 1.1.1.2 安装RStudio https://www.rstudio.com/products/rstudio/download/ 前往RStudio下载页，选择最左边免费的开源版本，然后选择对应自己的操作系统的版本，下载并安装。 1.1.2 为什么使用R，R与其他统计软件的比较1 （这一小节不影响R的学习进度，可以直接跳过到下一章） SAS，SPSS，Prism，R和Python是数据分析和科研作图常用的软件。 SAS，SPSS和Prism都是收费的，而且不便宜。比如SAS第一年需要10000多美元，随后每年要缴纳几千美元的年费。 R是GNU计划的一部分，因此R是一个自由软件 (Libre software)。它不仅免费，还允许用户自由地学习，运行该软件；拷贝，分发，修改并改进该软件，以帮助其他人。你可以 在GNU官网了解更多。 R比各种商业统计软件功能更强大。没错，免费的R比昂贵的商业软件功能更强大。所有SAS中的功能，都能在R中实现，而很多R中的功能无法在SAS中实现2。 R有巨大的用户社群3，其中有很多热心的使用者/开发者在论坛上解答问题，或是编写免费获取的教程。SAS等软件虽然有客户支持，但是如果你用的是盗版…… R（RStudio）非常稳定。闪退率极低，而且就算闪退了，也完全不会丢失上一次工作中的数据，可以无缝衔接上一次的工作。我经常会创建一两个实验用的R script文件，我不需要把它们命名并保存在我的工作目录，重启RStudio的时候仍然可以使用它们。总之，关闭RStudio的时候，你甚至可以什么都不用保存；关闭，重启，无忧无虑地继续工作。设置Git后体验更佳。 R与其它编程语言/数据库之间有很好的接口。比如dbplyr package帮助你方便地把R和数据库（MySQL, MariaDB, Postgres等等）连接起来，reticulate可以让你在R中使用Python. Python（NumPy和SciPy）是近几年兴起的数据分析处理方案。在数据分析的应用中，R比Python历史更悠久，因此积攒了很多很棒的packages（包）。一般来说，python的强项是数据挖掘，而R的强项是数据分析，它们都是强大的工具。不用担心需要在二者之中做选择，因为rpy, reticulate等packages可以让你在python中使用R，在R中使用python，详情请见第??章。无论你是数据分析零基础，还是有python数据分析的经验，都能从本书中获益。 至于Excel，它的定位原本就是办公（而不是学术）软件，数据分析的严谨性，大数据的处理能力，和功能的拓展非常局限。有五分之一的使用了Excel的遗传学论文，数据都出现了偏差 (Ziemann, Eren, and El-Osta 2016)。对了，Excel和SPSS和其它一些软件绘图的时候，坐标轴和/或图例中的文字竟然不能上下标！ 我也不是说要严禁使用Excel（或者其它可用的工具），而是要清楚各种工具的优势和局限，物尽其用。比如当需要从PDF文件中提取表格数据时，我会把它们复制到Excel（因为兼容性强）；我也会用Excel做一些数据的初步处理，比如删除数量不多的冗余的行和列，重命名变量名等。 虽然R是自由软件，但是我们要记得感激所有位R贡献智慧的奉献者。出于对知识劳动的尊重和，以及保持R的发展壮大，我呼吁有能力出资的使用者在https://www.r-project.org/foundation/donations.html 对R进行捐赠。 References "],
["getting-help.html", "1.2 获取资源与帮助（重要！）", " 1.2 获取资源与帮助（重要！） 这本书可以帮助你快速学会R和tidyverse的最常用和最重要的操作，但这仅仅是冰山一角。当你在做自己的研究的时候，会用到很多这本书中没有讲到的方法，因此学会获取资源和帮助是很重要的。以下列举几个常用的获取R的帮助的网站/方法： 1.2.1 核心/入门资源 1.2.1.1 论坛类（解答实际操作中的问题） 爆栈网 (StackOverflow)是著名计算机技术问答网站（如果你有其他的编程语言基础，一定对它不陌生）。查找问题的时候加上[R]，这样搜索结果就都是与R相关的了（为了进一步缩小搜索范围，可以加上其他的tag，比如[ggplot], [dplyr])。注意，提问和回答的时候话语尽量精简，不要在任何地方出现与问题无关的话（包括客套话如“谢谢”），了解更多请查看其新手向导。 由谢益辉大佬在2006年（竟然比爆栈网更早！）创建的“统计之都”论坛，是做的最好的一个面向R的中文论坛（但是客观地来说活跃度还是没爆栈网高）同样不要忘记读新手指引。 1.2.1.2 Reference类（查找特定的function/package的用法） 直接在R console中执行?+函数名称或者package名或者其它，比如?t.test，可以查看对应函数的帮助文档（documentation）有一些函数/packages/内容名需要加上引号，比如?&quot;+&quot;, ?&quot;if&quot;。有一个相似的方法，??+&quot;内容&quot;可以根据你输入的内容搜索帮助文档，比如??&quot;probability distrubution&quot;。 RDocumentation上有基础R语言和来自CRAN，GitHub和Bioconductor上的近18000个packages的所有的函数的说明和使用例。 有些packages会在官网或github仓库提供使用说明，比如tidyverse 有些packages会提供vignettes，它们类似于使用指南，相比于函数的帮助文档更为详细且更易读。vignette()（无参数）以查看全部可用vignettes. 试试vignette(&quot;Sweave&quot;)。 1.2.1.3 教程和书籍类（用来系统地学习） R for Data Science by Garrett Grolemund &amp; Hadley Wickham. tidyverse的作者写的一本书，较为详细地介绍了tidyverse的用法以及一些更高深的关于编程的内容。（练习题答案） R for Beginners by Emmanuel Paradis及其中文译本 R的官方Manuals. 是一组严谨，全面但略微枯燥的文档，可能不太适合零基础的新手，但是对于精通R有很大的帮助。部分由丁国徽翻译成中文。 RStudio Resources是RStudio的资源区，有关于R和RStudio的高质量教程，还可以下载很多方便实用的Cheat Sheet. R的官方FAQ（在左侧菜单栏中找到“FAQ”） 存储在CRAN上的中文FAQ（注意这不是英文FAQ的翻译，而是一本独立的R入门教程） 1.2.1.4 速查表 (Cheat sheets)（用来贴墙上） R Reference Card 2.0 by Mayy Baggott &amp; Tom Short以及其第一版的中文翻译 RStudio Cheat Sheets包含了RStudio IDE和常用packages的cheat sheets。2019年版的合集在这里。 1.2.2 进阶资源 The R Book by Michael J. Crawley Advanced R by Hadley Wickham及其练习题答案。 CRC的The R Series Springer的Use R! Series。 Venables &amp; Ripley (2002). S Programming. "],
["interface-basics-project.html", "1.3 RStudio界面介绍，基本操作，和创建新项目", " 1.3 RStudio界面介绍，基本操作，和创建新项目 1.3.1 界面 1.3.1.1 概览 1.3.1.2 左下角：Console（控制台） Console是执行代码的地方。试试在里面输入1 + 1并按回车以执行。 1.3.1.3 左上角：Source（源） Source是写代码的地方。请看第1.3.3.3节。 这个位置也是用来查看文件和数据的地方。试试在console中执行View(airquality)或library(help = &quot;stats&quot;). 1.3.1.4 右上角：Environment（环境） Environment 是一个列表，显示了所有当前工作环境中所有的对象，包括变量（“values”和“data”）和自定义的函数（functions），并简要显示了它们对应的值。 History（历史）和 Connections（连接）不太常使用。 1.3.1.5 右下角：Plots（绘图），Help（帮助），Files（文件）和Packages（包） Plots是预览图像的区域。试试在console中执行hist(rnorm(10000)). Help是查看帮助文档的区域。试试在console中执行?hist或?norm. Files是查看文件的区域，默认显示工作目录 (working directory)。 Packages是安装/查看/更新packages（包）的区域。详情请看第1.4章。 1.3.2 执行代码 1.3.2.1 计算和赋值 我本来不想在开篇就写一小节使用较多的术语的文字，但是R中计算和赋值的概念实在太重要了，我不得不把它放在这里。 几乎所有R中的指令可以归为两种。计算 (evaluation)或者赋值 (assignment).4 没有&lt;-符号的为计算，有&lt;-符号的为赋值。 大多数情况下，计算仅仅会产生效果（或是在console输出结果，或是在plot区产生图像，或是在工作目录新建一个pdf文件），赋值会且仅会改变一个对象（变量）的值（包括新建一个对象），并且不会产生其他的效果。5 首先我们来做一个计算。 在console里输入1 + 1，并按回车以执行。你的console会显示： &gt; 1 + 1 [1] 2 其中2是计算结果， [1]是索引，在第2.1.2节有解释。&gt; 1 + 1是input，[1] 2是output. 还是用1 + 1举例，在本书中，对于input和output的展示格式是这样的： 1+1 #&gt; [1] 2 注意input中的&gt;被省略了，这意味着你可以很方便地直接把代码从本书复制到你的console并按回车执行（因为console本身自带了&gt;)。 再执行以下指令（在RStudio中，可以用Alt+- (Mac是 option+-) 这个快捷键打出这个符号。）： x &lt;- 5*5+1 这是一个赋值指令。计算结果不会显示，但是你新建了一个名为x的变量（准确地说，是“对象”），值为5*5+1的计算结果，即26. 你可以执行x来查看x的值： x #&gt; [1] 26 像一个小箭头的赋值符号（&lt;-）的作用是6，首先计算出其右边的指令（必须是一个计算指令；即同一条指令不可以出现两个&lt;-符号），然后把计算结果的值作为一个拷贝赋予给左边的名字，这样就新建了一个对象 (object)。每个对象有一个名称和一个值。7左右是很重要的；绝大多数其他的编程语言，虽然赋值符号是=，但也是从右往左赋值，R使用&lt;-作为赋值符号更形象，避免新手写出像5 = x之类的指令。当然，如果你喜欢，也可以在R中使用=。8 &lt;-用于给任何对象赋值，包括常用的向量 (vector)，列表 (list)，数据框 (dataframe)和函数 (function)。 谨记，赋值符号只是把右边的计算结果作为一个拷贝赋予给左边，而不会做任何其它的事情9。变化的仅仅是左边的变量（对象），右边的计算中所用到的任何变量（对象）不会改变！ 为什么强调是一个拷贝呢？举个例子，我们现在把x的值赋予给y，不出所料，y的值将为26。那么要是我们在这之后重定义x为40，y的值是多少呢？ y &lt;- x x &lt;- 40 y #&gt; [1] 26 还是26（而不是40）。赋值是一次性的，每次被赋值的对象都将成为独立自主的个体。对象y虽然在被赋值的时候需要用到对象x，但是在那之后y和x半毛钱关系都没有了（除非再次赋值），所以x的变化不会影响y，y的变化也不会影响x。 所有的变化，只可能发生在赋值。 1.3.2.2 计算和函数 所有的计算都是通过函数实现的，包括当你输入x然后按回车时。10像+, -这样的运算符也是函数（参见第2.6.1节）。 函数的标志是小（圆）括号，比如sum(6, 7, 8)是求6, 7和8的和；其中sum()是函数，6, 7, 8是（三个参数）。 函数可以嵌套使用，而且很常见。 prod(sqrt(sum(2, 3, 4)), 2, 5) #&gt; [1] 30 最“内部的”函数先运行，然后把计算结果作为它外面的函数的参数。这里，sum(2, 3, 4)得到9, sqrt(9)得到3, prod(3, 2, 5)得到30. 就像小学的时候学的括号运算规则一样。 更多关于函数的知识请参阅第2.6节。 1.3.3 管理代码 1.3.3.1 创建R Project 试着在console里输入（或者复制）以下代码并执行： attach(airquality) plot(Wind, Ozone, main = &quot;Ozone and Wind in New York City&quot;, pch = 20) model &lt;- lm(Ozone ~ Wind, airquality) abline(model, lwd = 2) 可以看到，在plots区，生成了一副漂亮的图。（先别在意每行代码具体的作用，在之后的章节我会一一讲述） 这时，把RStudio关掉，再重新启动，你会发现你的图没了。因此我们需要记录和管理代码。 初学者经常会在console里写代码，或者从别处复制代码，并执行。这对于一次性的计算（比如写统计学作业时用R来算线性回归的参数）很方便，但是如果你想保存你的工作，你需要把它们记录在R script文件里。如果你的工作比较复杂，比如有一个excel表格作为数据源，然后在R中用不同的方法分析，导出图表，这时候你会希望这些文件都集中在一起。你可以使用R Project来管理它们。 左上角File &gt; New Project 点选New Directory &gt; New Project 输入名称和目录并Create Project 1.3.3.2 使用R Project 在创建R project的文件夹中打开.Rproj文件。或者，RStudio启动的时候默认会使用上一次所使用的R project. 随后，你在RStudio中做的所有工作都会被保存到.Rproj所在的这个文件夹（正规的说法是“工作目录” (working directory)）。比如，在console中执行： pdf(&quot;normalDistrubution.pdf&quot;) curve(dnorm(x),-5,5) dev.off() 一个正态分布的图像便以pdf格式保存在了工作目录。你可以在系统的文件管理器中，或是在RStudio右下角File面板中找到。 1.3.3.3 写/保存/运行R script 在console中运行代码，代码得不到保存。代码需保存在R script文件（后缀为.R）里。 Ctrl+Shift+N（Mac是command+shift+N）以创建新R script. 然后就可以写R script. 合理使用换行可以使你的代码更易读。#是注释符号。每行第一个#以及之后的内容不会被执行。之前的例子，可以写成这样： # 读取数据 attach(airquality) # 绘图 plot(Wind, Ozone, # x轴和y轴 main = &quot;Ozone and Wind in New York City&quot;, # 标题 pch = 20) # 使用实心圆点 model &lt;- lm(Ozone ~ Wind, airquality) # 线性回归模型 abline(model, lwd = 2) # 回归线 点击你想执行的语句，按Ctrl+Enter (command+return)以执行那一“句”语句（比如上面的例子中，从plot(Wind...到pch = 20)有三行，但是它是一“句”），然后光标会跳至下一句开头。 Ctrl+Shift+Enter (command+shift+return)以从头到尾执行所有代码。 通过Ctrl（+Shift）+Enter执行代码时，相关代码相当于是从R script中复制到了console并执行。 试试复制并执行以上代码吧。 Ctrl+S (command+S)以保存R script. 保存后会在工作目录找到你新保存的.R文件。重新启动RStudio的时候，便可以打开对应的R script文件以重复/继续之前的工作。 1.3.4 RStudio的额外福利11 {rstudio-fuli} 1.3.4.1 括号/引号自动补齐；换行自动缩进 在RStudio中，除非你故意，否则很难出现括号不完整的错误。当你打出一个左括号/引号 ((, [, {, &quot;, ')时，对应的右括号/引号会自动补齐，同时光标移动到括号/引号的中间。 当你在括号中间换行时，右括号和光标会移动到正确的位置。举个例子，我打出下面这两段代码的时候不需要手动输入任何空格或者TAB来实现正确的缩进： mklog &lt;- function(x){ function(y){ log(y, x) } } x &lt;- tibble(nums = c(1, 2, 3), chars = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), cplx = c(1+5i, 2+3i, 6+8i)) 1.3.4.2 自动完成/建议提示/快速帮助 (autocomplete) 当你在console或者source区输入三个12或更多字母时，R会提示以这三个字母开头的所有对象（不一定是packages里的函数，也可以自定义的向量，列表，函数等等）。 然后，你可以用键盘的“上”，“下”键去选择，然后按回车键完成（或者用鼠标点选）。如果对象是一个函数，会自动帮你补齐括号。 注意，当你选中一个函数时，右边会有一个黄色的方框，提示这个函数的参数名称和参数选项，以及一段简要说明。如果你这时想查看此函数的帮助文档，按F1即可。 通过$符号取子集的时候，R会自动列举所有可用的子集（用于列表和数据框/tibble）。类似地，在package名后输入::准备调用函数时，R会列举该package所有可用函数（见第1.4.3.2节）。 1.3.5 一些实用的快捷键 1.3.5.1 快速插入标题 当一份R script文件写得很长的时候，用注释+横线作为小标题把整个文件分割成很多块可以增强易读性： # foo --------------------------------------------------------------------- print(1) #&gt; [1] 1 # bar --------------------------------------------------------------------- x &lt;- 2 # some other code # blah blah blah 在RStudio中，可以通过Ctrl (command) + shift + R快速插入像上面foo, bar这样的小标题。更棒的是，在source栏左下角，可以根据小标题快速定位： 1.3.6 其他 1.3.6.1 “一句”的概念 一次计算（一个单句）执行且执行一个函数（不包括里面嵌套着的函数）。 当你通过函数名 + (“开启”一次运算时，从这里开始到这个函数所对应的反括号，即)之前的内容，即使再多，都只是这个函数的参数。 当你在R script里敲击Ctrl+Enter时，光标所在的位置的那一句指令将会被执行（无需在那一句的开头，可以在那一句之中的任何位置）；如果那句命令不完整，会在console中用+提示（见下一小节）。 单句与单句之间必须换行，或者用分号（;）连接： sum(1, 9) sum(2, 3) # 和 sum(1, 9); sum(2, 3) # 都是可以的，而 sum(1, 9) sum(2, 3) # 不可以，会出错 在同一行用分号分隔的几句代码会按顺序被一起执行，但是每个单句分别产生一个效果/分别返回一个结果。 sum(1, 9); mean(2, 3); x &lt;- 5; x + 1 #&gt; [1] 10 #&gt; [1] 2 #&gt; [1] 6 我们还可以使用大括号构建复合句。在大括号开头处执行代码，括号里的内容会按顺序执行，但是只会返回最后一步的计算结果。 { sum(1, 9) mean(2, 3) x &lt;- 5 x + 1 } #&gt; [1] 6 复合句在自定义函数和流程控制中经常使用。 1.3.6.2 关于换行 Console 中每个命令开头的&gt;叫做prompt（命令提示符），当它出现在你所编辑的那一行的开头时，按下回车的时候那行的命令才会被执行。有时候它会消失，这时候按esc可以将其恢复。 prompt消失的主要原因是你的代码没有写完，比如括号不完整： &gt; 2+(3+4 这时你按回车，它会显示： &gt; 2+(3+4 + +号是在提示代码没写完整。这时你把括号补上再按回车： &gt; 2+(3+4 + ) [1] 9 便可以完成计算。 准确地说，赋值也是一种计算。赋值符号本身就是一个函数，你可以用&quot;&lt;-&quot;(x, 5)把5赋值给x。↩ 有一些计算不支持赋值。当强行赋值的时候，会产生效果，但赋值的值为NULL，比如x &lt;- pdf()会在工作目录新建一个pdf，并新建了对象x，但x的值为NULL. 有一些计算支持赋值，但是同时也会产生效果，比如hist(rnorm(1000))（以list的形式赋值）。↩ 其实你还可以把这个小箭头反过来，试试5 -&gt; x. 但是不建议这么做。代码易读性会变差。↩ 每个对象还可以有一些（可选的）attributes（属性）。↩ 其实可以用=替代&lt;-作为赋值符号，但是更多的R用户还是采用传统的的&lt;-符号，而=则用于给函数的参数赋值。这种区分可以使代码可读性更强（更容易看出哪些语句是赋值，哪些是计算）。当然，如果你真的非常非常想用=符号，也是可以接受的。↩ 一个特例是environment（环境）的赋值。初学者不需要知道。↩ 查看x的值，我们只需要输入x然后按回车，然后我们在console看到了x的值。这其实也是用函数实现的。当一个指令不是赋值时，R默认会对整个指令使用print()函数。因此，2 + 4等同于print(2 + 4), x等同于print(x). 当一个指令是赋值是，R默认会对右边的整个指令使用invisible()函数，因此，y &lt;- x等同于y &lt;- invisible(x).↩ 一切福利都可以在设置中取消。↩ 可以在设置中，自定义所需输入的最少字母和延迟。默认分别为3个字母和250毫秒。↩ "],
["packages.html", "1.4 安装和使用packages (包)", " 1.4 安装和使用packages (包) 1.4.1 Package是什么，为什么使用它们？ Package是别人写好的在R中运行的程序（以及附带的数据和文档），你可以免费安装和使用它们。 Packages可以增加在基础R语言中没有的功能，可以精简你代码的语句，或是提升使用体验。比如有个叫做tikzDevice的package可以将R中的图表导出成tikz语法的矢量图，方便在LaTeX中使用。本书的编写和排版也是使用R中的一个叫做bookdown的package完成的. 这个课程主要是学习tidyverse这个package， 1.4.2 如何安装packages 首先我们安装tidyverse（很重要，本书接下来的部分都要使用这个package）： install.packages(&quot;tidyverse&quot;) 在console中运行以上代码，R就会从CRAN中下载tidyverse并安装到你电脑上的默认位置。因此安装packages需要网络连接。 如果想安装多个packages，你可以一行一行地安装，或是把多个packages的名字合成一列，同时安装，比如： install.packages(c(&quot;nycflights13&quot;, &quot;gapminder&quot;, &quot;Lahman&quot;) 绝大多数的packages都能用这个方法安装，因为它们是被存储在CRAN上的。Bioconductor packages请看第1.4.4.2节。 1.4.3 如何使用packages 1.4.3.1 加载packages 安装packages后，有两种方法使用它们。以tidyverse为例： library(&#39;tidyverse&#39;) 或 require(&#39;tidyverse&#39;) 两者的效果很大程度上都是一样的，都可以用来读取单个package。它们的不同，以及如何通过一行指令读取多个packages，请参看第1.4.4.1节。 每次重启R的时候，上一次使用的packages都会被清空，所以需要重新读取。因此我们要在R script里面记录此script需要使用的packages（这个特性可以帮助你养成好习惯：当你把你的代码分享给别人的时候，要保证在别人的电脑上也能正常运行，就必须要指明要使用哪些packages）.13 1.4.3.2 使用packages里的内容 刚才加载tidyverse的时候，你也许注意到了这样一条提示： ── Conflicts ─────────────── tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag() masks stats::lag() 这是因为R本来自带了一个叫做stats的package，有俩函数名曰filter()和lag()，而dplyr（tidyverse的一部分）也有同名的俩函数，把原来的覆盖了。所以它提示你，当你使用filter()和lag()时，使用的是dplyr的版本，而不是原来stats里的。 这不意味着stats里的这两个函数就不能用了。要使用他们，用这个格式就好了： stats::filter() 同样的道理也适用于其他的packages. 你可以通过 dplyr::filter() 使用dplyr版本的filter()。虽然这是个好习惯，但是很少人这么做（除非你是开发者）。Python里每使用一次NumPy里的函数都要加上np_的前缀，虽然严谨，但是麻烦。R的一大便利之处就是使用packages里的内容时，不强制要求指定packages的名称。如果函数/对象名称有重叠，以packages的加载顺序决定优先度；最近（即最后）被加载的package里的函数/对象胜出，而其余的要通过packageName::object的形式调取。 1.4.3.3 更新和卸载packages 更新：update.packages()；卸载：remove.packages()；两者皆可在RStudio右下角的Packages区进行操作。 1.4.4 其它 这小节是一些不重要的内容，因此可酌情跳到下一章（第2章）。 1.4.4.1 library()和require的区别；如何使用一行指令读取多个packages require()会返回一个逻辑值。如果package读取成功，会返回TRUE，反之则返回FALSE. library()如果读取试图读取不存在的package，会直接造成错误(error)，而require()不会造成错误，只会产生一个警告(warning). 这意味着require()可以用来同时读取多个packages： lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, character.only = TRUE) 或者更精简一点， lapply(c(&quot;dplyr&quot;,&quot;ggplot2&quot;), require, c = T) 1.4.4.2 安装Bioconductor packages Bioconductor是一系列用于生物信息学的R packages. 截止2019年7月2日，共有1741个可用的bioconductor packages. 它们没有被存储在CRAN上，因此需要用特殊的方法安装。首先，安装一系列Bioconductor的核心packages（可能需要几分钟）： source(&quot;http://bioconductor.org/biocLite.R&quot;) biocLite() 然后，通过biocLite()函数安装其它packages，比如： biocLite(&quot;RforProteomics&quot;) 另一个主要原因是，寻找对象时，R需要搜索所有已加载的packages，而且，packages都被加载在RAM里，因此加载过多的packages会使R显著变慢。（虽然有一些开挂的方法）↩ "],
["-test-intro.html", "1.5 小测 {test-intro}", " 1.5 小测 {test-intro} 1.5.1 基础 {test-intro-basics} 计算。 z`等于多少？为什么？ z &lt;- { x &lt;- 6 y &lt;- 7 x + y x &lt;- 10 x - y x * y } 下面两行代码的运算结果分别是什么？z的值分别是什么？ z &lt;- x &lt;- 0; x + 1 z &lt;- {x &lt;- 0; x + 1} 1.5.2 进阶 {test-intro-advanced} 建议读完下一章再来做这些题。 计算。 rep( seq(10, 100, 10), rep(1:4, c(2, 1, 4, 3)) ) rep({ x &lt;- 5 x &lt;- x+5 x }, 3) greet &lt;- function(t) { print(if(t == 1) &quot;早上好&quot; else if(t == 2) &quot;下午好&quot; else if(t == 3) &quot;晚上好&quot;) } t = 1; greet(t) t = 3; greet(t) "],
["vectors-logicals-and-functions.html", "Chapter 2 向量，逻辑，循环和函数", " Chapter 2 向量，逻辑，循环和函数 本章内容速览 第2.1节介绍了R中向量的概念，使用方法和优越性。 2.1.1：向量的创建（赋值）和合并 2.1.2：向量的索引（indexing）和取子集（subsetting） 2.1.3：生成有序数列（连续整数，重复数/重复向量， 2.1.4：向量的其它操作 2.1.5：向量的优越性——向量化计算概念基础 第2.2节介绍了R中的数据/对象类型 2.2.1：如何查看数据/对象的类型；最基础的5种（atomic vector所存储的）数据类型；其它常用数据/对象类型 2.2.2：数据类型详解；更多的数据类型 第2.3节介绍了R中的数学规则 2.3.1：数的表达；整数，浮点数，科学计数法 2.3.2：基础的数学运算 2.3.3：基础的统计学计算，包括t分布，t检验，卡方检验 第2.4节介绍了R中逻辑值(TRUE, FALSE, NA)的概念和玩法。 第2.6节介绍了R中的函数的定义和使用。 第2.7节介绍了R中列表 (list)的性质和使用方法。 第2.8节介绍了R中矩阵 (matrix)和数组 (array)的性质和使用方法。 注意，R中的变量名/自定义函数名不能以数字和特殊符号开头，中间只能使用&quot;_“和”.&quot;作为特殊符号14 如果一定要违反规则，可以使用转义符号\\``，比如可以``4foo%b=a+r` &lt;- 50 ``↩ "],
["vector-section.html", "2.1 向量的概念，操作和优越性", " 2.1 向量的概念，操作和优越性 R使用各种类型的向量 (vector)来存储单一类型的数据。 2.1.1 创建向量（赋值） 单元素的向量，可以直接像这样赋值： x &lt;- 2 x #&gt; [1] 2 要创建一个多元素的向量，需要用到c() (concatenate)函数： nums &lt;- c(1,45,78) cities &lt;- c(&quot;Zürich&quot;, &quot;上海&quot;, &quot;Tehrān&quot;) nums #&gt; [1] 1 45 78 cities #&gt; [1] &quot;Zürich&quot; &quot;上海&quot; &quot;Tehrān&quot; 通过length()函数，可以查看向量的长度。 length(nums) #&gt; [1] 3 #如果无后续使用，没必要赋值一个变量；c(...)的计算结果就是一个向量，并直接传给`length()`函数 length(c(&quot;Guten Morgen&quot;)) #&gt; [1] 1 （每个被引号包围的一串字符，都只算做一个元素，因此长度为1；多元素的向量请看第2.1.1节） 还是通过c()函数，可以把多个向量拼接成一个大向量： cities_1 &lt;- c(&quot;Zürich&quot;, &quot;上海&quot;, &quot;Tehrān&quot;) cities_2 &lt;- c(&quot;大阪&quot;, &quot;Poznań&quot;, &quot;Cairo&quot;) cities &lt;- c(cities_1, cities_2, c(&quot;Jyväskylä&quot;, &quot;邯郸&quot;, &quot;札幌่&quot;)) cities #&gt; [1] &quot;Zürich&quot; &quot;上海&quot; &quot;Tehrān&quot; &quot;大阪&quot; &quot;Poznań&quot; &quot;Cairo&quot; #&gt; [7] &quot;Jyväskylä&quot; &quot;邯郸&quot; &quot;札幌่&quot; 2.1.2 索引/取子集/子集重新赋值 (indexing/subsetting) 索引 (index)就是一个元素在向量中的位置。R是从1开始索引的，即索引为1的元素是第一个元素（因此用熟了Python和C可能会有些不适应）。在向量后方使用方括号进行取子集运算（即抓取索引为对应数字的元素）。 x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;) x[3] #&gt; [1] &quot;three&quot; 可以在方括号中使用另一个向量抓取多个元素： x[c(2,5,9)] # 第2个，第5个，第9个元素 #&gt; [1] &quot;two&quot; &quot;five&quot; &quot;nine&quot; 我们可以重新赋值子集： x[c(2,5,9)] &lt;- c(&quot;二&quot;, &quot;五&quot;, &quot;九&quot;) x #&gt; [1] &quot;one&quot; &quot;二&quot; &quot;three&quot; &quot;four&quot; &quot;五&quot; &quot;six&quot; &quot;seven&quot; &quot;eight&quot; &quot;九&quot; 经常，我们会抓取几个连续的元素。如果想知道方法，请继续往下看。 2.1.3 生成器 有时候我们需要其元素按一定规律排列的向量，这时，相对于一个个手动输入，有更方便的方法： 2.1.3.1 连续整数 1:10 #从左边的数（包含）到右边的数（包含），即1:10 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 这时，你应该会有个大胆的想法： x[3:6] #&gt; [1] &quot;three&quot; &quot;four&quot; &quot;五&quot; &quot;six&quot; 没错就是这么用的，而且极为常用。 当元素比较多的时候： y &lt;- 7:103 y #&gt; [1] 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #&gt; [18] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #&gt; [35] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #&gt; [52] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #&gt; [69] 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #&gt; [86] 92 93 94 95 96 97 98 99 100 101 102 103 注意到了左边方括号中的数字了吗？它们正是所对应的那一行第一个元素的索引。 下面的内容可能有点偏，可以酌情从这里跳到第2.1.5节。 2.1.3.2 复读机rep() rep(6, 8) # 把6重复8遍；或rep(6, times = 8) #&gt; [1] 6 6 6 6 6 6 6 6 rep(c(0, 7, 6, 1), 4) # 把(0, 7, 6, 1)重复4遍 #&gt; [1] 0 7 6 1 0 7 6 1 0 7 6 1 0 7 6 1 rep(c(0, 7, 6, 1), each = 4) # 把0, 7, 6, 1各重复4遍 #&gt; [1] 0 0 0 0 7 7 7 7 6 6 6 6 1 1 1 1 rep(c(0, 7, 6, 1), c(1, 2, 3, 4)) # 把0, 7, 6, 1分别重复1, 2, 3, 4遍 #&gt; [1] 0 7 7 6 6 6 1 1 1 1 想一想，rep(8:15, rep(1:5, rep(1:2, 2:3)))的计算结果是什么？ 2.1.3.3 等差数列: seq() 公差确定时： seq(0, 15, 2.5) # 其实是`seq(from = 0, to = 50, by = 5)`的简写 #&gt; [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 长度确定时： seq(0, 50, length.out = 11) # 其实是`seq(from = 0, to = 50, length.out = 11)`的简写 #&gt; [1] 0 5 10 15 20 25 30 35 40 45 50 2.1.3.4 随机数： 连续型均匀分布随机数用runif(n, min, max)，n是数量，min是最小值，max是最大值。默认min为0，max为1。 x_unif &lt;- runif(100000, 40, 60) # 生成100000个40到60之间，连续均匀分布的的随机数 hist(x_unif) # 画直方图 正态分布随机数用rnorm(n, mean, sd), 三个参数分别为数量，平均值，标准差。默认mean为0，sd为1。 x_norm &lt;- rnorm(100000, 250, 20) # 按照平均值为250，标准差为20的正态分布的概率密度函数生成100000个随机数 hist(x_norm) # 画直方图 此外，还有rlnorm(), rpois(), rexp()等函数。?stats::distributions中介绍了R中自带的分布，其中大部分都有对应的随机数生成器。 2.1.4 向量的其他操作 2.1.4.1 创建长度为0的向量 使用循环的时候，经常需要初始化一个长度为0的向量（见第2.5节 有两种方法实现： x &lt;- vector(&quot;numeric&quot;) # 或`vector(&quot;integer&quot;)`, `vector(&quot;character&quot;)`等 class(x) #&gt; [1] &quot;numeric&quot; 或者： x &lt;- integer(0) # 或 x &lt;- integer() # 或`character(0)`, `numeric(0)`等 class(x) #&gt; [1] &quot;integer&quot; 其中后面这种方法亦可用于创建长度为\\(n\\)的向量，把0替换成你想要的长度即可。 2.1.4.2 sort(), rank()和order() x &lt;- c(2, 5, 3, 6, 10, 9, 7, 8, 1, 4) sort(x) rank(x) order(x) rev(sort(x)) # 为方便同框展示，我用的代码是 list(x = x), `sort(x)` = sort(x), `rank(x)` = rank(x), `order(x)` = order(x), `rev(sort(x))` = rev(sort(x))) #&gt; $x #&gt; [1] -10 5 -89 999 84 #&gt; #&gt; $`sort(x)` #&gt; [1] -89 -10 5 84 999 #&gt; #&gt; $`rank(x)` #&gt; [1] 2 3 1 5 4 #&gt; #&gt; $`order(x)` #&gt; [1] 3 1 2 5 4 #&gt; #&gt; $`rev(sort(x))` #&gt; [1] 999 84 5 -10 -89 sort()很好理解，就是把原向量的元素从小到大重新排列。如果要从小到大：rev(sort(x)). rank()是原向量各个元素的（从小到大的）排名。（-10是第2名，5是第3名，-89是第1名，以此类推） order()是一个原向量索引的排序，使得x[order(x)] = sort(x)，即x[order(x)] = x[c(3, 1, 2, 5, 4)] = c(-89, -10, 5, 84, 999) = sort(x) 至于文字向量，英文按a, b, c, d, e, ...排列，中文按笔画排列。 2.1.4.3 元素的命名 scores &lt;- c(ochem = 79, math = 66, mcb = 64, blc = 75, bpc = 72) scores #&gt; ochem math mcb blc bpc #&gt; 79 66 64 75 72 然后便可以额外地用名字抓取元素： scores[c(&quot;math&quot;, &quot;bpc&quot;)] == scores[c(2, 5)] #&gt; math bpc #&gt; TRUE TRUE 2.1.5 R向量的优越性 R中的向量（矩阵和数列也是）的各种计算默认都是逐元素 (elementwise)的。比如： x &lt;- c(4, 9, 25) y &lt;- c(8, 6, 3) x + y #&gt; [1] 12 15 28 x * y # 在matlab中这样乘是不行的，要用`.*`，除法也是 #&gt; [1] 32 54 75 sqrt(x) #&gt; [1] 2 3 5 拥有这种特性的计算也被称为向量化计算 (vectorized computation). 相比于常用的编程语言，向量化计算省去了for循环，计算效率得到极大的提升；相比于matlab的默认矩阵乘法，逐元素乘法在数据处理中更有用。 若想更多地了解向量化计算（比如如何把for循环需要39秒的运算压缩到0.001秒），请看第2.5.4节。 "],
["data-types.html", "2.2 数据/对象类型 (Data/Object Types)", " 2.2 数据/对象类型 (Data/Object Types) 2.2.1 基础的数据/对象类型 2.2.1.1 向量所存储的数据类型 向量所存储的的数据类型有5种： 类型 含义与说明 例子 numeric 浮点数向量 3, 0.5, sqrt(2), NaN, Inf integer 整数向量 3L, 100L character 字符向量；需被引号包围 &quot;1&quot;, &quot;$&quot;, &quot;你好&quot; logical 逻辑向量 TRUE, FALSE, NA complex 复数向量 3+5i, 1i, 1+0i 一个向量的所有元素必须属于同一种类型。如果尝试把不同类型的元素合并成一个向量，其中一些元素的类型会被强制转换 (coerced)。你可以试试c(2, &quot;a&quot;), c(2+5i, 4), c(TRUE, 1+9i)和c(TRUE, 1+9i, &quot;a&quot;)，但是实际操作的时候尽量不要这么做。 2.2.1.2 关于数据类型的简单操作 通过class()函数，可以查看数据/对象的类型。 class(6) # 6是一个（浮点）数，应为&quot;numeric&quot; #&gt; [1] &quot;numeric&quot; 通过is.XXX()函数，可以得到一个逻辑值，指明此数据/对象是否属于某个类型，TRUE为是，FALSE为否。比如： is.numeric(6) #&gt; [1] TRUE is.character(&quot;6&quot;) #&gt; [1] TRUE 通过as.XXX()函数，可以把数据/对象强行转换成另一种类型，比如： as.integer(c(TRUE, FALSE)) #&gt; [1] 1 0 as.character(c(23, 90)) #&gt; [1] &quot;23&quot; &quot;90&quot; 2.2.1.3 NA, Inf, NaN和NULL NA为缺损值，意思是该元素所代表的数值丢失/不确定/不可用。举个例子，当我们统计学生的200m跑成绩时，有一些学生因为身体不适未能参与测试，这时他们的成绩应被记为NA： time_in_sec &lt;- c(29.37, 28.66, 31.32, NA, 27.91, NA) 之前说过，一个向量中，所有的元素都是同一类型的。的确，这里的NA的类型是numeric: class(time_in_sec[4]) #&gt; [1] &quot;numeric&quot; 同理，character向量里的NA，类型也是character，其他类型也是一样的道理。如果只是单个的NA, 它的类型是logical: y &lt;- c(&quot;a&quot;, &quot;b&quot;, NA) class(y[3]) #&gt; [1] &quot;character&quot; class(NA) #&gt; [1] &quot;logical&quot; Inf（无限）NaN（非数）的概念，以及作为numeric的NA的数学计算在第2.3.2.4小节讨论。 作为logical的NA的逻辑运算在第2.4小节讨论。 NULL是“无”。它几乎一无是处，因此在此不作更多讨论。学有余力者可以自己去了解。 2.2.1.4 其它的数据/对象类型 Dataframe/tibble 是R中存储复杂（多变量）数据的规范格式，从第3章开始将一直占据我们话题的中心。 因子 (factor)有很多向量的特性，尤其是能在dataframe/tibble中作为变量，但是它并不是向量；因子的详细内容在第5.4节。 函数 (function)。我们刚才用c()来创建向量，它就是一个函数：class(c)；函数的详细内容在第2.6节。 list类似于向量，但是一个list可以包含不同类型的元素。性质和使用方法也和向量大相径庭。详细内容在第2.7节，算是较为进阶的内容。 矩阵 (matrix)和数组 (array)可以算作是二维和多维的向量，同样只能存储一种类型的数据，详细内容在第2.8节，同样是较为进阶的内容。 2.2.2 数据类型（严谨版） 可以酌情跳到第2.3节。 本小节内容没完成，请跳到第2.3节。 2.2.2.1 class, type, mode和storage mode 其实class根本不是基础的数据类型。学过编程的应该猜到了，此class类似于OOP里的“类”，是“高层”的类型。你可以随意篡改class： x &lt;- c(&quot;Joe&quot;, &quot;Lynne&quot;, &quot;Pat&quot;) class(x) # 本应为&quot;character&quot; #&gt; [1] &quot;character&quot; class(x) &lt;- c(&quot;high_school&quot;, &quot;student&quot;) # 篡改 class(x) # 新class #&gt; [1] &quot;high_school&quot; &quot;student&quot; 用typeof(), mode(), storage.mode()所获取到的三种属性是不可篡改的“底层”类型。 以下是五种atomic vectors用四种方式获取到的结果： 对象 例子 typeof() mode() storage.mode() class() 浮点数 1, NaN, Inf double numeric double numeric 整数 1L integer numeric integer integer 复数 0+1i complex complex complex complex 字符串 &quot;a&quot; character character character character 逻辑值 TRUE logical logical logical logical 其中浮点数和整数的“类型”名称有一些出入。is.XX()系列有三个用于实数的函数： is.numeric()用于判断对象是否是实数，即1和1L的判断结果都为TRUE is.double()用于判断对象是否是浮点数，即1为TRUE, 1L为FALSE is.integer()用于判断对象是否是整数，即1为FALSE, 1L为TRUE 对于矩阵和数列，用typeof(), mode(), storage.mode()所得到的结果与对应的atomic vectors得到的结果一致15。而用class()会得到matrix/array. x &lt;- matrix(c(TRUE, FALSE, FALSE, TRUE), ncol = 2) typeof(x); class(x) #&gt; [1] &quot;logical&quot; #&gt; [1] &quot;matrix&quot; 以下是其它数据类型用四种方式获取到的结果： 对象 例子 typeof() mode() storage.mode() class() 基础函数16 sum, ^ buitin function function function 闭包（包括自定义函数） mean, function(x) 2*x closure function function function 流程控制关键字17 if, while, break special function function function 因子 (factor) factor(“a”) 列表 (list) list(“a”, 2) list list list list 数据框 (dataframe) data.frame(x = 1) list list list data.frame 日期和时间是一种特殊的数据格式。它们被存储在向量中，可以拥有维度（即，可以做成矩阵和数列）。它们的属性展示如下： 对象 例子 typeof() mode() storage.mode() class() 国际标准格式的日期+时间 as.POSIXct(&quot;2018-01-02 12:23:56&quot;) double numeric double POSIXt 日期 as.date(“2018-01-02”) double numeric double date 矩阵和数列和atomic vector一样，都只能存储一种形式的数据；本质上，它们就是多维的向量。↩ 若是二元运算符，要用typeof(`+`)的形式。自定义的二元运算符和流程控制关键字同理。↩ 若是二元运算符，要用typeof(`+`)的形式。自定义的二元运算符和流程控制关键字同理。↩ "],
["math.html", "2.3 数学表达和运算", " 2.3 数学表达和运算 2.3.1 数的表达 2.3.1.1 浮点数 除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其class为numeric。 class(3) #&gt; [1] &quot;numeric&quot; 这会导致一些有趣的现象，比如\\((\\sqrt{3})^2 \\neq 3\\)：（强迫症患者浑身难受） sqrt(3)^2-3 #&gt; [1] -4.44e-16 浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位；只有当两个非常，非常大且数值相近对数字相减才会出现较大的误差）。 2.3.1.2 科学计数法 在R中可以使用科学计数法(AeB\\(= A \\times 10^B\\))，比如： 3.1e5 #&gt; [1] 310000 -1.2e-4+1.1e-5 #&gt; [1] -0.000109 2.3.1.3 整数 整数的class为integer。有两种常见的方法创建整数： 1）在数后面加上L； class(2) #&gt; [1] &quot;numeric&quot; class(2L) #&gt; [1] &quot;integer&quot; 2）创建数列 1:10 #公差为1的整数向量生成器，包含最小值和最大值 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 class(1:10) #&gt; [1] &quot;integer&quot; seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数 #&gt; [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5,50,5)) #因此产生的是一个浮点数向量 #&gt; [1] &quot;numeric&quot; seq(5L,50L,5L) #可以强制生成整数 #&gt; [1] 5 10 15 20 25 30 35 40 45 50 class(seq(5L,50L,5L)) #是整数没错 #&gt; [1] &quot;integer&quot; 整数最常见的用处是indexing（索引）。 2.3.1.3.1 整数变成浮点数的情况 这一小段讲的比较细，请酌情直接跳到下一节（2.3.2）。 整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(factorial)也是，即便现实中不管怎么阶乘都不可能得到非整数）： class(2L+1L) #&gt; [1] &quot;integer&quot; class(2L-1L) #&gt; [1] &quot;integer&quot; class(2L*3L) #&gt; [1] &quot;integer&quot; class(17L%/%3L) #&gt; [1] &quot;integer&quot; class(17L%%3L) #&gt; [1] &quot;integer&quot; class(1000L/1L) #&gt; [1] &quot;numeric&quot; class(3L^4L) #&gt; [1] &quot;numeric&quot; class(sqrt(4L)) #&gt; [1] &quot;numeric&quot; class(log(exp(5L))) #&gt; [1] &quot;numeric&quot; class(factorial(5L)) #&gt; [1] &quot;numeric&quot; 整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。 2.3.2 运算 2.3.2.1 二元运算符号 R中常用的binary operators（二元运算符）有： 符号 描述 + 加 - 减 * 乘 / 除以 ^或** 乘幂 %/% 求整数商，比如7%%3\\(=2\\) %% 求余数，比如7%%3\\(=1\\) 其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（见本章小测）。 2.3.2.2 \\(e^x\\)和\\(\\log_x{y}\\) exp(x)便是运算\\(e^x\\)。如果想要\\(e=2.71828...\\)这个数： exp(1) #&gt; [1] 2.72 log(x, base=y)便是运算\\(\\log_y{x}\\)，可以简写成log(x,y)（简写需要注意前后顺序，第2.6.2有解释）。 默认底数为\\(e\\)： log(exp(5)) #&gt; [1] 5 有以10和2为底的快捷函数, log10()和log2() log10(1000) #&gt; [1] 3 log2(128) #&gt; [1] 7 2.3.2.3 近似数（取整，取小数位，取有效数字） 取有效数字用signif()函数；第一个参数是对象，第二个参数是保留的位数；若保留的位数未指定，默认为6. signif(12.3456789, 4) #&gt; [1] 12.3 当对象的有效数字小于你想保留的有效数字位数时，它不会让你乱来（下面round()函数也类似）： signif(12.3, 8) #&gt; [1] 12.3 保留小数位用round()函数。 round(12.3456789, 3) # 保留3个小数位 #&gt; [1] 12.3 若不指定保留多少位，默认为0，即四舍五入地取整： round(13.5) #&gt; [1] 14 此外，还有三种取整函数：floor(), ceiling()和trunc() floor(5.6) # = 5 # “地板”；比x小的最近的整数 ceiling(5.4) # = 6 # “天花板”；比x大的最近的整数 floor(-5.6) # = -6 # 不是-5，因为-6是比-5.6小的最近的整数 ceiling(-5.4) # = -5 # 不是-6；因为-5是比x大的最近的整数 trunc(-5.6) # = -5 # 你可能需要这个；它无视了小数点后面的位数 注意，所有取整函数给出的的结果都并不是整数！ class(ceiling(7.4)) #&gt; [1] &quot;numeric&quot; 虽然浮点数使用起来真没啥不方便的，但是如果你一定需要的话，可以用as.integer()函数把它转换成真·整数。 2.3.2.4 NA, Inf, NaN相关 我不知道张三有几个苹果，我也不知道李四有几个苹果；你问我张三和李四共有几个苹果： NA + NA #&gt; [1] NA 鬼才知道咧！ 类似地，NA - NA, NA/NA, NA*NA, log(NA)都等于NA NA^0等于几？别上当！R的开发者们可没有忘记\\(\\forall x\\in \\mathbb{R:x^0 = 1}\\) Inf, 即\\(\\infty\\), 表示很大的数字（准确地说，大于等于\\(2^{1024}\\)即\\(1.797693\\times10^{308}\\)的数字）它还有个负值，-Inf. 以下是几个结果为Inf的例子： exp(1000) # = Inf; 这个很明显 1/0 # = Inf; 0被当作很小的数 0^(-1) # = 1/(0^1) = 1/0 = Inf log(0) # = -Inf; 0又被当作很小的数 NaN是“非数” (not a number). 运算结果为NaN的例子有： 0/0 # NaN log(-1) # = NaN 0^(3+8i) # = NaN + NaNi Inf-Inf; Inf/Inf # = NaN -NaN # = NaN Inf和NaN的类型是numeric（浮点数）. class(Inf); class(NaN) #&gt; [1] &quot;numeric&quot; #&gt; [1] &quot;numeric&quot; is.na()会判定NaN为真： is.na(NaN) #&gt; [1] TRUE 2.3.2.5 R中自带的常用数学函数概览 函数 描述 exp(x) \\(e^x\\) log(x,y) \\(\\log_yx\\) log(x) \\(\\ln(x)\\) sqrt(x) \\(\\sqrt{x}\\) factorial(x) \\(x!=x\\times(x-1)\\times(x-2)\\ldots\\times2\\times1\\) choose(n,k) \\(\\binom{n}{k}=\\frac{n!}{k!(n-k)!}\\)（二项式系数） gamma(z) \\(\\Gamma(z)=\\int_0^\\infty x^{z-1}e^{-x}dx\\)（伽马函数） lgamma(z) \\(\\ln(\\Gamma(z))\\) floor(x), ceiling(x), trunc(x), 取整；见上一小节。 round(x, digits = n) 四舍五入，保留n个小数位，n默认为0 signif(x,digits = n) 四舍五入，保留n个有效数字，n默认为6） sin(x), cos(x), tan(x) 三角函数 asin(x), acos(x), atan(x) 反三角函数 sinh(x), cosh(x), tanh(x) 双曲函数 abs(x) \\(|x|\\)（取绝对值） sum(...), prod(...) 所有元素相加之和/相乘之积 2.3.3 简易的统计学计算 本节简要解释了R中的基础统计学函数，t分布，t检验和\\(\\chi^2\\)检验。统计学方法并不是本书的重点，因此可以酌情跳到下一节。 2.3.3.1 基础 中位数median(); 平均数mean(); 方差var(); 标准差sd(). 2.3.3.2 t分布 众所周知，t分布长这样： 阴影面积为\\(P(t&lt;T)\\)，虚线对应的\\(t\\)为\\(T\\). qt()可以把\\(P(t≤T)\\)的值转化成\\(T\\),pt()则相反。 假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为\\(95\\%\\)，即\\(\\alpha=0.05\\)，degrees of freedom(自由度)为\\(12\\)，那么怎么算\\(t^*\\)呢？ qt(0.975, df = 12) #&gt; [1] 2.18 为什么是\\(0.975\\)？因为你要把\\(0.05\\)分到左右两边，所对应的t*就等同于t分布中，\\(P(t ≤ T) = 0.975\\)时T的值。 再举一个例子，你在做t检验，双尾的，算出来\\(t=1.345\\)，自由度是\\(15\\)，那么\\(p\\)值怎么算呢？ p &lt;- (1-(pt(2.2, df = 15)))*2 p #&gt; [1] 0.0439 其中pt(2.2, df = 15)算出阴影面积（\\(P(t≤T)\\)的值），1减去它再乘以2就是对应的双尾t检验的\\(p\\)值。 2.3.3.3 z分布 没有z分布专门的函数。可以直接用t分布代替，把df调到很大（比如999999）就行了。比如我们试一下\\(95\\%\\)置信区间所对应的\\(z*\\)： qt(0.975,9999999) #&gt; [1] 1.96 （果然是\\(1.96\\)） 2.3.3.4 t检验 t检验分为以下几种： One sample t test （单样本） paired t test（配对） Two sample…（双样本） Unequal variance (Welch) t test（不等方差） Equal variance t test（等方差） 在R中做t检验，很简单，以上这些t检验，都是用t.test 这个函数去完成。 以单样本为例： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: x #&gt; t = -2, df = 10, p-value = 0.07 #&gt; alternative hypothesis: true mean is not equal to 2.31 #&gt; 95 percent confidence interval: #&gt; 2.26 2.31 #&gt; sample estimates: #&gt; mean of x #&gt; 2.28 可以看到\\(p=0.06766\\)。 R的默认是双尾检验，你也可以设置成单尾的： x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) t.test(x, mu = 2.31, alternative = &quot;less&quot;) # 检验是否*less* than μ #&gt; #&gt; One Sample t-test #&gt; #&gt; data: x #&gt; t = -2, df = 10, p-value = 0.03 #&gt; alternative hypothesis: true mean is less than 2.31 #&gt; 95 percent confidence interval: #&gt; -Inf 2.31 #&gt; sample estimates: #&gt; mean of x #&gt; 2.28 \\(p\\)值瞬间减半。 双样本/配对: x &lt;- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32) y &lt;- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22) t.test(x, y) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: x and y #&gt; t = -2, df = 10, p-value = 0.1 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -0.1846 0.0292 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 2.28 2.36 R的默认是non-paired, unequal variance，你可以通过增加paired = TRUE，var.equal = TRUE这两个参数来改变它。 t.test(x, y, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: x and y #&gt; t = -1, df = 10, p-value = 0.2 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -0.1925 0.0372 #&gt; sample estimates: #&gt; mean of the differences #&gt; -0.0777 2.3.3.5 \\(\\chi^2\\) 检验 \\(\\chi^2\\)检验有两种，goodness of fit test（适配度检验）和contigency table test/test of independence（列联表分析/独立性检验）。都是用chisq.test()函数去完成。 2.3.3.5.1 适配度检验 假设我们制造了一个有问题的骰子，使1至6朝上的概率分别为： expected_probs &lt;- c(0.05, 0.1, 0.15, 0.2, 0.2, 0.3) 然后我们投掷了100次，实际1至6朝上的次数分别为： observed_vals &lt;- c(6, 9, 14, 24, 18, 29) 通过chisq.test()，检验实际的1至6朝上概率是否与预期有偏差： chisq.test(observed_vals, p = expected_probs) # 参数p是指概率 #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: observed_vals #&gt; X-squared = 1, df = 5, p-value = 0.9 p值很大（远大于0.05），因此结论是骰子各面朝上的概率符合预期。 如果不指定p参数，默认为检测是否所有值相等（即骰子的所有面朝上的概率相等）： chisq.test(observed_vals) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: observed_vals #&gt; X-squared = 20, df = 5, p-value = 3e-04 这时p值小于0.05. 得出“骰子各面朝上的概率不等”的结论。 2.3.3.5.2 列联表分析/独立性检验 假设我们有一组不同年级的学生参加社团的人数数据： (社团参与 &lt;- matrix(c(28,36,40,40,32,33,38,29,36), nrow = 3, dimnames = list(c(&quot;一年级&quot;, &quot;二年级&quot;, &quot;三年级&quot;), c(&quot;棒球&quot;, &quot;足球&quot;, &quot;网球&quot;)))) #&gt; 棒球 足球 网球 #&gt; 一年级 28 40 38 #&gt; 二年级 36 32 29 #&gt; 三年级 40 33 36 我们想知道社团的参与，与所在年级是否是独立事件： chisq.test(社团参与) #&gt; #&gt; Pearson&#39;s Chi-squared test #&gt; #&gt; data: 社团参与 #&gt; X-squared = 4, df = 4, p-value = 0.4 p值不小于0.05，无法拒绝“社团的参与，与所在年级是独立事件”的虚无假设。 彩蛋：用R代码实现卡方分布的概率密度函数的图像： #其实还可以更精简，但是为了易读性不得不牺牲一点精简度。 Z &lt;- matrix(rep(rnorm(1000000), 6), nrow = 6)^2 X &lt;- Z^2 Q &lt;- matrix(nrow = 6, ncol = 1000000) for (i in (1+1):6) { Q[1,] = Z[1,] Q[i,] = Q[(i-1),] + Z[i,] } plot(NULL, xlim=c(0.23,6), ylim = c(0,1), main = expression(paste(&#39;X ~ &#39;, chi^&#39;2&#39;, &#39;(k)&#39;)), xlab = &quot;x&quot;, ylab= expression(f[k]*&#39;(x)&#39;) ) colors &lt;- c(&#39;blue&#39;, &#39;black&#39;, &#39;red&#39;, &#39;green&#39;, &#39;gray&#39;, &#39;orange&#39;) for (i in 1:6) { lines(density(Q[i,]), col=colors[i], lwd=2) } legend(&#39;topright&#39;,c(&#39;k=1&#39;,&#39;k=2&#39;,&#39;k=3&#39;,&#39;k=4&#39;,&#39;k=5&#39;,&#39;k=6&#39;), fill = colors) 2.3.3.5.3 其他 R自带的检验还有Box.test(), PP.test(), ansari.test(), bartlett.test(), wilcox.test等共31种。查看帮助文件或利用网络资源以了解更多。 "],
["logical-operation.html", "2.4 逻辑", " 2.4 逻辑 2.4.1 逻辑值 {logical-values} 逻辑值有三个。TRUE, FALSE和NA. class(c(TRUE,FALSE,NA)) #&gt; [1] &quot;logical&quot; TRUE为真，FALSE为假，NA为未知（即真假难辨）。 2.4.2 关系运算符和简单的逻辑运算 R中常用的关系运算符有： 符号 描述 == equal to（等于） != equal to（不等于） &lt; less than（小于） &gt; more than（大于） &lt;= less than or equal to（小于等于） &gt;= more than or equal to（大于等于） 这些关系运算符只能用于(atomic) vectors, 不能用于其他类型的R对象；indentical()函数可以用于所有类型的对象，用来确认两者是否完全一致。 使用关系运算符进行计算，会产生逻辑值作为结果。比如： x &lt;- 5 x != 3 #x等于5，所以“x不等于3”为真 #&gt; [1] TRUE 有一些其他的运算符或函数也会返回逻辑值，比如 7 %in% c(1,4,5,6,7) #&gt; [1] TRUE 顾名思义，这个运算符是用来检测一个元素是否在另一个向量中。其它类型的运算符，我在需要用到的时候再讲。 有很多种运算会以NA作为计算结果，在此不一一列举。最重要的一个是： NA == NA #&gt; [1] NA 这看起来像是一个bug，然而仔细想想才发现这个设计很巧妙。假设你问我是否知道我的一些朋友写完了暑假作业。我说我不知道张三是否写完了，也不知道李四是否写完了。你再问我“张三和李四的作业完成情况是一样的吗”？鬼才知道咧！ 这意味着不能直接使用x == NA来判断x是否是NA，而要用is.na()函数： x &lt;- NA is.na(x) #&gt; [1] TRUE 2.4.3 逻辑运算符 以下是最常用的三个逻辑运算符。 符号 描述 &amp; AND（且） | OR（或） ! 反义符号 2.4.3.1 反义符号（!） !使TRUE FALSE颠倒。一般，我们用小括号来包住一个逻辑运算，然后在它的前面加上一个!来反转结果，比如 !(3 &lt; 4) # 这个例子很简单，反义符号意义不大。后面实操的时候才能领略到它的用处。 #&gt; [1] FALSE 2.4.3.2 多个逻辑运算的组合（&amp;（且）和|（或）） &amp;和|可以把多个逻辑运算的结果合并成一个逻辑值。 &amp;判断是否两边运算结果都为TRUE。如果是，才会得到TRUE（即一真和一假得到假）。 |判断两边运算结果是否至少有一个 TRUE，如果是，就会得到TRUE。 不用死记硬背！其实就是“且”和“或”的逻辑。 用脑子想一下以下三条运算的结果，然后复制代码到R console对答案。 1 == 1 &amp; 1 == 2 &amp; 3 == 3 #即：“1等于1且1等于2且3等于3”，是真还是假？ FALSE | FALSE | TRUE # FALSE/TRUE等价于一个运算结果 !(FALSE | TRUE) &amp; TRUE # 注意反义符号 我们可以查看三个逻辑值所有两两通过&amp;组和的计算结果（如果你不感兴趣，可以不关注方法。这里重点是结果）： vals &lt;- c(TRUE, FALSE, NA) names(vals) &lt;- paste(&#39;[&#39;,as.character(vals),&#39;]&#39;,sep = &#39;&#39;) outer(vals, vals, &quot;&amp;&quot;) #&gt; [TRUE] [FALSE] [NA] #&gt; [TRUE] TRUE FALSE NA #&gt; [FALSE] FALSE FALSE FALSE #&gt; [NA] NA FALSE NA 可以看到，FALSE与任何逻辑值组合，结果都是FALSE。这个好理解，因为一旦一个是FALSE，那么不可能两边都是TRUE. TRUE &amp; NA之所以为NA（而不是FALSE），是因为NA的意思是“不能确定真假”，即有可能真也有可能假。因此TRUE &amp; NA也无法辨真假。 再来看|的组合： outer(vals, vals, &quot;|&quot;) #&gt; [TRUE] [FALSE] [NA] #&gt; [TRUE] TRUE TRUE TRUE #&gt; [FALSE] TRUE FALSE NA #&gt; [NA] TRUE NA NA 可以看到，TRUE与任何一个逻辑值组合，都是TRUE，而FALSE | NA为NA。原因一样（因为NA的不确定性）。 "],
["control-flow.html", "2.5 判断和循环（流程控制）", " 2.5 判断和循环（流程控制） 2.5.1 给有编程基础者的快速指南 如果没编程基础，没接触过判断和循环，请看第2.5.2小节。 如果学过其他编程语言，知道判断和循环的作用，只是需要知道在R中的表达，那么请看以下两个例子快速入门，然后跳至第2.6节： m &lt;- 1:100 # 产生一个[1,2,3,...,99,100]的整数向量。上面讲过。 n &lt;- vector(&quot;numeric&quot;) for (i in n) { if (i %% 2 == 0) { n &lt;- append(n, i^2) } else if (i == 51) { break } } n #&gt; numeric(0) logi = TRUE num &lt;- 1 while (num &lt;= 100) { if (logi) { num = num + 10 # R 不支持 num += 5的简写 print(num) logi = FALSE } else { num = num + 20 print(num) logi = TRUE } } #&gt; [1] 11 #&gt; [1] 31 #&gt; [1] 41 #&gt; [1] 61 #&gt; [1] 71 #&gt; [1] 91 #&gt; [1] 101 2.5.2 无编程基础者的快速指南 我认为，举例子比纯粹的概念灌输更容易理解。 2.5.2.1 if, else if, else语句（“如果……”，“或者，如果……”，“否则……”） # 以下代码翻译成英语就是：If 1 + 1 = 2, print &quot;hi&quot;. Else, print &quot;bye&quot;. # 或中文：如果一加一等于二，那么印出“hi”，否则印出“bye”. if (1 + 1 == 2) { # 1 + 1 == 2 的运算结果是TRUE，因此“如果”成真 print(&quot;hi&quot;) # 所以会执行`print(&quot;hi&quot;)` } else { print(&quot;bye&quot;) } #&gt; [1] &quot;hi&quot; # 代码第一行中的FALSE可以替换成任何计算结果为FALSE的运算， # 比如1 + 1 == 3；小括号内的计算过程不重要， # 但运算结果必须为TRUE或FALSE（不可以是NA） if (FALSE) { print(&quot;hi&quot;) } else { # 因为是FALSE，所以`else`里的语句被执行 print(&quot;bye&quot;) } #&gt; [1] &quot;bye&quot; if (FALSE) { # 第一个`if`为FALSE print(&quot;hi&quot;) } else if (FALSE) { # 检查下一个`else if`，也是FALSE print(&quot;yoo&quot;) } else if (TRUE) { # 再检查下一个`else if`，这次是TRUE print(&quot;hey&quot;) # 所以执行`print(&quot;hey&quot;)` } else { print(&quot;bye&quot;) # 而轮不到else } #&gt; [1] &quot;hey&quot; 2.5.2.2 for循环 # 以下代码翻译成英文就是: for every element i in c(2, 4, 6, 8): # assign i^2 to n, then print n # 中文：对c(2, 4, 6, 8)`中的每一个元素i： # 创建一个n使得n等于i的平方，然后印出n for (i in c(2, 4, 6, 8)) { # i可以是任何你想要的名字，比如num n &lt;- i^2 # 如果上一行是 for (num in ..., 这一行就要写成 n &lt;- num^2 print(n) } #&gt; [1] 4 #&gt; [1] 16 #&gt; [1] 36 #&gt; [1] 64 x &lt;- vector(mode = &quot;numeric&quot;) # 创建一个空的numeric vector for (m in 1:10) { if (m %% 2 == 0) { x &lt;- append(x, m) } } x #&gt; [1] 2 4 6 8 10 M &lt;- c(1, 2, 3 ,4 ,5) N &lt;- c(10, 100, 1000) x &lt;- vector(&quot;numeric&quot;) for (m in M) { for (n in N) { # 在一个for循环中嵌入另一个for循环 x &lt;- append(x, m*n) } } x #&gt; [1] 10 100 1000 20 200 2000 30 300 3000 40 400 4000 50 500 #&gt; [15] 5000 实际操作中，要想尽办法避免for循环，尤其是以上这种双层（多层）嵌套的for循环！原因和方法请看第2.5.4节。 2.5.2.3 while循环 x &lt;- 1 while (x &lt; 10) { # 当x&lt;10的时候，执行大括号内的语句 print(x) x &lt;- x + 3 # 一定要让x的值增加，否则会进入无限循环 } #&gt; [1] 1 #&gt; [1] 4 #&gt; [1] 7 2.5.2.4 break 和 next for (i in 1:10) { if (i == 3) { next # 当i == 3时，跳过它，继续（最近的）for循环的下一个回合 } else if (i == 6) { break # 当i == 6时，结束（最近的）for循环 } print(i) # 只有当if和else if里的检验都为FALSE时，`print(i)`才会执行。 } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 4 #&gt; [1] 5 M &lt;- c(1, 2, 3, 4, 5) x &lt;- vector(&quot;numeric&quot;) for (m in M) { while (TRUE) { # 原本while(TRUE){}将会是一个无限循环（判定条件永远TRUE） x &lt;- append(x, 2*m) break # break打破了最近的这个while循环，而不影响for循环。 } } x #&gt; [1] 2 4 6 8 10 2.5.3 严谨版 如果看懂了上一节中的例子，并且作为新手不太想深究，可以暂时跳过这一节，前往第2.6节。 这里很多内容还没完成，请前往第2.6节。 2.5.3.1 if, else, else if 语句 if else语句长这样： if (something is true) { do something } else { do some other things } 其中小括号内为测试的条件，其运算结果需为TRUE或FALSE（不能是NA！）。如果你还不熟悉关于逻辑值的计算，请看第2.4节。 若运算结果为TRUE：大括号内的语句将会被执行。（如果语句只有一行，大括号可以省略） 如运算结果为FALSE： 如果后面没有else语句：什么都不会发生。 如果后面有else语句：else后（大括号里）的语句将会被执行。 R中没有专门的elseif语句，但用else加上if能实现同样的效果。else if可以添加在if语句之后，顾名思义（“或者如果”），它的作用是，如果前一个if测试的条件为FALSE，那么再新加一个测试条件。一整个if/else/else if代码块里可以包含多个else if. 注意，不能直接用x == NA来判断x是否是NA，而要用is.na(x). 否则会得到NA的结果。 2.5.3.2 ifelse()函数 ifelse()是if/else语句的向量化版本。假设我有一组长度： l &lt;- c(1.21, 1.34, -1.45, 1.56, 1.22, 1.10, 1.78, -1.33, 1.71) 我们发现有两个值是负数。长度不可能是负数，因此这些测量结果是错误的，我们需要把它们替换成NA. 这时可以用ifelse()函数： l_1 &lt;- ifelse(l &lt; 0, NA, l) l_1 #&gt; [1] 1.21 1.34 NA 1.56 1.22 1.10 1.78 NA 1.71 2.5.3.3 for循环 2.5.3.4 while循环 2.5.3.5 repeat循环 2.5.3.6 break和next 2.5.4 如何避免for循环——apply()家族函数 R中的循环效率是很低的，尤其是有多层嵌套。通过system.time()函数，看看你的电脑执行以下运算需要花多少秒：（system.time()函数在第2.6.6小节有介绍） x &lt;- vector(&quot;numeric&quot;) system.time( for (l in 1:40) { for (m in 1:50) { for (n in 1:60) { x &lt;- append(x, l*m*n) } } } ) 我的i5处理器(i5-8259U CPU @ 2.30GHz)花了39秒左右才能算出来，然而看起来计算量并不大： \\[x = \\left(1\\times1\\times1, 1\\times1\\times2\\ldots, 40\\times50\\times59, 40\\times50\\times60\\right)\\] 一共有\\(40\\times50\\times60 = 120000\\)次计算. 一个原因是，无论你的CPU有多少核心，R默认只会使用其中的一个进行计算。在第2.5.5.1节中介绍了开挂使用多核的方法。但是它治标不治本，解决for循环缓慢的终极方案是避免使用for循环，而使用向量化的方法进行计算 (vectorized computation)。在第2.1.5我介绍了简单的（二元）向量化计算。除了二元运算以外，很多时候，复杂的for loop也能用向量化计算实现。我们需要用到apply()家族的一系列函数：apply(), sapply(), lapply(), mapply(), tapply(), vapply(), rapply(), eapply()；此外，像Map(), rep(), seq()等函数也会执行向量化的计算。 在学习它们的用法之前，先来看一个直观的数据： 方法 \\((L,M,N)=(1:40,1:50,1:60)\\) \\((L,M,N)=(1:500,1:600,1:700)\\) 普通（单核）for循环 39秒 等了一小时，无果，遂弃 开挂（四核）for循环 12.304秒；CPU巨热 怕CPU炸，不敢试 sapply() 0.001秒 2.719秒 rep() 0.002秒 2.825秒 mapply() 0.004秒 4.302秒 rapply() 0.003秒 2.094秒 Map() 0.004秒 3.106秒 同样是运算上面那个for循环花了39秒的例子，使用sapply()函数和rep()函数几乎是瞬间完成；而把\\((l,m,n)\\)增至\\((1:500,1:600,1:700)\\)时（计算量为1750倍），它们仍只需不到3秒，而for循环则是不可行的。 2.5.4.1 lapply() lapply() (list apply)至少需要两个参数，第一个是对象（可以是vector或者list），第二个是函数。它的作用是把函数作用于对象中的每一个元素，并返回一个list. 无论对象是vector还是list, 返回的都是一个list. 有两类使用lapply()的方法。第一种是使用匿名函数，这个很直观： lapply(c(1, 2, 3), function(i) i^2*10) #&gt; [[1]] #&gt; [1] 10 #&gt; #&gt; [[2]] #&gt; [1] 40 #&gt; #&gt; [[3]] #&gt; [1] 90 另一种是使用有命名的函数。此时，第二个参数是函数名；随后，如果有需要，还可以加上这个函数需要的其它参数： lapply(list(5, 6, 7), rnorm, 3, .1) #&gt; [[1]] #&gt; [1] 2.97 2.79 3.07 3.05 3.08 #&gt; #&gt; [[2]] #&gt; [1] 2.98 3.03 3.12 3.15 2.95 3.08 #&gt; #&gt; [[3]] #&gt; [1] 3.00 3.13 3.08 3.00 2.99 3.00 2.89 默认lapply()的对象的各元素作为函数的第一个参数。上面这个例子等同于： list(rnorm(5, 3, .1), # 即 `rnorm(n = 5, mean = 3, sd = .1)` rnorm(6, 3, .1), rnorm(7, 3, .1)) 当第一个参数在后面被指定时，lapply()的对象的各元素所代表的参数按照排序顺延，比如： lapply(list(5, 6, 7), rnorm, n = 3, .1) #&gt; [[1]] #&gt; [1] 5.09 5.05 4.99 #&gt; #&gt; [[2]] #&gt; [1] 6.05 6.03 5.84 #&gt; #&gt; [[3]] #&gt; [1] 7.03 7.07 7.06 等同于： list(rnorm(n = 3, 5, .1), rnorm(n = 3, 6, .1), rnorm(n = 3, 7, .1)) 但是这么做会降低易读性。当对象不是被作为函数的第一个参数时，最好使用匿名函数，使之更易读： lapply(list(5, 6, 7), function(x) rnorm(3, x, .1)) 2.5.4.2 sapply() sapply() (simplified list apply)的功能本质上和lapply()一样。sapply()额外的一个特点是尽可能地化简结果： 当结果只有一个分量时，sapply()返回一个vector 当结果有多个分量，但每个分量只包含一个vector且长度相等时，sapply()会返回一个matrix 试试以下计算： lapply(c(1, 2, 3), function(i) i*10) sapply(c(1, 2, 3), function(i) i*10) lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) sapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) lapply(list(1, 2, 3), function(i) i*c(1, 10, 100)) sapply(list(1, 2, 3), function(i) i*c(1, 10, 100)) lapply(list(c(1, 2), c(4, 6), c(7, 9)), function(i) i*10) sapply(list(c(1, 2, 3), c(4, 6), c(7, 9)), function(i) i*10) 2.5.4.3 mapply()和Map() lapply()和sapply()本质上是把一个函数应用在一个向量/列表上，即这个向量/列表作为函数唯一的“自变量”。Map()则可以使用多组自变量。这意味着，lapply()能做到的，Map都能做到；Map能做到的，lapply()不一定做得到。 之前lapply()的例子lapply(c(5, 6, 7), rnorm, n = 3, .1)的Map()版本是这样的： Map(rnorm, c(5, 6, 7), 3, .1) #&gt; [[1]] #&gt; [1] 3.06 2.93 2.96 3.12 2.96 #&gt; #&gt; [[2]] #&gt; [1] 2.94 2.88 2.97 3.08 2.98 3.07 #&gt; #&gt; [[3]] #&gt; [1] 3.02 2.83 3.01 3.07 3.01 3.03 2.98 多个自变量的计算也很自然： Map(rnorm, c(2, 3, 4), c(1, 10, 100), c(.1, .5, 1)) #&gt; [[1]] #&gt; [1] 0.922 0.883 #&gt; #&gt; [[2]] #&gt; [1] 10.13 9.53 10.80 #&gt; #&gt; [[3]] #&gt; [1] 99.8 100.4 98.8 100.4 mapply()是Map()的自动化简版本： mapply(rnorm, 3, c(1, 10, 100), c(.1, .5, 1)) #&gt; [,1] [,2] [,3] #&gt; [1,] 0.845 10.22 98.6 #&gt; [2,] 1.076 10.97 101.0 #&gt; [3,] 0.972 9.85 100.4 想一想，Map(rep, list(c(1,2), list(2,3)), 3)的计算结果是什么？ 2.5.5 foreach package：for循环的进化版 foreach package相对于base R中的for循环增加了一些特性，不过最实用的是支持多核并行运算： 2.5.5.1 使用多内核进行计算 首先需要安装和使用doParallel，然后才可以使用foreach中的%dopar进行多核并行运算。 查看和设置内核数量： library(doParallel) getDoParWorkers() # 查看R当前使用的内核数量；默认应为1 #&gt; [1] 1 detectCores() # 查看可用内核总数 #&gt; [1] 8 registerDoParallel(4) # 设置内核数量 getDoParWorkers() # 再次检查内核数量 #&gt; [1] 4 设置完之后就可以使用%dopar进行多核并行运算了： x &lt;- foreach(l = 1:40, .combine = &quot;c&quot;) %dopar% { foreach(m = 1:50, .combine = &quot;c&quot;) %dopar% { foreach(n = 1:60, .combine = &quot;c&quot;) %do% { l*m*n } } } x 相比单核for循环的39秒，开挂（四核）的速度是12秒（计算量越大，优势越明显）。 2.5.6 purrr package中的apply家族函数替代品和进化产物 这一节需要使用purrr, 它是tidyverse的一部分。所以我们首先要加载它： library(tidyverse) # 或library(purrr) 2.5.6.1 map(), map_dbl(), map_chr(), … map()的使用方法和lapply()几乎一样。lapply(list(5, 6, 7), rnorm, 3, .1)用map()转写就是map(list(5, 6, 7), rnorm, 3, .1)。map()（和下面介绍的其他函数）有一个绝招就是简写匿名函数。在第(apply-lapply)节讲过，lapply()的对象默认会被作为函数的第一个参数（map()也是如此）。当不想让它作为第一个参数的时候，要使用匿名函数以保证易读性： lapply(list(5, 6, 7), function(x) rnorm(3, x, .1)) 用map()的简写版本则是： map(list(5, 6, 7), ~ rnorm(3, ., .1)) #&gt; [[1]] #&gt; [1] 4.96 5.14 4.98 #&gt; #&gt; [[2]] #&gt; [1] 6.12 6.11 6.01 #&gt; #&gt; [[3]] #&gt; [1] 7.06 6.93 7.03 map_dbl(), map_chr()函数可以把结果化简为一个向量，前提是每次的计算结果的长度都为1（即一个标量），比如这里，mean(x), mean(y), mean(z)的结果都是一个标量，所以map()的结果可以化简为一个浮点数向量。 x = c(1, 2, 3); y = c(10, 20, 30); z = c(5, 60, 115) map_dbl(list(x, y, z), mean) #&gt; [1] 2 20 60 2.5.6.2 map2()和`pmap()系列 map2()使用两个因变量。 map2(.x = c(1, 100, 10000), .y = c(.1, 1, 10), ~ rnorm(5, .x, .y)) #&gt; [[1]] #&gt; [1] 0.916 1.096 1.056 1.058 0.956 #&gt; #&gt; [[2]] #&gt; [1] 102.1 99.1 100.0 100.3 99.5 #&gt; #&gt; [[3]] #&gt; [1] 9996 9996 9997 10013 10011 pmap()使用多个因变量。与Base R的Map()不同，pmap()的第一个参数是对象，第二个才是函数。你可以使用命名列表来指定使用的函数的参数： pmap(list(mean = c(1, 100, 10000), sd = c(.1, 1, 10)), rnorm, n = 3) #&gt; [[1]] #&gt; [1] 1.30 1.00 1.15 #&gt; #&gt; [[2]] #&gt; [1] 98.1 100.4 100.1 #&gt; #&gt; [[3]] #&gt; [1] 10021 10015 9999 下一章会讲到，因为dataframe/tibble的本质是list，上面的操作也可以适用于tibble： args &lt;- tibble(mean = c(1, 100, 10000), sd = c(.1, 1, 10)) pmap(args, rnorm, 3) #&gt; [[1]] #&gt; [1] 0.954 0.847 0.739 #&gt; #&gt; [[2]] #&gt; [1] 100.0 101.4 99.1 #&gt; #&gt; [[3]] #&gt; [1] 9999 10000 10010 2.5.6.3 invoke_map(), invoke_map_dbl(), … "],
["functions.html", "2.6 函数", " 2.6 函数 2.6.1 R中的函数 不像很多其他语言的函数（和方法）有value.func()和func value等格式，R中所有函数的通用格式是这样的： function(argument1 = value1, argument2 = value2, ...) 比如 sample &lt;- c(5.1, 5.2, 4.5, 5.3, 4.3, 5.5, 5.7) # 根据传统，赋值变量时用`&lt;-`号，赋值函数参数时才用`=` t.test(x = sample, mu = 4.5) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: sample #&gt; t = 3, df = 6, p-value = 0.02 #&gt; alternative hypothesis: true mean is not equal to 4.5 #&gt; 95 percent confidence interval: #&gt; 4.61 5.56 #&gt; sample estimates: #&gt; mean of x #&gt; 5.09 二元运算符和[（取子集符号）看起来一点都不像函数，而实际上它们也是函数，因此也可以用通用的格式使用他们，只是需要加上引号或转义符号： &quot;+&quot;(2, 3) `+`(2, 3) ## 5 &quot;[&quot;(c(&quot;四川担担面&quot;, &quot;武汉热干面&quot;, &quot;兰州牛肉面&quot;, &quot;北京炸酱面&quot;), 2) #&gt; [1] &quot;武汉热干面&quot; 可自定义的二元运算符形式为%x%, 其中x为任何字符。（见第2.6.3.3节） （英语中，“parameter”或“formal argument”二词用于函数定义，“argument”或“actual argument”二词用于调用函数(Kernighan and Ritchie 1988)，中文里分别是“形式参数”和“实际参数”，但是多数场合简称“参数”。） 2.6.2 调用函数 根据通用格式（function(argument1 = value1, argument2 = value2, ...)）调用函数。对于二元运算符，a %x% b等价于&quot;x&quot;(a, b). 从“function(”开始到此函数结尾的“)”中间为参数，参数用逗号隔开，空格和换行会被忽略，“#”符号出现之处，那一行之后的内容都会被忽略。这意味着你可以（丧心病狂地）像这样调用一个函数。 sum ( # 4 4 # 我怕不是 , #疯了 6 ) #&gt; [1] 10 它实际的好处是，当参数很长或是有嵌套的函数时，可以通过换行和空格使代码更易读，就像其它的编程语言一样。 函数的参数以seq函数为例，通过查看documentation（在console执行?seq）可以查看它的所有的参数： ## Default S3 method: seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL, ...) 可以看到第一个参数是from，第二个是to，第三个是by，以此类推。因此我们执行seq(0, 50, 10)的时候，R会自动理解成seq(from = 0, to = 50, by = 10)。而想用指定长度的方法就必须要写清楚是length.out等于几。 length.out本身也可以简写： seq(0, 25, l = 11) #&gt; [1] 0.0 2.5 5.0 7.5 10.0 12.5 15.0 17.5 20.0 22.5 25.0 因为参数中只有length.out是以l开头的，l会被理解为length.out. 但是这个习惯并不好；自己用用就算了，与别人分享自己的工作时请尽量使用参数名的全称。 对于seq(0, 50, 10)，亦可写成seq(by = 10, 0, 50). 这是因为by参数先赋值，0和50是未命名的参数，所以按照剩余的参数的排列顺序来，即from = 0, to = 50. 同理，seq(to = 50, 0, 10)也是等价的。 2.6.3 创建函数 2.6.3.1 普通函数 函数名 &lt;- function(参数1, 参数2, ...){ 对参数1和参数2 进行 一系列 一行或者多行 计算 return(计算结果) } 在R中，函数是作为对象保存的，因此定义函数不需要一套另外的符号/语句，还是用赋值符号&lt;-，和function()函数。 R自带了计算样本标准差 (standard deviation, \\(s\\))的函数, sd()，我们可以根据它写一个计算均值标准差（即“标准误”, standard error）（\\(SE=s_{\\bar{x}}=\\frac{s}{\\sqrt{n}}\\)） SE &lt;- function(x) { s &lt;- sd(x) n &lt;- length(x) result &lt;- s/sqrt(n) return(result) } # 随后，你就可以使用自定义的函数了 SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) #&gt; [1] 0.337 这里其实可以做一些省略。很多时候，最后一“句”的计算结果（不是赋值计算）就是我们想return的结果。因此，这时return可以省略： SE &lt;- function(x) { s &lt;- sd(x) n &lt;- length(x) s/sqrt(n) # 注意不是`result &lt;- s/sqrt(n)` } SE(c(5,6,5,5,4,5,6,6,5,4,5,3,8)) #&gt; [1] 0.337 很多时候，函数内部有复杂流程控制，这时使用return()可以很大地增强易读性： # 这是随手写的一个没有意义的函数 myfunc &lt;- function(i){ k &lt;- 8 if (i&gt;3) { j &lt;- -i while(j &lt; 20){ k &lt;- k + i + j j &lt;- j+5 } return(k) } else { if (i %% 2 == 0) { return(5) } else return(k*i) } } myfunc(6) #&gt; [1] 83 本章剩余的内容，都是比较进阶的了。可以酌情从这里跳转至本章第2.9节。 2.6.3.2 匿名函数 函数不需要名字也可以执行。一般，会与apply族函数联用（见第2.5.4节）： sapply(1:5, function(x) x^2) #&gt; [1] 1 4 9 16 25 或者用于 2.6.3.3 二元运算符 定义二元运算符的方式和定义普通函数的方法极其类似，只是参数必须要有且仅有两个（否则作为“二元”运算符就无意义了），且运算符名称需要用引号包围。 比如我们可以定义一个计算椭圆面积的函数 &#39;%el%&#39; &lt;- function(x, y) pi*x*y 2 %el% 5 #&gt; [1] 31.4 原则上，可自定义的二元运算符不一定要用%包围；+, -, :等符号的功能都可以被自定义，但是它们是R自带的，非常常用的函数，重定义它们只会带来麻烦。 2.6.3.4 闭包 (Closure) 函数里可以包含着另一个函数，这就形成了一个闭包： myfunc &lt;- function(){ a = 5 function(){ b = 10 return(a*b) } } # 执行myfunc()的时候，默认结果为最后一句/一行，在这里应为内函数： myfunc() #&gt; function(){ #&gt; b = 10 #&gt; return(a*b) #&gt; } #&gt; &lt;environment: 0x7fa75c0f21c8&gt; # 既然`myfunc()`的结果是一个函数，那么在后面再加上一个括号就是执行内函数了；内函数可以使用外函数中所定义的变量（比如这里使用了外函数的`a = 5`） myfunc()() #&gt; [1] 50 speak &lt;- function(x){ x()$speak } speak(cat) #&gt; NULL 利用闭包，可以使用R中的简易的函数实现伪·OOP（R中的真·OOP是有三种，S3，R6和S4），这是本章末的挑战题。 2.6.4 关于... 有时候，你想写的函数可能有数量不定的参数，或是有需要传递给另一个函数的“其他参数”（即本函数不需要的参数），这时候可以在函数定义时加入一个名为...的参数，然后用list()来读取它们。list是进阶内容，在第2.7节有说明。 比如我写一个很无聊的函数： my_func &lt;- function(arg1, arg2 = 100, ...){ other_args &lt;- list(...) print(arg1) print(arg2) print(other_args) } my_func(&quot;foo&quot;, cities = c(&quot;崇阳&quot;, &quot;Αθήνα&quot;, &quot;つがる&quot;), nums = c(3,4,6)) #&gt; [1] &quot;foo&quot; #&gt; [1] 100 #&gt; $cities #&gt; [1] &quot;崇阳&quot; &quot;Αθήνα&quot; &quot;つがる&quot; #&gt; #&gt; $nums #&gt; [1] 3 4 6 arg1指定了是&quot;foo&quot;（通过简写），因此第一行印出&quot;foo&quot;; arg2未指定，因此使用默认值100，印在第二行。cities和nums在形式参数中没有匹配，因此归为“…”，作为list印在第三行及之后。 下面是一个（没有意义的）利用...做一个对于向量和列表通用的函数calc()，使calc(data, pow = a, times = b, add = c)返回与原数据data的结构相同，但各元素\\(x\\)变为\\(bx^a+c\\)的向量/列表（这和OOP有相似之处）： calc_v &lt;- function(v, pow = 1, times = 1, add = 0) { v ^ pow * times + add } calc_l &lt;- function(L, pow = 1, times = 1, add = 0) { rapply(L, function(l) l ^ pow * times + add, how = &quot;list&quot;) } calc &lt;- function(data, ...) { if(is.list(data)) { calc_l(data, ...) # 即 calc_l(L = data, ...) } else if(is.vector(data)) { calc_v(data, ...) # 即 calc_v(v = data, ...) } } calc(c(1, 2, 3), pow = 2, add = 1) #&gt; [1] 2 5 10 calc(list(1, 2, list(10, 20)), pow = 2, times = 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 8 #&gt; #&gt; [[3]] #&gt; [[3]][[1]] #&gt; [1] 200 #&gt; #&gt; [[3]][[2]] #&gt; [1] 800 pow, times和add不是calc的参数，它们以...的形式被传递给calc_l()和calc_v(). 在第(apply-sapply)节讲到，sapply()的功能本质上和lapply()一致，只是会化简结果。我们看一下sapply()函数的结构： sapply #&gt; function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) #&gt; { #&gt; FUN &lt;- match.fun(FUN) #&gt; answer &lt;- lapply(X = X, FUN = FUN, ...) #&gt; if (USE.NAMES &amp;&amp; is.character(X) &amp;&amp; is.null(names(answer))) #&gt; names(answer) &lt;- X #&gt; if (!isFALSE(simplify) &amp;&amp; length(answer)) #&gt; simplify2array(answer, higher = (simplify == &quot;array&quot;)) #&gt; else answer #&gt; } #&gt; &lt;bytecode: 0x7fa75366aa58&gt; #&gt; &lt;environment: namespace:base&gt; 可以看到，answer &lt;- lapply(X = X, FUN = FUN, ...)这一行把sapply()里...中的参数传递到了lapply()中，使用lapply()得到未化解的结果answer, 随后仅需要写用来化简结果的代码，而不需要把与lapply()里的代码重写一遍。 2.6.5 赋值函数外的对象 函数内的赋值一般只在函数内有效，比如： x &lt;- 5 fun1 &lt;- function() { x &lt;- 100 } fun1() x #&gt; [1] 5 使用assign()函数可以在函数内赋值任意environment中的对象，其中最常见的是Global environment里的（即等价于在console中直接赋值）。 x &lt;- 5 fun1 &lt;- function() { assign(&quot;x&quot;, 100, envir = .GlobalEnv) } fun1() x #&gt; [1] 100 &lt;&lt;-可用于赋值“上一层”里的对象。当在“第一层”的函数里使用&lt;&lt;-时， .GlobalEnv里对应的对象就会受到影响，即和assign(&quot;x&quot;, value, envir = .GlobalEnv)等效。 x &lt;- 5 fun1 &lt;- function() { x &lt;&lt;- 100 } fun1() x #&gt; [1] 100 在下面的例子中，fun2()赋值了fun1()里的n, 但.GlobalEnv里的n不受影响。 n &lt;- 1 # `GlobalEnv`里的`n` = 1 fun1 &lt;- function() { n &lt;- 10 # `fun1()`里的`n` = 10 fun2 &lt;- function() { n &lt;- 50 # 赋值`fun2()`里的`n` n &lt;&lt;- 100 # 重赋值`fun1()`里的`n`为100 } fun2() # 运行`fun2()` return(n) # 返回`fun1()`里的`n` } fun1() # 10是否变为100? #&gt; [1] 100 n # 是否仍然是1？ #&gt; [1] 1 利用这个性质，我们可以使apply()族函数进行递归计算，比如求累加和： cum = 0 sapply(1:10, FUN = function(x){ cum &lt;&lt;- cum + x cum }) #&gt; [1] 1 3 6 10 15 21 28 36 45 55 原则上，这已经不是一个向量化计算了，但是在这个例子中sapply()仍然比for循环（见下）速度更快。 cum = 1 for (i in 2:10000) { cum[i] &lt;- cum[i-1] + i } cum 2.6.6 测速 当你开始处理复杂，大量的数据时，或是向别人分享自己的代码时，代码执行的速度变得重要。 一段代码/一个函数经常有很多种写法，哪种效率更高呢？实践是检验真理的唯一标准，R提供了一个测速函数：system.time()函数。 x &lt;- vector(&#39;numeric&#39;) system.time( for (i in 1:50){ for (j in 1:100) { x &lt;- append(x, i*j) } } ) #&gt; user system elapsed #&gt; 0.047 0.019 0.066 其中第三个数字 (elapsed)是执行system.time()括号内的语句实际消耗的时间。可以使用索引 ([3])抓取。 如果括号内的语句大于一句，像这样： system.time( 1 + 1 2 + 1 ) R会报错。就像流程控制里学到的那样，需要用大括号包围多行/多句的语句，就像这样： system.time({ 1 + 1 2 + 1 }) References "],
["list.html", "2.7 列表 (list)", " 2.7 列表 (list) R中的列表是一种特殊的数据存储形式。使用list()函数来创建列表，比如list(1, 2, 3). 在一个列表和向量上分别使用四个判断数据结构类型的函数得到的结果 data is.vector() is.list() is.atomic() is.recursive() list(1, 2, 3) TRUE TRUE FALSE TRUE c(1 ,2 , 3) TRUE FALSE TRUE FALSE 尝试对lists和vectors使用is.vector(), is.list(), is.atomic()和is.recursive()函数，你会发现列表虽然也是“vector”，但我们一般说的“vector”都是指只能存储一种数据类型的atomic vector；而lists是recursive vector. 这意味着一个list能存储多种类型的数据，且可以包含子列表。列表中的每个分量可以是任何R中的对象 (object)：除了常用的 (atomic) vector和另外一个（子）列表以外，还可以有dataframe/tibble和函数： y &lt;- list(1, c(&quot;a&quot;,&quot;あ&quot;), list(1+3i, c(FALSE, NA, TRUE)), data.frame(x = c(&quot;阿拉木图&quot;, &quot;什切青&quot;), y = c(2, 3)), t.test) y #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; &quot;あ&quot; #&gt; #&gt; [[3]] #&gt; [[3]][[1]] #&gt; [1] 1+3i #&gt; #&gt; [[3]][[2]] #&gt; [1] FALSE NA TRUE #&gt; #&gt; #&gt; [[4]] #&gt; x y #&gt; 1 阿拉木图 2 #&gt; 2 什切青 3 #&gt; #&gt; [[5]] #&gt; function (x, ...) #&gt; UseMethod(&quot;t.test&quot;) #&gt; &lt;bytecode: 0x7fcd11819620&gt; #&gt; &lt;environment: namespace:stats&gt; 这个列表有5个分量，其中第3个是一个有2个分量的子列表。 2.7.1 list的索引/取子集 使用上面的例子： y[2] # 使用单方括号，得到的是一个只有一个分量的列表 #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;あ&quot; y[[2]] # 使用双方括号，得到的是一个向量 #&gt; [1] &quot;a&quot; &quot;あ&quot; y[[3]][[2]] # 得到的也是一个向量；父列表的索引在前，子列表的在后 #&gt; [1] FALSE NA TRUE y[[3]] # 这个位置包含两个子列表，因此得到一个有两个分量的列表 #&gt; [[1]] #&gt; [1] 1+3i #&gt; #&gt; [[2]] #&gt; [1] FALSE NA TRUE y[[3]][[2]][2] # 得到向量时，直接在后面用单方括号 #&gt; [1] NA 列表里的分量可以有名字；被命名的元素可以通过$符号抓取： z &lt;- list(c(1, 3), z2 = c(4, 5, 6), c(&quot;a&quot;, &quot;b&quot;)) z # `[[2]]`被`$z2`所取代 #&gt; [[1]] #&gt; [1] 1 3 #&gt; #&gt; $z2 #&gt; [1] 4 5 6 #&gt; #&gt; [[3]] #&gt; [1] &quot;a&quot; &quot;b&quot; z$z2 == z[[2]] # `z[[2]]`仍然是可用的，结果和`z$z2`一样 #&gt; [1] TRUE TRUE TRUE 2.7.2 合并与拆解 通过c()函数来合并多个列表。 c(list(1, 2), list(3, 4, list(5,6))) # 将等同于list(1, 2, 3, 4, list(5,6)) 也许你想把需要“合并”的列表作为子列表放在另一个列表里；这也很简单，在本节一开始就讲了： list(list(1, 2), list(3, 4)) #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] 1 #&gt; #&gt; [[1]][[2]] #&gt; [1] 2 #&gt; #&gt; #&gt; [[2]] #&gt; [[2]][[1]] #&gt; [1] 3 #&gt; #&gt; [[2]][[2]] #&gt; [1] 4 通过unlist()函数来拆解列表中的子列表。若参数recursive为TRUE（默认值），将一直拆解至无子列表的列表，如果此最简列表的所有分量都属于五种atomic vector中的数据18，此列表还会被进一步化简成向量。若recursive = FALSE，最“靠外”的一级列表（可能是多个）将会被拆解。 unlist(list(1, list(2, list(3, 4)), list(5, 6), 7, 8, 9)) # 将等同于c(1, 2, 3, 4, 5, 6, 7, 8, 9) # 注意被化简成了向量 unlist(list(1, list(2, list(&quot;a&quot;, 4)), list(5, TRUE), 7L, 8, 9+0i)) # 将等同于c(&quot;1&quot;, &quot;2&quot;, &quot;a&quot;, 4, 5, &quot;TRUE&quot;, &quot;7&quot;, 8, &quot;9+0i&quot;) # 化简成向量时，非字符元素被强制转换成字符了 unlist(list(1, list(2, list(t.test, 4)), list(5, TRUE), 7L, x, 9+0i)) # t.test无法存储于向量中，因此最简结果为一个list： # list(1, 2, t.test, 4, 5, TRUE, 7L, x, 9+0i) unlist(list(1, list(2, 3, list(4, 5)), list(6, 7), 8, 9), recursive = FALSE) # 将等同于list(1, 2, 3, list(4, 5), 6, 7, 8, 9) 因此，当A, B为列表，unlist(list(A, B), recursive = FALSE)等同于c(A, B). 2.7.3 其他性质和操作 上面说到unlist(list(A, B), recursive = FALSE)等同于c(A, B)，你可能很想用==验证一下。很不幸，你会得到一条错误信息： comparison of these types is not implemented 在第2.4.2节讲过，==只能用于atomic vectors；对于列表（和其他对象）可以用identical()函数确认两者是否完全一致。 A &lt;- list(&quot;a&quot;, 1, TRUE); B &lt;- list(5+8i, NA, 4L) C1 &lt;- unlist(list(A, B), recursive = FALSE); C2 &lt;- c(A, B) identical(C1, C2) #&gt; [1] TRUE dataframe也是可以unlist成向量的，但是并不实用。（试试unlist(list(data.frame(x = c(1,2), y = c(3,4)), 5, 6))）↩ "],
["matrix-array.html", "2.8 数组 (array)和矩阵 (matrix)简介", " 2.8 数组 (array)和矩阵 (matrix)简介 Vector是一维的数据。Array是多维的数据。Matrix是二维的数据，因此matrix是array的一种特殊情况。 Dataframe不是matrix（虽然都是方的）. Matrix是二维的，仅包含数字的array. Dataframe是一个二维的list，不同列（即列表的分量）可以存储不同的数据类型。 本质上，矩阵和数组都是以向量的形式存储的。它们只是额外地拥有dim（即“dimensions”，维度）属性。我们可以用dim()函数从向量创建数组/矩阵： A &lt;- 1:48 dim(A) &lt;- c(6,8) A #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 7 13 19 25 31 37 43 #&gt; [2,] 2 8 14 20 26 32 38 44 #&gt; [3,] 3 9 15 21 27 33 39 45 #&gt; [4,] 4 10 16 22 28 34 40 46 #&gt; [5,] 5 11 17 23 29 35 41 47 #&gt; [6,] 6 12 18 24 30 36 42 48 可以看到我们创建了一个二维的，array, 因此它也是一个（4行6列的）matrix。 is.array(A) #&gt; [1] TRUE is.matrix(A) #&gt; [1] TRUE 注意24个数字排列的方式。第一个维度是行，所以先把4行排满，随后再使用下一个维度（列），使用第2列继续排4行，就像数字一样，（十进制中）先把个位从零数到9，再使用第二个位数（十位），以此类推。下面三维和四维的例子可能会更清晰。 同时注意最左边和最上边的[1,], [,3]之类的标记。你应该猜出来了，这些是index. 假设你要抓取第五行第三列的数值： A[5,3] #&gt; [1] 17 或者第三行的全部数值： A[3,] #&gt; [1] 3 9 15 21 27 33 39 45 或者第四列的全部数值： A[,4] #&gt; [1] 19 20 21 22 23 24 接下来我们再看一个三维的例子（还是用1-48）： dim(A) &lt;- c(2,8,3) A #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 3 5 7 9 11 13 15 #&gt; [2,] 2 4 6 8 10 12 14 16 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 17 19 21 23 25 27 29 31 #&gt; [2,] 18 20 22 24 26 28 30 32 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 33 35 37 39 41 43 45 47 #&gt; [2,] 34 36 38 40 42 44 46 48 它生成了三个二维的矩阵。在每个2*8的矩阵存储满16个元素后，第三个维度就要加一了。每个矩阵开头的, , x正是第三个维度的值。同理，我们可以生成四维的array： dim(A) &lt;- c(3,4,2,2) A #&gt; , , 1, 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; , , 2, 1 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 13 16 19 22 #&gt; [2,] 14 17 20 23 #&gt; [3,] 15 18 21 24 #&gt; #&gt; , , 1, 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 25 28 31 34 #&gt; [2,] 26 29 32 35 #&gt; [3,] 27 30 33 36 #&gt; #&gt; , , 2, 2 #&gt; #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 37 40 43 46 #&gt; [2,] 38 41 44 47 #&gt; [3,] 39 42 45 48 观察每个矩阵开头的, , x, y. x是第三个维度，y是第四个维度。每个二位矩阵存满后，第三个维度（x）加一。x达到上限后，第四个维度（y）再加一。 类似二维矩阵，你可以通过index任意抓取数据，比如： A[ ,3 , , ] #每个矩阵第3列的数据，即所有第二个维度为3的数值 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 7 19 #&gt; [2,] 8 20 #&gt; [3,] 9 21 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 31 43 #&gt; [2,] 32 44 #&gt; [3,] 33 45 2.8.1 给matrices和arrays命名 假设我们记录了3种药物（chloroquine, artemisinin, doxycycline) 对5种疟原虫(P. falciparum, P. malariae, P. ovale, P. vivax, P. knowlesi)的疗效，其中每个药物对每种疟原虫做6次实验。为了记录数据，我们可以做3个6*5的矩阵：（这里只是举例子，用的是随机生成的数字） B &lt;- runif(90, 0, 1) #从均匀分布中取100个0到1之间的数 dim(B) &lt;- c(6, 5, 3) #注意顺序 B #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.0745 0.037 0.307 0.973 0.807 #&gt; [2,] 0.6947 0.923 0.815 0.521 0.706 #&gt; [3,] 0.8143 0.267 0.398 0.739 0.449 #&gt; [4,] 0.5012 0.920 0.667 0.474 0.896 #&gt; [5,] 0.5621 0.427 0.198 0.271 0.717 #&gt; [6,] 0.7429 0.393 0.805 0.793 0.069 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.260 0.9125 0.2095 0.2476 0.91970 #&gt; [2,] 0.550 0.9864 0.6791 0.0696 0.43929 #&gt; [3,] 0.908 0.0643 0.9226 0.1422 0.87797 #&gt; [4,] 0.893 0.8497 0.0858 0.9645 0.00813 #&gt; [5,] 0.181 0.3692 0.5784 0.5575 0.56831 #&gt; [6,] 0.261 0.6800 0.0103 0.2126 0.46323 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0.587 0.748 0.9722 0.512 0.9159 #&gt; [2,] 0.514 0.521 0.6365 0.316 0.9899 #&gt; [3,] 0.532 0.862 0.0901 0.653 0.6901 #&gt; [4,] 0.982 0.282 0.7048 0.496 0.0472 #&gt; [5,] 0.350 0.468 0.5280 0.929 0.3457 #&gt; [6,] 0.118 0.403 0.4688 0.359 0.3701 然后我们用dimnames()来命名： dimnames(B) &lt;- list(paste(&quot;trial.&quot;, 1:6), c(&#39;P. falciparum&#39;, &#39;P. malariae&#39;, &#39;P. ovale&#39;, &#39;P. vivax&#39;, &#39;P. knowlesi&#39;), c(&#39;chloroquine&#39;, &#39;artemisinin&#39;, &#39;doxycycline&#39;)) B #&gt; , , chloroquine #&gt; #&gt; P. falciparum P. malariae P. ovale P. vivax P. knowlesi #&gt; trial. 1 0.0745 0.037 0.307 0.973 0.807 #&gt; trial. 2 0.6947 0.923 0.815 0.521 0.706 #&gt; trial. 3 0.8143 0.267 0.398 0.739 0.449 #&gt; trial. 4 0.5012 0.920 0.667 0.474 0.896 #&gt; trial. 5 0.5621 0.427 0.198 0.271 0.717 #&gt; trial. 6 0.7429 0.393 0.805 0.793 0.069 #&gt; #&gt; , , artemisinin #&gt; #&gt; P. falciparum P. malariae P. ovale P. vivax P. knowlesi #&gt; trial. 1 0.260 0.9125 0.2095 0.2476 0.91970 #&gt; trial. 2 0.550 0.9864 0.6791 0.0696 0.43929 #&gt; trial. 3 0.908 0.0643 0.9226 0.1422 0.87797 #&gt; trial. 4 0.893 0.8497 0.0858 0.9645 0.00813 #&gt; trial. 5 0.181 0.3692 0.5784 0.5575 0.56831 #&gt; trial. 6 0.261 0.6800 0.0103 0.2126 0.46323 #&gt; #&gt; , , doxycycline #&gt; #&gt; P. falciparum P. malariae P. ovale P. vivax P. knowlesi #&gt; trial. 1 0.587 0.748 0.9722 0.512 0.9159 #&gt; trial. 2 0.514 0.521 0.6365 0.316 0.9899 #&gt; trial. 3 0.532 0.862 0.0901 0.653 0.6901 #&gt; trial. 4 0.982 0.282 0.7048 0.496 0.0472 #&gt; trial. 5 0.350 0.468 0.5280 0.929 0.3457 #&gt; trial. 6 0.118 0.403 0.4688 0.359 0.3701 "],
["test-base.html", "2.9 小测", " 2.9 小测 2.9.1 基础 转换年份到世纪。写一个名为as.century()的函数，把存储着年份的向量，比如years &lt;- c(2014, 1990, 1398, 1290, 1880, 2001)，转换成对应的世纪（注意，19XX年是20世纪）。 as.century(c(2014, 1990, 1398, 1290, 1880, 2001)) #&gt; [1] 21 20 14 13 19 21 分割时间为时和分。写名为hour(), minute()的函数，使得： times &lt;- c(0512, 0719, 2358, 0501) hour(times) #&gt; [1] 5 7 23 5 minute(times) #&gt; [1] 12 19 58 1 斐波那契数列。 背景：斐波那契数列是指\\(F = [1, 1, 2, 3, 5, 8, ...]\\)，其中： \\(F_1 = 1\\)，\\(F_2 = 1\\) 从\\(F_3\\)开始，\\(F_i = F_{i-2} + F_{i-1}\\) (也有\\(F_0=0, F_1=1\\)的说法，但是为了方便我们不用这个定义) 题目：创建一个函数名为fibon()的函数，使得fibon(i)： 当\\(i\\in \\mathbb{Z}^+\\)时，返回向量\\([F_1, F_2, \\ldots, F_i]\\) 当\\(i\\notin \\mathbb{Z}^+\\)时，返回&quot;请输入一个正整数作为`fibon()`的参数。&quot; 提示： 虽然在R中整数用1L, 2L等表示，用户在被指示“输入整数”的时候很有可能输入的是2而不是2L. 2是否等于2L?如果是，如何利用它检测输入的是否是整数？（2和2L都要被判定为“是整数”） 斐波那契数列前两位是定义，从第三位开始才是计算得出的。 seq(0, 20, 5), seq(by = 5, 0, 20, 和seq(by = 5, 0, y = 30, 20)的结果分别是什么？为什么？（你可能需要参考第(abbr)节和第(about-dot-dot-dot)节） 2.9.2 进阶 质数表。创建一个prime.list()函数，使prime.list(i)得到\\((2, 3, 5, 7, 11, ... n)\\), 其中i为大于或等于3的整数，\\(n\\)为小于i的最大质数。 prime.list(100) #&gt; [1] 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 #&gt; [24] 89 97 你能想到几种方法？哪一种更快？为什么？ 2.9.3 挑战 使用且仅使用function(), c(), list(), paste(), print()函数，&lt;-, $, ==符号，和if，实现这样的效果： Pigeon(), Turtle(), Cat()分别创建一只鸽子， 一只乌龟和一只猫（即产生一个list，各自的元素展示如下）： Guoguo &lt;- Pigeon(&quot;Guoguo&quot;) Felix &lt;- Cat(&quot;Felix&quot;, &quot;TRUE&quot;) Kazuya &lt;- Turtle(&quot;Kazuya&quot;) str(Guoguo) #&gt; List of 5 #&gt; $ name : chr &quot;Guoguo&quot; #&gt; $ common_name : chr &quot;pigeon&quot; #&gt; $ binomial_name: chr &quot;Columba livia&quot; #&gt; $ speak : chr &quot;coo&quot; #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7f8dff912a78&gt; str(Kazuya) #&gt; List of 5 #&gt; $ name : chr &quot;Kazuya&quot; #&gt; $ common_name : chr &quot;turtle&quot; #&gt; $ binomial_name: chr &quot;Trachemys scripta elegans&quot; #&gt; $ speak : logi NA #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7f8dff912a78&gt; str(Felix) #&gt; List of 6 #&gt; $ name : chr &quot;Felix&quot; #&gt; $ common_name : chr &quot;cat&quot; #&gt; $ binomial_name: chr &quot;Felis catus&quot; #&gt; $ speak : chr &quot;meow&quot; #&gt; $ greet :function (time = &quot;not_specified&quot;) #&gt; ..- attr(*, &quot;srcref&quot;)= &#39;srcref&#39; int [1:8] 6 12 12 3 12 3 6 12 #&gt; .. ..- attr(*, &quot;srcfile&quot;)=Classes &#39;srcfilecopy&#39;, &#39;srcfile&#39; &lt;environment: 0x7f8dff912a78&gt; #&gt; $ sterilized : chr &quot;TRUE&quot; 注意，鸽子，乌龟和猫都有名字 (name)，通称 (common_name)，学名 (binomial_name)，和打招呼函数 (greet())；此外，乌龟没有叫声speak()，猫额外地有绝育sterilized信息。可以这样查看信息和使用打招呼函数： Felix$binomial_name #&gt; [1] &quot;Felis catus&quot; Kazuya$greet(&quot;afternoon&quot;) #&gt; [1] &quot;Good afternoon, I&#39;m a turtle and my name is Kazuya&quot; 其中greet()的参数如果是morning, afternoon或evening，则返回&quot;Good &lt;时间段&gt; ...&quot;，否则返回&quot;Hi ...&quot;. 此外，另写两个仅对这些宠物使用的函数binomial_name()和greet()，使之能够这样使用： binomial_name(Kazuya) #&gt; [1] &quot;Trachemys scripta elegans&quot; greet(Guoguo) #&gt; [1] &quot;Hi, I&#39;m a pigeon and my name is Guoguo&quot; 你可能需要的额外信息： 鸽子，乌龟和猫的学名分别为Columba livia, Trachemys scripta elegans, Felis catus. paste()函数把多个字符串拼接成一个，其中参数sep指定连接符号，默认为空格： x &lt;- &quot;world&quot; paste(&quot;Hello&quot;, x, &quot;Bye&quot;, x, sep = &quot;---&quot;) #&gt; [1] &quot;Hello---world---Bye---world&quot; "],
["tibble.html", "Chapter 3 dataframe和tibble", " Chapter 3 dataframe和tibble 3.0.1 本章内容速览 R中的多变量数据的标准保存形式是dataframe；tibble是dataframe的进化版。 第3.1节介绍了dataframe/tibble的基本概念以及如何查看数据。 第3.2节介绍了tibble的创建——直接创建，从dataframe转换，或是从外部导入。 第3.3介绍了数据转换，即对原有的数据做一些筛选和简单的计算处理。 "],
["tibble-view.html", "3.1 查看dataframe/tibble并了解它们的结构", " 3.1 查看dataframe/tibble并了解它们的结构 3.1.1 dataframe/tibble的基本概念 dataframe是R中存储复杂（多变量）数据的规范格式，它直观易操作。tibble是tidyverse的一部分，它是dataframe的进化版，功能更强大，更易操作。 我们来看个例子： 首先加载tidyverse： require(tidyverse) 以后每次跟着本书使用R的时候，都要先加载tidyverse，不再重复提醒了。 tidyverse中自带一些范例数据，比如我们输入： mpg 这张图是重中之重。一个正确的dataframe/tibble，每一行代表的是一个observation（硬翻译的话是“观测单位”，但是我觉得这个翻译不好），每一列代表的是一个variable（变量），且同一个变量的数据类型必须一样。像这样的数据被称为“tidy data”（“整齐的数据”）。虽然看起来简单，直观，理所当然，但是现实中上人们经常会做出“不整齐”的数据。把不整齐的数据弄整齐是第(wrangle)章的重点。 3.1.2 查看更多数据 R默认显示tibble的前10行。如果想看前n行或最后n行，可以分别使用head()和tail()函数，比如： tail(mpg, 6) # `mpg`的最后6行 #&gt; # A tibble: 6 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 volkswagen passat 1.8 1999 4 auto… f 18 29 p mids… #&gt; 2 volkswagen passat 2 2008 4 auto… f 19 28 p mids… #&gt; 3 volkswagen passat 2 2008 4 manu… f 21 29 p mids… #&gt; 4 volkswagen passat 2.8 1999 6 auto… f 16 26 p mids… #&gt; 5 volkswagen passat 2.8 1999 6 manu… f 18 26 p mids… #&gt; 6 volkswagen passat 3.6 2008 6 auto… f 17 26 p mids… 若要在source栏中从头到尾查看全部数据，可以使用View函数： View(mpg) "],
["tibble-create.html", "3.2 创建tibble", " 3.2 创建tibble 3.2.1 手动输入数据以创建tibble 使用tibble()函数19，按以下格式创建tibble. 换行不是必须的，但是换行会看得更清楚。如果换行，不要忘记行末的逗号。 my_tibble_1 &lt;- tibble( nums = c(4, 5, 6), chars = c(&quot;hej&quot;, &quot;你好&quot;, &quot;こんにちは&quot;), cplxnums = c(&quot;4+8i&quot;, &quot;3+5i&quot;, &quot;3+4i&quot;) ) my_tibble_1 #&gt; # A tibble: 3 x 3 #&gt; nums chars cplxnums #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 4 hej 4+8i #&gt; 2 5 你好 3+5i #&gt; 3 6 こんにちは 3+4i 类似地，可以从现有的vector创建。注意，所有变量的长度必须一样。 x &lt;- c(1, 4 , 5 ) y &lt;- c(211,23,45) z &lt;- c(20 ,32) my_tibble_2 &lt;- tibble(v1 = x, v2 = y) my_tibble_2 #&gt; # A tibble: 3 x 2 #&gt; v1 v2 #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 211 #&gt; 2 4 23 #&gt; 3 5 45 而试图把x和z做成tibble就会报错： my_tibble_3 &lt;- tibble(w1 = x, w2 = z) # Error: Tibble columns must have consistent lengths, only values of length one are recycled: * Length 2: Column `w2` * Length 3: Column `w1` 3.2.2 把dataframe转换成一个tibble d1 &lt;- as_tibble(d) #其中d是一个dataframe 3.2.3 从外部数据创建tibble 参见第5.2.1节（数据的导入） tribble()函数亦可用来创建新tibble. 与tibble()的区别是，tibble()逐列写入数据，tribble()逐行写入数据。查看帮助文档获取使用例。↩ "],
["data-transformation.html", "3.3 数据转换 (Data Transformation)", " 3.3 数据转换 (Data Transformation) 数据转换，简而言之，就是对原有数据的展示形式做一些改动，因而把最有意义的数值以易读的形式展示出来，或是为绘图做准备。 3.3.1 取子集（抓取行，列）{tbl-subsetting} 本小节介绍了如何使用dplyr package提供的select(), filter(), slice取子集方法 更详细的解释请看第3.4.1.2节。 3.3.1.1 抓取单列 抓取单列很简单，也很常用（比如我们只想从一个大的tibble中抓两个变量研究它们之间的关系）。 有两个符号可以用于抓取列，$（仅用于变量名称）与[[]]（变量名称或索引）。还是以mpg为例，假设我们要抓取第3列 (displ)： ######################## #通过变量名称抓取： mpg[[&quot;displ&quot;]] #或 mpg$displ #一般，在RStudio中此方法最方便，因为打出“$”之后会自动提示变量名。 ######################## #通过索引抓取： mpg[[3]] 以上三种方法都应得到同样的结果（是一个vector）： #&gt; [1] 1.8 1.8 2.0 2.0 2.8 2.8 3.1 1.8 1.8 2.0 2.0 2.8 2.8 3.1 3.1 2.8 3.1 #&gt; [18] 4.2 5.3 5.3 一般我们抓取单列是为了在tibble中新建一个与那一列相关的变量，或是建一个新tibble，或是做统计学分析。以上三种情况（是绝大多数的情况）用vector进行操作很方便。 假设你在写一个复杂的函数，且需要保持数据的完整性和一致性，可以使用单方括号[；这样得到的是一个tibble（试试mpg[3]）这个特性在第3.4.1.2节中有解释。 3.3.1.2 抓取多列并返回一个tibble 有时候，一个tibble中含有很多冗余信息，我们可能想把感兴趣的几个变量抓出来做一个新tibble. 这时select()函数最为方便。可以用变量名称或者索引来抓取。比如： mpg_new &lt;- select(mpg, 3:5, 8, 9) #等同于 mpg_new &lt;- select(mpg, displ, year, cyl, cty, hwy) mpg_new #&gt; # A tibble: 234 x 5 #&gt; displ year cyl cty hwy #&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1.8 1999 4 18 29 #&gt; 2 1.8 1999 4 21 29 #&gt; 3 2 2008 4 20 31 #&gt; 4 2 2008 4 21 30 #&gt; 5 2.8 1999 6 16 26 #&gt; 6 2.8 1999 6 18 26 #&gt; 7 3.1 2008 6 18 27 #&gt; 8 1.8 1999 4 18 26 #&gt; 9 1.8 1999 4 16 25 #&gt; 10 2 2008 4 20 28 #&gt; # … with 224 more rows 显然，使用变量名抓取列比使用索引更好。虽然打字较多，但是易读性比使用索引强太多了。在向其他人展示或者分享你的工作时，易读性尤为重要。 3.3.1.3 通过filter()，抓取满足某条件的行 通过filter()，我们可以过滤出某个或多个变量满足某种条件的observations. 如果你还不熟悉逻辑运算，请看第2.4节 假设我们只想看mpg中的奥迪品牌的，排量大于等于2且小于4的车辆的数据： mpg_audi_displ2to4 &lt;- filter(mpg, manufacturer == &quot;audi&quot;, displ &gt;= 2.5 &amp; displ &lt; 4) mpg_audi_displ2to4 #&gt; # A tibble: 9 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 2.8 1999 6 auto… f 16 26 p comp… #&gt; 2 audi a4 2.8 1999 6 manu… f 18 26 p comp… #&gt; 3 audi a4 3.1 2008 6 auto… f 18 27 p comp… #&gt; 4 audi a4 qu… 2.8 1999 6 auto… 4 15 25 p comp… #&gt; 5 audi a4 qu… 2.8 1999 6 manu… 4 17 25 p comp… #&gt; 6 audi a4 qu… 3.1 2008 6 auto… 4 17 25 p comp… #&gt; 7 audi a4 qu… 3.1 2008 6 manu… 4 15 25 p comp… #&gt; 8 audi a6 qu… 2.8 1999 6 auto… 4 15 24 p mids… #&gt; 9 audi a6 qu… 3.1 2008 6 auto… 4 17 25 p mids… 3.3.1.4 用slice()，通过行数（索引）抓取行。 mpg_1to6 &lt;- slice(mpg, 21:26) # 抓取mpg的第21行至26行 mpg_1to6 #&gt; # A tibble: 6 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 chevrolet c1500… 5.3 2008 8 auto… r 14 20 r suv #&gt; 2 chevrolet c1500… 5.7 1999 8 auto… r 13 17 r suv #&gt; 3 chevrolet c1500… 6 2008 8 auto… r 12 17 r suv #&gt; 4 chevrolet corve… 5.7 1999 8 manu… r 16 26 p 2sea… #&gt; 5 chevrolet corve… 5.7 1999 8 auto… r 15 23 p 2sea… #&gt; 6 chevrolet corve… 6.2 2008 8 manu… r 16 26 p 2sea… slice()更实际的用途是随机选择个体： mpg_random4 &lt;- slice(mpg, sample(length(mpg[[1]]), 4)) # 随机四辆车 mpg_random4 #&gt; # A tibble: 4 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 toyota camry 2.4 2008 4 auto… f 21 31 r mids… #&gt; 2 chevrolet c1500… 5.3 2008 8 auto… r 14 20 r suv #&gt; 3 toyota camry 2.2 1999 4 manu… f 21 29 r mids… #&gt; 4 chevrolet corve… 6.2 2008 8 auto… r 15 25 p 2sea… 3.3.2 用mutate()修改或新增变量 mutate()函数用于新增一列数据（即新增一个变量）。 这里用R自带的一组数据举例，因为它是以dataframe格式存储的，首先我们需要把它转换成tibble. women &lt;- as_tibble(datasets::women) women #&gt; # A tibble: 15 x 2 #&gt; height weight #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 58 115 #&gt; 2 59 117 #&gt; 3 60 120 #&gt; 4 61 123 #&gt; 5 62 126 #&gt; 6 63 129 #&gt; 7 64 132 #&gt; 8 65 135 #&gt; 9 66 139 #&gt; 10 67 142 #&gt; 11 68 146 #&gt; 12 69 150 #&gt; 13 70 154 #&gt; 14 71 159 #&gt; 15 72 164 它展示了两个变量，身高和体重。根据这两个变量我们可以算出BMI. 但是，首先，我们的单位正确吗？通过观察，身高的值在64左右，体重的值在140左右，显然不像是标准单位（千克和米）。这时，第一个寻求帮助的地方应该是帮助文档，通过?women打开。帮助文档中写道： [,1] height numeric Height (in) [,2] weight numeric Weight (lbs) 原来分别是以英寸和磅做单位的。根据1 m = 39.370 in, 1 kg = 2.204 lbs： women1 &lt;- mutate(women, height_in_m = height/39.37, weight_in_kg = weight/2.204) women1 #&gt; # A tibble: 15 x 4 #&gt; height weight height_in_m weight_in_kg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 58 115 1.47 52.2 #&gt; 2 59 117 1.50 53.1 #&gt; 3 60 120 1.52 54.4 #&gt; 4 61 123 1.55 55.8 #&gt; 5 62 126 1.57 57.2 #&gt; 6 63 129 1.60 58.5 #&gt; 7 64 132 1.63 59.9 #&gt; 8 65 135 1.65 61.3 #&gt; 9 66 139 1.68 63.1 #&gt; 10 67 142 1.70 64.4 #&gt; 11 68 146 1.73 66.2 #&gt; 12 69 150 1.75 68.1 #&gt; 13 70 154 1.78 69.9 #&gt; 14 71 159 1.80 72.1 #&gt; 15 72 164 1.83 74.4 mutate()的第一个参数是dataframe/tibble的名称，接下来的参数都是变量名和它们所对应的值；可以直接在计算它们的值的表达式中使用tibble中原有的变量名，如height, weight。 当然你可以引用tibble外部的vector或者其它tibble的数据： h &lt;- women1$height_in_m women2 &lt;- mutate(women, height_in_m = h, # 引用外部vector weight_in_kg = women1$weight_in_kg) # 引用`women1`里的数据 identical(women2 ,women1) # 和`women1`是相同的 #&gt; [1] TRUE mutate()也可以用来重新赋值原有变量。假设我们根本不再需要以英寸和磅作为单位的数据，我们可以： women3 &lt;- mutate(women, height = height/39.37, weight = weight/2.204) head(women3, 3) #&gt; # A tibble: 3 x 2 #&gt; height weight #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.47 52.2 #&gt; 2 1.50 53.1 #&gt; 3 1.52 54.4 接下来我们可以愉快地算BMI了： women_bmi_1 &lt;- mutate(women3, BMI = weight/height^2) head(women_bmi_1, 4) #&gt; # A tibble: 4 x 3 #&gt; height weight BMI #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.47 52.2 24.0 #&gt; 2 1.50 53.1 23.6 #&gt; 3 1.52 54.4 23.4 #&gt; 4 1.55 55.8 23.2 如果你在创建新变量后，不想保留原有变量，可以用transmute()函数： women_bmi_2 &lt;- transmute(women3, BMI = weight/height^2) head(women_bmi_2, 4) #&gt; # A tibble: 4 x 1 #&gt; BMI #&gt; &lt;dbl&gt; #&gt; 1 24.0 #&gt; 2 23.6 #&gt; 3 23.4 #&gt; 4 23.2 这意味着transmute()函数也可以用于重命名变量： women_bmi_3 &lt;- transmute(women_bmi_2, body_mass_index = BMI) head(women_bmi_3, 3) #&gt; # A tibble: 3 x 1 #&gt; body_mass_index #&gt; &lt;dbl&gt; #&gt; 1 24.0 #&gt; 2 23.6 #&gt; 3 23.4 3.3.3 %&gt;%符号 (Pipe Operator) 通过上面学习的方法，我们来初步处理一个叫做Aids2的数据；首先，把它做成tibble并重命名为更简洁的aids aids &lt;- as_tibble(MASS::Aids2) aids #&gt; # A tibble: 2,843 x 7 #&gt; state sex diag death status T.categ age #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 NSW M 10905 11081 D hs 35 #&gt; 2 NSW M 11029 11096 D hs 53 #&gt; 3 NSW M 9551 9983 D hs 42 #&gt; 4 NSW M 9577 9654 D haem 44 #&gt; 5 NSW M 10015 10290 D hs 39 #&gt; 6 NSW M 9971 10344 D hs 36 #&gt; 7 NSW M 10746 11135 D other 36 #&gt; 8 NSW M 10042 11069 D hs 31 #&gt; 9 NSW M 10464 10956 D hs 26 #&gt; 10 NSW M 10439 10873 D hsid 27 #&gt; # … with 2,833 more rows 你要如何知道，各个变量代表什么意思？假设我们只想知道这些艾滋病人从被确诊到死亡的时间，而对其他的变量都不感兴趣，我们要去如何裁剪和转换这个tibble？ 问题看起来很简单，你也许不假思索地就这么做了： aids1 &lt;- select(aids, diag, death) aids2 &lt;- mutate(aids1, span = death-diag) aids2 #&gt; # A tibble: 2,843 x 3 #&gt; diag death span #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 10905 11081 176 #&gt; 2 11029 11096 67 #&gt; 3 9551 9983 432 #&gt; 4 9577 9654 77 #&gt; 5 10015 10290 275 #&gt; 6 9971 10344 373 #&gt; 7 10746 11135 389 #&gt; 8 10042 11069 1027 #&gt; 9 10464 10956 492 #&gt; 10 10439 10873 434 #&gt; # … with 2,833 more rows 错！ 切记，不要自作主张地推测变量的含义！一定要看作者的说明（帮助文档）！对于这个数据，在R中使用?Aids2便可以查看帮助文档，但如果数据来源于其他地方，帮助文档放置的位置多种多样（虽然一般都作为README文件与数据共同打包下载），这时需要随机应变。 即使你猜对了diag和death是两个日期，你万万不会想到death并不一定是死亡日期。实际上，它是“死亡日期”或“观察结束日期”，而status变量指示的是观察结束时患者的生/死(&quot;A&quot;/&quot;D&quot;). 所以我们实际上应该这么做： aids1 &lt;- filter(aids, status == &quot;D&quot;) # 只关注在观察期间死亡的病人 aids2 &lt;- select(aids1, diag, death) # 只关注确诊时间和死亡时间 aids_span1 &lt;- mutate(aids2, span = death-diag) # 计算时间间隔 aids_span1 #&gt; # A tibble: 1,761 x 3 #&gt; diag death span #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 10905 11081 176 #&gt; 2 11029 11096 67 #&gt; 3 9551 9983 432 #&gt; 4 9577 9654 77 #&gt; 5 10015 10290 275 #&gt; 6 9971 10344 373 #&gt; 7 10746 11135 389 #&gt; 8 10042 11069 1027 #&gt; 9 10464 10956 492 #&gt; 10 10439 10873 434 #&gt; # … with 1,751 more rows 这次我们得到了正确的数据，但是源代码非常繁琐：每进行一步操作，我们都要创建一个新的变量，然后再下一步中引用上一步创建的新变量。事实上，我们可以利用函数的嵌套把它化简： aids_span2 &lt;- mutate( select( filter(aids, status == &quot;D&quot;), diag, death ), span = death-diag ) # 验证两种方法的结果一致 identical(aids_span1, aids_span2) #&gt; [1] TRUE 虽然字数减少了，但是这种表达产生了新的问题：它既难读又难写。难读是很明显的，你要从最内部读到最外部（而不是从头读到尾），而且需要好的眼力才能把函数和参数对上号。至于难写，是因为逻辑和书写不一致：逻辑是先filter()再select()最后mutate()，而写的时候，需要不断往周围加括号，很难一气呵成。 使用%&gt;%可以极大地增强多步骤指令的易读性和易写性。上面的代码可以改写成这样（换行不是必须的）： aids_span3 &lt;- aids %&gt;% filter(status == &quot;D&quot;) %&gt;% select(diag, death) %&gt;% mutate(span = death-diag) # 验证和方法二的结果一致（即和方法一一致） identical(aids_span2, aids_span3) #&gt; [1] TRUE 清清楚楚，一目了然。第一行是操作的对象 (aids)，下面每一行是一次操作，与逻辑顺序一致，而且不需要每进行一次操作就赋值/重新引用新的数据，每个函数的第一个参数（dataframe/tibble名称）被省略了。事实上，%&gt;%符号做的事情，本质上就是把它左边的运算结果作为右边函数的第一个参数，然后再根据使用者提供的其它参数计算右边的函数。 %&gt;%的名称是“pipe operator”，和赋值符号“&lt;-”一样有快捷键，默认是Ctrl(command)+shift+M，不过可以在Tools &gt; Modify Keyboard Shortcut中自定义（在它的面板中搜索pipe operator ），我喜欢设置成Alt(option)+.。 3.3.4 group_by与summarise 这是两个经常被放在一起使用的，实用且强大的函数。这次我们用到的数据是datasets::warpbreaks. wb &lt;- as_tibble(datasets::warpbreaks) wb #&gt; # A tibble: 54 x 3 #&gt; breaks wool tension #&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; #&gt; 1 26 A L #&gt; 2 30 A L #&gt; 3 54 A L #&gt; 4 25 A L #&gt; 5 70 A L #&gt; 6 52 A L #&gt; 7 51 A L #&gt; 8 26 A L #&gt; 9 67 A L #&gt; 10 18 A M #&gt; # … with 44 more rows 通过查看帮助文档，得知这组数据是在描述羊毛类型（A或B）和张力（L, M, H, 即低，中，高）对每个织机的经纱断裂数量 (breaks)的影响。首先通过group_by函数，我们把数据首先根据wool再根据tension分组。 wb_grouped &lt;- group_by(wb, wool, tension) 这时，如果你查看wb_grouped，你很难发现它与原来的wb的区别（除了第二行的# Groups: wool, tension [6]）；但是通过summarise()函数，你可以根据分组计算相应的数据： wb_summary &lt;- summarise(wb_grouped, n = n(), MEAN = mean(breaks)) wb_summary #&gt; # A tibble: 6 x 4 #&gt; # Groups: wool [2] #&gt; wool tension n MEAN #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A L 9 44.6 #&gt; 2 A M 9 24 #&gt; 3 A H 9 24.6 #&gt; 4 B L 9 28.2 #&gt; 5 B M 9 28.8 #&gt; 6 B H 9 18.8 这里，你要想象原来的54行（54个observations）被分成6组，每组代表不同的wool和tension的组合。然后，对于每组，我们先用n()函数计算出每组的行数（多少个observations），并把它赋值给n；再通过mean(breaks)计算每组数据的breaks变量的平均值，并把它赋值给MEAN；最后，对于每组，我们都有了行数和平均值，于是返回一个新的tibble反映这些数据。 类似地，我们可以更进一步，把\\(95%\\)置信区间算出来： wb_summary &lt;- summarise(wb_grouped, n = n(), MEAN = mean(breaks), SE = sd(breaks)/sqrt(n), t = qt(0.975, n-1), upper = MEAN + t*SE, lower = MEAN - t*SE) 注意，在summarise()函数中创建的变量，如n和MEAN，可以在赋值后面的变量时直接引用，比如SE = sd(breaks)/sqrt(n)中引用了n, upper = MEAN + t*SE中引用了前面刚创建的MEAN, t, SE. 根据这些数据，我们可以很方便地用ggplot绘一个柱状图（在下一章详细讲）： ggplot(wb_summary, aes(tension, fill = wool))+ geom_col(aes(y = MEAN), position = position_dodge())+ geom_errorbar(aes(ymax = upper, ymin = lower), position = position_dodge((width=1)), width = 0.2, size = 0.4)+ theme_light() 再用我们的老朋友mpg举一个例子： mpg #&gt; # A tibble: 234 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… #&gt; 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… #&gt; 3 audi a4 2 2008 4 manu… f 20 31 p comp… #&gt; 4 audi a4 2 2008 4 auto… f 21 30 p comp… #&gt; 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… #&gt; 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… #&gt; 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… #&gt; 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… #&gt; 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… #&gt; 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… #&gt; # … with 224 more rows 你要如何根据manufacturer分组，查看每组中cty和hwy的平均值和标准误呢？自己尝试一下，然后对答案： mpg_summary &lt;- mpg %&gt;% group_by(manufacturer) %&gt;% summarise(n = n(), cty_mean = mean(cty), cty_SE = sd(cty)/sqrt(n), hwy_mean = mean(hwy), hwy_SE = sd(hwy)/sqrt(n)) mpg_summary #&gt; # A tibble: 15 x 6 #&gt; manufacturer n cty_mean cty_SE hwy_mean hwy_SE #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 audi 18 17.6 0.465 26.4 0.513 #&gt; 2 chevrolet 19 15 0.671 21.9 1.17 #&gt; 3 dodge 37 13.1 0.409 17.9 0.588 #&gt; 4 ford 25 14 0.383 19.4 0.666 #&gt; 5 honda 9 24.4 0.648 32.6 0.852 #&gt; 6 hyundai 14 18.6 0.401 26.9 0.582 #&gt; 7 jeep 8 13.5 0.886 17.6 1.15 #&gt; 8 land rover 4 11.5 0.289 16.5 0.866 #&gt; 9 lincoln 3 11.3 0.333 17 0.577 #&gt; 10 mercury 4 13.2 0.25 18 0.577 #&gt; 11 nissan 13 18.1 0.950 24.6 1.41 #&gt; 12 pontiac 5 17 0.447 26.4 0.510 #&gt; 13 subaru 14 19.3 0.244 25.6 0.309 #&gt; 14 toyota 34 18.5 0.694 24.9 1.06 #&gt; 15 volkswagen 27 20.9 0.877 29.2 1.02 最终我们可以利用这些数据绘图（这将是下一章的练习）： "],
["tibble-misc.html", "3.4 其它", " 3.4 其它 3.4.1 list和dataframe/tibble 3.4.1.1 Dataframe和tibble的本质 聪明的你也许已经注意到了，dataframe/tibble抓取单列的方法和list的取子集2.7.1惊人地相似。事实上，dataframe的本质正是list，而tibble也是dataframe（只是进化了一些功能）： is.list(mpg) #&gt; [1] TRUE class(mpg) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 3.4.1.2 Dataframe/tibble的取子集 Dataframe/tibble既有list的特征，也有matrix的特征。 当使用一个参数取子集的时候，比如mpg[[3]]，mpg[[&quot;displ&quot;]]或mpg$displ，tibble表现得像list，其中每一列是一个有命名的list element； 当使用两个参数取子集的时候，比如mpg[3,4], mpg[3, ], mpg[ ,4]，tibble表现得像matrix mpg[3, ] #&gt; # A tibble: 1 x 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 2 2008 4 manua… f 20 31 p comp… 3.4.2 Tidyverse tibble相对于Base R dataframe的优势 你可以把mpg转换成dataframe，命名为mpg1，探索两者的区别。 mpg1 &lt;- as.data.frame(mpg) 3.4.2.1 信息的显示 首先，查看print()结果（直接输入mpg1或者print(mpg1)） 对于行数/列数较多的数据，dataframe的显示结果很乱，而且信息量小。当行数较多时，你需要往上划才能看见变量名；当你的console比较窄或者变量名太多时，dataframe会先显示一部分变量（列），再把剩余的变量（列）显示在后面。这时你需要往上划查看一部分变量，再往上划查看另一部分变量。 tibble的显示结果一致性强，信息量大。它永远只显示前10行，因此不用往上划就能看到显示的所有信息。它指明了行数和列数，变量的数据类型；当变量较多时，不会影响显示，而是在末尾指明其余的变量名字和数据类型。 3.4.2.2 tibble不会自作主张地化简结果 Base R dataframe自带的取子集函数在一些情况下不会化简结果，而在另一些情况下会自动化简结果20，这经常会造成意想不到而且很难察觉的错误，尤其对于开发者来说简直是噩梦(Gentleman 2009, 33; Wickham 2019)。对tibble取子集，永远会返回一个tibble；这样可以提高代码的一致性，降低发生错误的可能性。 请查看Advanced R了解更多。 3.4.2.3 tibble与其它tidyverse中的功能兼容性更强 很多tidyverse中的神器，如group_by，只能在tibble上使用。 References "],
["graphics.html", "Chapter 4 使用ggplot绘图", " Chapter 4 使用ggplot绘图 若要了解更多，请阅读ggplot开发者本人所编写的ggplot2: Elegand Graphics for Data Analysis(Wickham 2015)。 References "],
["g-phil.html", "4.1 哲理", " 4.1 哲理 "],
["g-basics.html", "4.2 基础", " 4.2 基础 4.2.1 基本语法 4.2.2 图像类型 "],
["g-intermediate.html", "4.3 进阶", " 4.3 进阶 4.3.1 逐层作图 4.3.2 尺寸，轴，和图例 4.3.3 位置 4.3.4 背景/主题的修改 4.3.5 与ggplot编程 "],
["g-base.html", "4.4 附：Base R中的作图", " 4.4 附：Base R中的作图 "],
["wrangle.html", "Chapter 5 数据处理 ", " Chapter 5 数据处理 "],
["untidy-to-tidy.html", "5.1 把“untidy data”整成“tidy data”", " 5.1 把“untidy data”整成“tidy data” 5.1.1 “untidy data”的主要问题 5.1.2 解决方案 "],
["import-export.html", "5.2 数据的导入和导出", " 5.2 数据的导入和导出 5.2.1 导入 5.2.1.1 csv 5.2.1.2 excel 5.2.1.3 其它 5.2.2 导出 "],
["strings.html", "5.3 字符串的处理", " 5.3 字符串的处理 Base R中有一些用于操作字符串的函数，但是因为各种原因它们很难用。因此我们使用一系列stringr中的函数（stringr是tidyverse的一部分）。stringr的函数都以str_开头。 5.3.1 基础 5.3.1.1 引号的使用 字符串可以用单引号和双引号包围。在双引号包围的环境下，可以很容易打出英澳常用的单引号和欧洲语言中的“撇”；在单引号包围的环境下，可以很容易打出北美和中国常用的双引号。否则需要使用转义字符 (escape character), \\. 以下是几个正确的例子。 &quot;&#39;The unexamined life is not worth living&#39; —Socrates&quot; #&gt; [1] &quot;&#39;The unexamined life is not worth living&#39; —Socrates&quot; &quot;La science n&#39;a pas de patrie.&quot; #&gt; [1] &quot;La science n&#39;a pas de patrie.&quot; &#39;&quot;老子曰：“知不知，尚矣；不知知，病矣。&quot;&#39; #&gt; [1] &quot;\\&quot;老子曰：“知不知，尚矣；不知知，病矣。\\&quot;&quot; &#39;l\\&#39;homme&#39; #&gt; [1] &quot;l&#39;homme&quot; 5.3.1.2 换行符和制表符 假设你想显示以下效果： #&gt; Guten #&gt; #&gt; Morgen. 即“Guten”后有两次换行，第三行开头有一个制表符 (TAB) 你需要的源代码是： &quot;Guten\\n\\n\\tMorgen.&quot; \\n (newline)为换行符，\\t (tab)为制表符。所有可用的通过\\实现的符号请参见help(&quot;'&quot;)（关于引号的帮助）. 5.3.1.3 print()和writeLines() print()只显示源码，writeLines()显示真实效果。 print(c(&quot;Guten\\n\\n\\tMorgen.&quot;, &quot;Guten\\n\\n\\tTag&quot;)) #&gt; [1] &quot;Guten\\n\\n\\tMorgen.&quot; &quot;Guten\\n\\n\\tTag&quot; writeLines(c(&quot;Guten\\n\\n\\tMorgen.&quot;, &quot;Guten\\n\\n\\tTag&quot;)) #&gt; Guten #&gt; #&gt; Morgen. #&gt; Guten #&gt; #&gt; Tag 索引和引号消失了，不同的元素之间有换行。 5.3.2 使用str_sub()取子集 A &lt;- &quot;D. rerio&quot; str_sub(A, 1, 5) # 第1到第5个字母。计入符号和空格。 #&gt; [1] &quot;D. re&quot; str_sub(A, 4, 4) # 抓取一个字母 #&gt; [1] &quot;r&quot; str_sub(A, -4, -2) # 倒数第4至倒数第2 #&gt; [1] &quot;eri&quot; 我们还可以通过索引修改某个位置的字符： W &lt;- &quot;D. Rerio&quot; str_sub(W, 4, 4) &lt;- str_to_lower(str_sub(W, 4, 4)) W #&gt; [1] &quot;D. rerio&quot; 和str_to_lower()相关的函数还有str_to_upper(), str_to_title()和str_to_sentence(). 它们的作用都顾名思义。 5.3.3 使用str_c()进行字符串的合并 一个简单的例子： str_c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;&quot;) #&gt; [1] &quot;abc&quot; 其中参数sep是被合并的字符串之间的连接字符；它可以是任何字符，包括空格和无（比如上面的例子；用sep = &quot;&quot;表示无连接字符）。 当需要合并的字符串保存在一个向量里时，用collapse而不是sep： str_c(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), collapse = &quot;[x@&quot;) #&gt; [1] &quot;a[x@b[x@c&quot; str_c()可以执行向量化运算： str_c(&quot;prefix&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;suffix&quot;, sep = &quot;-&quot;) #&gt; [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot; 所以我们可以这么玩： 混沌在各地的称呼 &lt;- str_c( str_c( &quot;地区&quot;, c(&quot;北京&quot;, &quot;湖北&quot;, &quot;巴蜀&quot;, &quot;两广&quot;, &quot;闽台&quot;), sep = &quot;：&quot; ), str_c( &quot;称呼&quot;, c(&quot;混沌&quot;, &quot;包面&quot;, &quot;抄手&quot;, &quot;云吞&quot;, &quot;扁食&quot;), sep = &quot;：&quot; ), sep = &quot; &quot; ) writeLines(混沌在各地的称呼) #&gt; 地区：北京 称呼：混沌 #&gt; 地区：湖北 称呼：包面 #&gt; 地区：巴蜀 称呼：抄手 #&gt; 地区：两广 称呼：云吞 #&gt; 地区：闽台 称呼：扁食 它还可以和if语句联用： win &lt;- 2 score &lt;- str_c( &quot;张三&quot;, if (win == 1) &quot;赢\\n&quot; else &quot;输\\n&quot;, &quot;李四&quot;, if (win == 2) &quot;赢&quot; else &quot;输&quot;, sep = &quot;&quot; ) writeLines(score) #&gt; 张三输 #&gt; 李四赢 5.3.4 使用str_view()来查找特定的字符组合 5.3.5 str_detect() suomi &lt;- &quot;Suomen kieli on uralilaisten kielten itämerensuomalaiseen ryhmään kuuluva kieli.&quot; "],
["factors.html", "5.4 Factors", " 5.4 Factors 5.4.1 基础 有时候，我们的变量是以文字的形式呈现，但是它们不是单纯的文字，而是有大小的差别，或是能以一定顺序排列，比如十二个月份 (Jan, Feb, …)，成绩的“优、良、中、差”，衣服的尺寸 (XS, S, M, XL, …). 假设我们在做客户满意度调查，七位客户的反馈是 满意度_v &lt;- c(&quot;满意&quot;, &quot;非常满意&quot;, &quot;满意&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常不满&quot;, &quot;不满意&quot;) 我们试图用sort()把七个反馈按满意度从小到大排列： sort(满意度_v) #&gt; [1] &quot;不满意&quot; &quot;不满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;满意&quot; &quot;非常不满&quot; #&gt; [7] &quot;非常满意&quot; 可见其排序并不是有意义的。（因为默认英语根据’abcde…’排序，中文根据笔画排序） 我们可以把这个vector做成factor，并用参数levels规定排序顺序： # 按照惯例，小的值在前，大的在后；“非常不满”应为满意度最低的值。 满意度_f &lt;- factor(满意度_v, levels = c(&quot;非常不满&quot;, &quot;不满意&quot;, &quot;满意&quot;, &quot;非常满意&quot;)) sort(满意度_f) #&gt; [1] 非常不满 不满意 不满意 满意 满意 满意 非常满意 #&gt; Levels: 非常不满 不满意 满意 非常满意 这样排序就是正确的了。 class(满意度_f) # &quot;factor&quot; is.vector(满意度_f) # FALSE 5.4.2 在绘图中的应用 5.4.3 高端操作 "],
["dttm.html", "5.5 日期和时间", " 5.5 日期和时间 日期和时间是一个很令人头疼的话题。不是所有的年都是365天，不是每天都是24小时，不是每分钟都是60秒21。 R自带的日期/时间方法不太好用，因此我们用一个叫做lubridate的package. install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) 5.5.1 ISO标准 日期/时间的ISO标准格式是这样的： now() #&gt; [1] &quot;2019-07-28 13:16:31 CST&quot; 最后三个字母是时区。 5.5.2 创建日期/时间 5.5.2.1 现在的日期/时间 today() #&gt; [1] &quot;2019-07-28&quot; now() #&gt; [1] &quot;2019-07-28 13:16:31 CST&quot; 5.5.2.2 通过字符串转换 date()函数可以把ISO标准格式的日期，从字符串转换成日期的数据类型。 class(&quot;2001-02-01&quot;) #&gt; [1] &quot;character&quot; date(&quot;2001-02-01&quot;); class(date(&quot;2001-02-01&quot;)) #&gt; [1] &quot;2001-02-01&quot; #&gt; [1] &quot;Date&quot; ymd(), mdy(), dmy()这三个函数可以很智能地把各种格式的日期转换成ISO标准的日期。 X &lt;- date(&quot;2001-02-01&quot;) A &lt;- ymd(010201) B &lt;- mdy(&quot;February the 1st, 2001&quot;) C &lt;- dmy(&quot;01/FEB/01&quot;) # 验证A, B, C全部等于X sapply(list(A, B, C), identical, X) #&gt; [1] TRUE TRUE TRUE 如果想加上时间，使用有_h, _hm, _hms后缀的版本的函数： dmy_h(&quot;01-Feb-2001 17&quot;) #&gt; [1] &quot;2001-02-01 17:00:00 UTC&quot; ymd_hms(010201173245) #&gt; [1] &quot;2001-02-01 17:32:45 UTC&quot; 5.5.3 计算 5.5.4 在绘图中的应用 闰年为366天；夏令时开始时的那一天只有23小时，结束时为25小时；地球的自转速度在缓慢下降，因此会有“闰秒”。↩ "],
["python.html", "Chapter 6 与Python的联合使用 ", " Chapter 6 与Python的联合使用 "],
["reticulate.html", "6.1 在R中使用Python: reticulate", " 6.1 在R中使用Python: reticulate "],
["rpy.html", "6.2 在Python中使用R: rpy", " 6.2 在Python中使用R: rpy "],
["beaker.html", "6.3 Beaker Notebook", " 6.3 Beaker Notebook https://decisionstats.com/2015/12/07/decisionstats-interview-scott-draves-beaker-notebook/ Inspired by Jupyter, Beaker Notebook allows you to switch from one language in one code block to another language in another code block in a streamlined way to pass shared objects (data) "],
["References.html", "References", " References "]
]
