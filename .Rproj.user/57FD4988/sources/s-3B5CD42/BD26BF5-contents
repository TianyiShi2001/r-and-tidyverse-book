---
nocite: |
 @Gentleman2009R-Programming-Bioinfo, @Grolemund:2016
---

# dataframe（数据框）和tibble {#tibble}

## 查看dataframe/tibble并了解它们的结构

### dataframe/tibble的基本概念

dataframe是R中存储复杂数据的格式，它直观易操作。tibble是tidyverse的一部分，它是dataframe的进化版，功能更强大，更易操作。

我们来看个例子：

首先加载tidyverse：

```{r eval=FALSE}
require(tidyverse)
```

**以后每次跟着本书使用R的时候，都要先加载tidyverse，不再重复提醒了。**

tidyverse中自带一些范例数据，比如我们输入：

```{r eval=FALSE}
mpg
```

```{r echo=FALSE}
knitr::include_graphics('img/tibble-intro.png')
```

这张图是重中之重。一个正确的dataframe/tibble，每一行代表的是一个observation（硬翻译的话是“观测单位”，但是我觉得这个翻译不好），每一列代表的是一个variable（变量），且同一个变量的数据类型必须一样[^1]。像这样的数据被称为“tidy data”（“整齐的数据”）。虽然看起来简单，直观，理所当然，但是现实中上人们经常会做出“不整齐”的数据。把不整齐的数据弄整齐是下一章的重点。

### 查看更多数据

R默认显示dataframe/tibble的前10行。如果想看最后6行，可以使用`tail()`函数，比如：

```{r}
tail(mpg)
```

若要从头到尾查看全部数据，可以使用`View`函数：

```{r eval=FALSE}
View(mpg)
```

## tibble的创建和基础操作

### 创建tibble

#### 手动输入数据以创建tibble

使用`tibble`函数，按以下格式创建tibble. 换行不是必须的，但是换行会看得更清楚。如果换行，不要忘记行末的逗号。

```{r}
my_tibble_1 <- tibble(
                nums = c(4, 5, 6),
                chars = c("hej", "你好", "こんにちは"),
                cplxnums = c("4+8i", "3+5i", "3+4i")
                )
my_tibble_1
```

类似地，可以从现有的vector创建。**所有的变量长度必须一样。**

```{r}
x <- c(1,4,5)
y <- c(211,23,45)
z <- c(20,32)
```

```{r}
my_tibble_2 <- tibble(v1 = x, v2 = y)
my_tibble_2
```

而试图把`x`和`z`做成tibble就会报错：

```{r eval=FALSE}
my_tibble_3 <- tibble(w1 = x, w2 = z)

 # Error: Tibble columns must have consistent lengths, only values of length one are recycled: * Length 2: Column `w2` * Length 3: Column `w1`
```

#### 把dataframe转换成一个tibble

```{r eval=FALSE}
d1 <- as.tibble(d) #其中d是一个dataframe
```

#### 从外部数据创建tibble

参见第\@ref(data-import)节（数据的导入）



### 取子集（抓取行，列）

#### 抓取单列 {#single-column}

抓取单列很简单，也很常用（比如我们只想从一个大的tibble中抓两个变量研究它们之间的关系）。 有两个符号可以用于抓取列，`$`（仅用于变量名称）与`[[]]`（变量名称或索引）。还是以`mpg`为例，假设我们要抓取第3列 (`displ`)：

```{r eval=FALSE}
########################
#通过变量名称抓取：
mpg[["displ"]]
#或
mpg$displ #一般，在RStudio中此方法最方便，因为打出“$”之后会自动提示变量名。

########################
#通过索引抓取：
mpg[[3]]
```

以上三种方法都应得到同样的结果（是一个vector）：

```{r echo=FALSE}
mpg[[3]][1:20] 
#因为长度有222，为避免浪费空间我们只显示第1到20个元素。顺便复习一下向量的索引。
```

如果使用单方括号，得到的是一个tibble（试试`mpg[3]`）这个特性在第\@ref(dataframe-subsetting)节中有解释。

#### 抓取多列

有时候，一个tibble中含有很多冗余信息，我们可能想把感兴趣的几个变量抓出来做一个新tibble. 这时`select()`函数最为方便。可以用变量名称或者索引来抓取。比如：

```{r}
mpg_new <- select(mpg, 3:5, 8, 9)
#等同于
mpg_new <- select(mpg, displ, year, cyl, cty, hwy)

mpg_new
```

base

#### 通过`filter()`，抓取满足某条件的行

通过`filter()`，我们可以过滤出某个或多个变量满足某种条件的observations. 如果你还不熟悉逻辑运算，请看第\@ref(logical-operations)节

假设我们只想看`mpg`中的奥迪品牌的，排量大于等于2且小于4的车辆的数据：

```{r}
mpg_audi_displ2to4 <- filter(mpg, manufacturer == "audi", displ >= 2.5 & displ < 4)

mpg_audi_displ2to4
```

#### 用`slice()`，通过行数（索引）抓取行。

```{r}
mpg_1to6 <- slice(mpg, 21:26) # 抓取mpg的第21行至26行
mpg_1to6
```

我觉得`slice()`更实际的用途是随机选择个体：

```{r}
mpg_random4 <- slice(mpg, sample(length(mpg[[1]]), 4)) # 随机四辆车
mpg_random4
```

### 关于Factor

有时候，我们的变量是以文字的形式呈现，但是它们不是单纯的文字，而是有大小的差别，或是能以一定顺序排列，比如十二个月份 (Jan, Feb, ...)，成绩的“优、良、中、差”，衣服的尺寸 (XS, S, M, XL, ...). 假设我们在做客户满意度调查，七位客户的反馈是

```{r}
满意度_v <- c("满意", "非常满意", "满意", "不满意", "满意", "非常不满",  "不满意")
```

我们试图用`sort()`把七个反馈按满意度从小到大排列：

```{r}
sort(满意度_v)
```

可见其排序并不是有意义的。（因为默认英语根据'abcde...'排序，中文根据笔画排序）

我们可以把这个vector做成factor，并用参数`levels`规定排序顺序：

```{r}
# 按照惯例，小的值在前，大的在后；“非常不满”应为满意度最低的值。
满意度_f <- factor(满意度_v, levels = c("非常不满", "不满意", "满意", "非常满意"))
sort(满意度_f)
```

这样排序就是正确的了。

```{r eval=FALSE}
class(满意度_f) # "factor"
is.vector(满意度_f) # FALSE
```


## 进阶内容：list, array和matrix

这一节为进阶内容，不用看。可以直接跳到下一章（第\@ref(graphics)

其中的很多操作和dataframe或tibble中的操作是等效的。一般，tibble中的操作更直观，更容易上手。

### list（列表）简介

R中的list是一种特殊的数据存储形式。使用`list()`函数来创建lists.

尝试对lists和vectors使用`is.vector()`, `is.list()`, `is.atomic()`和`is.recursive()`函数，你会发现list虽然也是“vector”，但我们一般说的“vector”都是指只能存储一种数据类型的atomic vector；而lists是recursive vector. 

这意味着**一个list能存储多种类型的数据，且可以包含子list**。list中的每个元素可以是**任何R中的物件** (object)：除了常用的 (atomic) vector和另外一个（子）list以外，还可以有dataframe/tibble和函数：

```{r}
y <- list(1, c("a","あ"), list(1+3i, c(FALSE, NA, TRUE)), 
          tibble(x = c("阿拉木图", "什切青"), y = c(2, 3)),
          t.test)
y
```

#### list的索引/取子集

使用上面的例子：

```{r}
y[2] # 使用单方括号，得到的是一个只有一个list元素的list
y[[2]] # 使用双方括号，得到的是一个vector
y[[3]][[2]] # 得到的也是一个vector；母list的索引在前，子list的在后
y[[3]] # 这个位置包含两个子list，因此得到一个有两个list元素的list
y[[3]][[2]][2] # 得到vector时，直接在后面用单方括号
```

list里的元素可以有名字；被命名的元素可以通过`$`符号抓取：

```{r}
z <- list(c(1, 3), z2 = c(4, 5, 6), c("a", "b"))
z # `[[2]]`被`$z2`所取代
z$z2 == z[[2]] # `z[[2]]`仍然是可用的，结果和`z$z2`一样
```

#### Dataframe和tibble的本质

聪明的你也许已经注意到了，dataframe/tibble[抓取单列的方法](#single-column)和list的取子集惊人地相似（我曾经的语文老师喜欢调侃抄作业的同学的答案与参考答案“惊人地相似”）。

事实上，dataframe的本质正是list，而tibble也是dataframe（只是进化了一些功能）：

```{r}
is.list(mpg)
class(mpg)
```

#### Dataframe/tibble的取子集 {#dataframe-subsetting}

Tibble既有list的特征，也有matrix的特征。

当使用一个参数取子集的时候，比如`mpg[[3]]`，`mpg[["displ"]]`或`mpg$displ`，tibble表现得像list，其中每一列是一个有命名的list element；

当使用两个参数取子集的时候，比如`mpg[3,4]`, `mpg[3, ]`, `mpg[ ,4]`，tibble表现得像matrix

```{r}
mpg[3, ]
```

请查看[Advanced R](https://adv-r.hadley.nz/subsetting.html#simplify-preserve)了解更多。

### Base R dataframe 和 Tidyverse tibble的区别

你可能已经注意到，上面`mpg[3, ]`和`select(mpg, 3)`是等效的；`mpg[3, ]`显然更精简，那么为什么要使用`select()`函数呢？


zaocheng[@Gentleman2009R-Programming-Bioinfo, p. 33; @Wickham:2019]



### array（数组）和matrix（矩阵）简介

Vector是一维的数据。Array是多维的数据。Matrix是二维的数据，因此matrix是array的一种特殊情况。

Dataframe不是matrix（虽然都是方的）. Matrix是二维的，**仅包含数字**的**array**. Dataframe是一个二维的**list**，不同列（即list元素）**可以存储不同的数据类型**。

我们可以用`dim()`来创建arrays：

```{r}
A <- 1:48 #创建一个(1,2,3,...24)的numeric vector
dim(A) <- c(6,8) #给A assign一个6乘4的dimensions
A
```

可以看到我们创建了一个二维的，array, 因此它也是一个（4行6列的）matrix。

```{r}
is.array(A)
is.matrix(A)
```

注意24个数字排列的方式。第一个维度是行，所以先把4行排满，随后再使用下一个维度（列），使用第2列继续排4行，就像数字一样，（十进制中）先把个位从零数到9，再使用第二个位数（十位），以此类推。下面三维和四维的例子可能会更清晰。

同时注意最左边和最上边的[1,], [,3]之类的标记。你应该猜出来了，这些是index. 假设你要抓取第五行第三列的数值：

```{r}
A[5,3]
```

或者第三行的全部数值：

```{r}
A[3,]
```

或者第四列的全部数值：

```{r}
A[,4]
```

接下来我们再看一个三维的例子（还是用1-48）：

```{r}
dim(A) <- c(2,8,3)
A
```

它生成了三个二维的矩阵。在每个2*8的矩阵存储满16个元素后，第三个维度就要加一了。每个矩阵开头的`, , x`正是第三个维度的值。同理，我们可以生成四维的array：

```{r}
dim(A) <- c(3,4,2,2)
A
```

观察每个矩阵开头的`, , x, y`.  x是第三个维度，y是第四个维度。每个二位矩阵存满后，第三个维度（x）加一。x达到上限后，第四个维度（y）再加一。

类似二维矩阵，你可以通过index任意抓取数据，比如：

```{r}
A[ ,3 , , ] #每个矩阵第3列的数据，即所有第二个维度为3的数值
```

### 给matrices和arrays命名

假设我们记录了3种药物（chloroquine, artemisinin, doxycycline)
对5种疟原虫(P. falciparum, P. malariae, P. ovale, P. vivax, P. knowlesi)的疗效，其中每个药物对每种疟原虫做6次实验。为了记录数据，我们可以做3个6*5的矩阵：（这里只是举例子，用的是随机生成的数字）

```{r}
B <- runif(90, 0, 1) #从均匀分布中取100个0到1之间的数
dim(B) <- c(6, 5, 3) #注意顺序
B
```

然后我们用`dimnames()`来命名：

```{r}
dimnames(B) <- list(paste("trial.", 1:6), c('P. falciparum', 'P. malariae', 'P. ovale', 'P. vivax', 'P. knowlesi'), c('chloroquine', 'artemisinin', 'doxycycline'))
B
```

**清清楚楚，一目了然。**

### `apply`

```{r}
apply(A,1,sum)
```