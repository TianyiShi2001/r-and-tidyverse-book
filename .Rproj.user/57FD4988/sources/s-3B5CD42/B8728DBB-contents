---
nocite: |
  @Gentleman2009R-Programming-Bioinfo
---

# 向量，逻辑，循环和函数 {#vectors-logicals-and-functions}

*注意，R中的变量名/自定义函数名不能以数字和特殊符号开头，中间只能使用"_"和"."作为特殊符号*[^naming]

[^naming]: 如果非要违反规则，可以使用转义符号`\``，比如可以`` `4foo%b=a+r` <- 50 ``


## 向量的概念，操作和优越性

R没有标量，它通过各种类型的向量 (vector)来存储数据。

### 创建向量（赋值）{#create-vector}

与很多其他的计算机语言不同，在R中，`<-`（像一个小箭头）用于给**向量，数据框和函数**赋值（即在每行的开头）。在RStudio中，可以用`Alt`+`-` (Mac是 `option`+`-`) 这个快捷键打出这个符号。

```{r}
x <- 2
x
```

虽然`=`也可以用，但是绝大多数R用户还是采用标准的`<-`符号，而`=`则用于给**函数的参数**赋值。

要创建一个多元素的向量，需要用到`c()` (concatenate)函数：

```{r}
nums <- c(1,45,78)
cities <- c("Zürich", "上海", "Tehrān")
nums
cities
```

通过`length()`函数，可以查看向量的长度。

```{r}
length(nums)
#如果无后续使用，没必要赋值一个变量；c(...)的计算结果就是一个向量，并直接传给`length()`函数
length(c("Guten Morgen")) 
```

（每个被引号包围的一串字符，都只算做一个元素，因此长度为1；多元素的向量请看第\@ref(create-vector)节）

还是通过`c()`函数，可以把多个向量拼接起来：
```{r}
cities_1 <- c("Zürich", "上海", "Tehrān")
cities_2 <- c("大阪", "Poznań", "Екатеринбу́рг")

cities <- c(cities_1, cities_2, c("Jyväskylä", "부산", "เชียงใหม่"))

cities
```

### 索引/取子集 (indexing/subsetting) {#indexing}

索引 (index)就是一个元素在向量中的位置。R是从1开始索引的，即索引为1的元素是第一个元素（因此用熟了Python和C可能会有些不适应）。在向量后方使用方括号进行取子集运算（即抓取索引为对应数字的元素；虽然subsetting翻译成“取子集”有点怪，但是没毛病；不知大家有没有更好的翻译方法，或是不翻译更好）。

```{r}
x <- c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine")
x[3]
```

可以在方括号中使用另一个向量抓取多个元素：

```{r}
x[c(2,5,9)] # 第2个，第5个，第9个元素
```

经常，我们会抓取几个连续的元素。如果想知道方法，请继续往下看。

### 生成器

有时候我们需要其元素按一定规律排列的向量，这时，相对于一个个手动输入，有更方便的方法：

#### 连续整数 

```{r}
1:10 #从左边的数（包含）到右边的数（包含），即1:10
```

这时，你应该会有个大胆的想法：

```{r}
x[3:6]
```

没错就是这么用的，而且极为常用。

当元素比较多的时候： 

```{r}
y <- 7:103 #复习一下赋值
y
```

注意到了左边方括号中的数字了吗？它们正是所对应的那一行第一个元素的索引。

下面的内容可能有点偏，**可以酌情从这里跳到第\@ref(youyuexing)节。**

#### 复读机`rep()`

```{r}
rep(c(0, 7, 6, 0), 4) # 把[0, 7, 6, 0]重复4遍
```

#### 等差数列: `seq()`

公差确定时：

```{r}
seq(0, 15, 2.5) # 其实是`seq(from = 0, to = 50, by = 5)`的简写
```

长度确定时：

```{r}
 seq(0, 50, length.out = 11) # 其实是`seq(from = 0, to = 50, length.out = 11)`的简写
```

#### 随机数：
 
连续型均匀分布随机数用`runif(n, min, max)`，n是数量，min是最小值，max是最大值。默认min为0，max为1。

```{r}
x_unif <- runif(100000, 40, 60) # 生成100000个40到60之间，连续均匀分布的的随机数
hist(x_unif) # 画直方图
```

正态分布随机数用`rnorm(n, mean, sd)`, 三个参数分别为数量，平均值，标准差。默认mean为0，sd为1。

```{r}
x_norm <- rnorm(100000, 250, 20) # 按照平均值为250，标准差为20的正态分布的概率密度函数生成100000个随机数
hist(x_norm) # 画直方图
```

### 向量的其它操作

#### `sort()`, `rank()`和`order()`

### R向量的优越性 {#youyuexing}

R中的向量（矩阵和数列也是）的各种计算默认都是逐元素 (elementwise)的。比如：

```{r}
x <- c(4, 9, 25)
y <- c(8, 6, 3)
x + y
x * y # 在matlab中这样乘是不行的，要用`.*`，除法也是
sqrt(x)
```

相比于常用的编程语言，省去了for循环；相比于matlab的默认矩阵乘法，逐元素乘法在数据处理中更有用。

## 数据类型 (Data Types)

向量所存储的的数据类型有：

|类型     |含义与说明            |例子                        |
|:--------|:---------------------|:---------------------------|
|numeric  |浮点数向量            |`3`, `0.5`, `sqrt(2)`, `NaN`, `Inf`|
|integer  |整数向量              |`3L`, `100L`                |
|character|字符向量；需被引号包围|`"1"`, `"$"`, `"你好"`      |
|logical  |逻辑向量              |`TRUE`, `FALSE`, `NA`       |
|complex  |复数向量              |`3+5i`, `1i`, `1+0i`        |


通过`class()`函数，可以查看向量的类型。

```{r}
class("早上好")
```

（除此之外，`typeof()`, `mode()`, `storage.mode()`这三个函数的功能与`class()`类似，但有重要的区别；为避免造成困惑，此处不展开讨论）。

## 数学表达和运算

### 数的表达

#### 浮点数

除非指定作为整数（见下），在R中所有的数都被存储为双精度浮点数的格式 (double-precision floating-point format)，其`class`为`numeric`。

```{r}
class(3)
```

这会导致一些有趣的现象，比如$(\sqrt{3})^2 \neq 3$：~~（强迫症患者浑身难受）~~

```{r}
sqrt(3)^2-3
```

浮点数的计算比精确数的计算快很多。如果你是第一次接触浮点数，可能会觉得它不可靠，其实不然。在绝大多数情况下，牺牲的这一点点精度并不会影响计算结果（我们的结果所需要的有效数字一般不会超过10位；只有当两个非常，非常大且数值相近对数字相减才会出现较大的误差）。

`NaN`（非数）和`Inf`（无限大）也是浮点数！

```{r}
class(NaN)
class(Inf)
```

#### 科学计数法

在R中可以使用科学计数法(`AeB`$= A \times 10^B$)，比如：

```{r}
3.1e5
```
```{r}
-1.2e-4+1.1e-5
```

#### 整数

整数的class为`integer`。有两种常见的方法创建整数：
1）在数后面加上`L`；

```{r}
class(2)
class(2L)
```

2）创建数列

```{r}
1:10 #公差为1的整数向量生成器，包含最小值和最大值
class(1:10)
seq(5,50,5) #自定义公差，首项，末项和公差可以不为整数
class(seq(5,50,5)) #因此产生的是一个浮点数向量
seq(5L,50L,5L) #可以强制生成整数
class(seq(5L,50L,5L)) #是�整数没错
```

整数最常见的用处是indexing（索引）。

##### 整数变成浮点数的情况

这一小段讲的比较细，**请酌情直接跳到下一节（\@ref(arithmetic)）。**

整数与整数之前的加，减，乘，求整数商，和求余数计算会得到整数，其他的运算都会得到浮点数，（阶乘(`factorial`)也是，即便现实中不管怎么阶乘都不可能得到非整数）：
```{r include=FALSE}
x <- list(2L+1L, 2L-1L, 2L*3L, 17L%/%3L, 17L%%3L, 1000L/1L, 3L^4L, sqrt(4L), log(exp(5L)),factorial(5L),sin(0L))
for (num in x){
  print(num)
  print(class(num))
}

y <- c(8L/2L, 2L^3L)
```

```{r}
class(2L+1L)
class(2L-1L)
class(2L*3L)
class(17L%/%3L)
class(17L%%3L)
```

```{r}
class(1000L/1L)
class(3L^4L)
class(sqrt(4L))
class(log(exp(5L)))
class(factorial(5L))
```

整数与浮点数之间的运算，显然，全部都会产生浮点数结果，无需举例。

另外一个需要注意的地方是，取整函数\@ref(quzheng)并不会产生整数。如果需要的话，要用`as.integer()`函数。

### 运算 {#arithmetic}

#### 二元运算符号

R中的binary operators（二元运算符）有：

|  符号     |     描述    |
|:---------:|:-----------:|
|   `+`     | 加          |
| `-`       | 减          |
| `*`       | 乘          |
| `/`       | 除以        |
| `^`或`**` | 乘幂        |
|`%/%`      |求整数商，比如`7%%3`$=2$|
|`%%`       |求余数，比如`7%%3`$=1$|

其中求余/求整数商最常见的两个用法是判定一个数的奇偶性，和时间，角度等单位的转换。（后面再详细介绍）。

#### $e^x$和$\log_x{y}$

`exp(x)`便是运算$e^x$。如果想要$e=2.71828...$这个数：

```{r}
exp(1)
```

`log(x, base=y)`便是运算$\log_y{x}$，可以简写成`log(x,y)`（简写需要注意前后顺序，第\@ref(abbr)有解释）。

默认底数为$e$：

```{r}
log(exp(5))
```

有以10和2为底的快捷函数, `log10()`和`log2()`

```{r}
log10(1000)
log2(128)
```

#### 近似数（取整，取小数位，取有效数字）{#quzheng}

注意，取整函数给出的的结果不是整数！

```{r}
class(ceiling(7.4))
```


#### R中自带的数学函数集合

|函数          |描述          |
|:---------------|:-------------|
|`exp(x)`        |$e^x$         |
|`log(x,y)`      |$\log_yx$     |
|`log(x)`        |$\ln(x)$     |
|`sqrt(x)`       |$\sqrt{x}$    |
|`factorial(x)`  |$x!=x\times(x-1)\times(x-2)\ldots\times2\times1$|
|`choose(n,k)`   |$\binom{n}{k}=\frac{n!}{k!(n-k)!}$（二项式系数）|
|`gamma(z)`      |$\Gamma(z)=\int_0^\infty x^{z-1}e^{-x}dx$（[伽马函数](https://en.wikipedia.org/wiki/Gamma_function)）|
|`lgamma(z)`     |$\ln(\Gamma(z))$|
|`floor(x)`, `ceiling(x)`, `trunc(x)`, |取整；见上一小节。|
|`round(x, digits = n)`|四舍五入，保留n个小数位，n默认为0|
|`signif(x,digits = n)`|四舍五入，保留n个有效数字，n默认为6）|
|`sin(x)`, `cos(x)`, `tan(x)`|三角函数|
|`asin(x)`, `acos(x)`, `atan(x)`|反三角函数|
|`sinh(x)`, `cosh(x)`, `tanh(x)`|双曲函数|
|`abs(x)`|$|x|$（取绝对值）|

## 逻辑 {#logical-operation}

### Logical Values（逻辑值）

逻辑值有三个。`TRUE`, `FALSE`和`NA`.

```{r}
class(c(TRUE,FALSE,NA))
```

`TRUE`为真，`FALSE`为假，`NA`为未知（即真假难辨）。

### Logical Operations（逻辑运算）{#logical-operations}

R中常用的关系运算符有：

|符号|描述|
|:--:|:----:|
|`==`  |equal to（等于）|
|`!=`  |equal to（不等于）|
|`<`|less than（小于）|
|`>`|more than（大于）|
|`<=`|less than or equal to（小于等于）|
|`>=`|more than or equal to（大于等于）|

使用关系运算符进行计算，会产生逻辑值作为结果。比如：

```{r}
x <- 5
x != 3 #x等于5，所以“x不等于3”为真
```

有一些其他的运算符或函数也会返回逻辑值，比如

```{r}
7 %in% c(1,4,5,6,7)
```

顾名思义，这个运算符是用来检测一个元素是否在另一个向量中。其它类型的运算符，我在需要用到的时候再讲。

### 逻辑运算详解

#### 逻辑运算符

以下是最常用的三个逻辑运算符。

|符号|描述|
|:--:|:----:|
|`&`|AND（且）|
|`|`|OR（或）|
|`!`|反义符号|

#### 反义符号（`!`）

`!`使`TRUE` `FALSE`颠倒。一般，我们用小括号来包住一个逻辑运算，然后在它的前面加上一个`!`来反转结果，比如

```{r}
!(3 < 4) # 这个例子很简单，反义符号意义不大。后面实操的时候才能领略到它的用处。
```

#### 多个逻辑运算的组合（`&`（且）和`|`（或））

`&`和`|`可以把多个逻辑运算的结果合并成一个逻辑值。

`&`判断是否两边运算结果都为`TRUE`。如果是，才会得到`TRUE`（即一真和一假得到假）。（正统的翻译貌似是“与”，但是我觉得不太与中文语法适配；想想“$x$大于$2$**与**$y$小于$4$”是不是比“$x$大于$2$**且**$y$小于$4$”别扭）

`|`判断两边运算结果是否至少有一个 `TRUE`，如果是，就会得到`TRUE`。

不用死记硬背！其实就是“且”和“或”的逻辑。

用脑子想一下以下三条运算的结果，然后复制代码到R console对答案。

```{r eval=FALSE}
1 == 1 & 1 == 2 & 3 == 3 #即：“1等于1且1等于2且3等于3”，是真还是假？
FALSE | FALSE | TRUE # FALSE/TRUE等价于一个运算结果
!(FALSE | TRUE) & TRUE # 注意反义符号
```

我们可以查看三个逻辑值所有两两通过`&`组和的计算结果（如果你不感兴趣，可以不看方法。这里重点是结果）：

```{r}
vals <- c(TRUE, FALSE, NA) 
names(vals) <- paste('[',as.character(vals),']',sep = '')
outer(vals, vals, "&")
```

可以看到，`FALSE`与任何逻辑值组合，结果都是`FALSE`。这个好理解，因为一旦一个是`FALSE`，那么不可能两边都是`TRUE`. `TRUE & NA`之所以为`NA`（而不是`FALSE`），是因为`NA`的意思是“不能确定真假”，即有可能真也有可能假。因此`TRUE & NA`也无法辨真假。

再来看`|`的组合：

```{r}
outer(vals, vals, "|")
```

可以看到，`TRUE`与任何一个逻辑值组合，都是`TRUE`，而`FALSE | NA`为`NA`。原因一样（因为`NA`的不确定性）。


## 判断和循环（控制流程）

如果你学过其他编程语言，知道判断和循环的作用，只是需要知道在R中的表达，那么请看以下两个例子快速入门，然后跳过本节（如果没学过，请往后面看）：

```{r}
foo <- 1:100 #产生一个[1,2,3,...,99,100]的整数向量。上面讲过。
bar <- vector("numeric")
for (i in foo) {
  if (i %% 2 == 0) {
    bar <- append(bar, i^2)
  } else if (i == 51) {
    break
  }
}
bar
```

```{r}
logi = TRUE
num <- 1
while (num <= 100) {
  if (logi) {
    num = num + 10 # R 不支持 num += 5的简写
    print(num)
    logi = FALSE
  } else {
    num = num + 20
    print(num)
    logi = TRUE
  }
}

```

### `if`, `else`, `else if` 语句

`if`语句长这样：

```
if (something is true/false) {
do something
}
```

其中小括号内为测试的条件，其运算结果需为TRUE或FALSE（关于逻辑值的计算请看第\@ref(logical-operation)节。若运算结果为TRUE，大括号内的语句将会被执行。

注意，不能直接用`x == NA`来判断是否是`NA`，而要用`is.na(x)`

R中没有专门的`elseif`语句，但用`else`加上`if`能实现同样的效果。

## 函数

不像很多其他语言的函数有`value.func()`和`func value`等格式，R中所有函数的通用格式是这样的：

```{}
function(argument1=value1, argument2=value2, ...)
```

比如

```{r}
x1 <- c(5.1,5.2,4.5,5.3,4.3,5.5,5.7)
t.test(x=x1, mu = 4.5)
```

（英语中，“parameter”或“formal argument”二词用于函数定义，“argument”或“actual argument”二词用于调用函数[@Kernighan1988The-C-Programming-La]，中文里分别是“形式参数”和“实际参数”，但是多数场合简称“参数”。）

### 调用函数时的简写 {#abbr}

以`seq`函数为例，通过查看documentation（在console执行`?seq`）可以查看它的所有的参数：

```{}
## Default S3 method:
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)
```

可以看到第一个参数是`from`，第二个是`to`，第三个是`by`，以此类推。因此我们执行`seq(0, 50, 10)`的时候，R会自动理解成`seq(from = 0, to = 50, by = 10)`。而想用指定长度的方法就必须要写清楚是`length.out`等于几。

`length.out`本身也可以简写：

```{r}
seq(0, 25, l = 11)
```

因为参数中只有`length.out`是以`l`开头的，`l`会被理解为`length.out`. 但是这个习惯并不好；自己用用就算了，与别人分享自己的工作时请务必使用标准写法。

### 关于`...`

有时候，你想写的函数可能有数量不定的参数，或是有需要传递给另一个函数的“其它参数”（即本函数不需要的参数），这时候可以在函数定义时加入一个名为`...`的参数，然后用`list()`来读取它们。list是进阶内容，在第\@ref(list)节有说明。

比如我写一个很无聊的函数：

```{r}
my_func <- function(arg1, arg2 = 100, ...){
  other_args <- list(...)
  print(arg1)
  print(arg2)
  print(other_args)
}

my_func("foo", cities = c("崇阳", "Αθήνα", "つがる"), nums = c(3,4,6))
```

`arg1`指定了是`"foo"`（通过[简写](#abbr)），因此第一行印出`"foo"`;  `arg2`未指定，因此使用默认值`100`，印在第二行。`cities`和`nums`在形式参数中没有匹配，因此归为"..."，作为list印在第三行及之后。

## 简易的统计学计算

本小节简要解释了R中的t分布，t检验和$\chi^2$检验。统计学方法并不是本书的重点，因此可以酌情跳到[下一章](#tibble)。

### t分布

众所周知，t分布长这样：

```{r include=FALSE}
library(tidyverse)
```

```{r echo=FALSE}
t.values <- seq(-4.5,4.5,.1)

t.probability <- dt(t.values,df=6)

all <- tibble(val=t.values,prob=t.probability)

cut <- tibble(val=t.values[1:75],prob=t.probability[1:75])

ggplot()+
  geom_line(data=all, aes(x=val,y=prob))+
  geom_area(data=cut,aes(x=val,y=prob))+
  theme_light()+
  labs(x="t",y="P(t≤T)")+
  geom_vline(xintercept = 2.9, linetype="dashed", color='grey')+
  geom_text(aes(x=3,y=0.1, label="T"))+
  scale_y_continuous(expand = c(0,0)) + scale_x_continuous(expand = c(0,0))
```

阴影面积为$P(t<T)$，虚线对应的$t$为$T$.
`qt()`可以把$P(t≤T)$的值转化成$T$,`pt()`则相反。

假设你需要算一个confidence interval（置信区间），confidence level（置信等级）为$95\%$，即$\alpha=0.05$，degrees of freedom(自由度)为$12$，那么怎么算$t^*$呢？

```{r}
qt(0.975, df = 12)
```

为什么是$0.975$？因为你要把$0.05$分到左右两边，所对应的t*就等同于t分布中，$P(t ≤ T) = 0.975$时T的值。

再举一个例子，你在做t检验，双尾的，算出来$t=1.345$，自由度是$15$，那么$p$值怎么算呢？

```{r}
p <- (1-(pt(2.2, df = 15)))*2
p
```

其中`pt(2.2, df = 15)`算出阴影面积（$P(t≤T)$的值），1减去它再乘以2就是对应的双尾t检验的$p$值。

### z分布

没有z分布专门的函数。可以直接用t分布代替，把`df`调到很大（比如`999999`）就行了。比如我们试一下$95\%$置信区间所对应的$z*$：

```{r}
qt(0.975,9999999)
```

（果然是$1.96$）

### t检验

t检验分为以下几种：

- One sample t test （单样本）
- paired t test（配对）
- Two sample...（双样本）
  - Unequal variance (Welch) t test（不等方差）
  - Equal variance t test（等方差）
  
在R中做t检验，很简单，以上这些t检验，都是用`t.test` 这个函数去完成。

以单样本为例：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
t.test(x, mu = 2.31)
```

可以看到$p=0.06766$。

R的默认是双尾检验，你也可以设置成单尾的：

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)

t.test(x, mu = 2.31, alternative = "less") # 检验是否*less* than μ
```

$p$值瞬间减半。

双样本/配对:

```{r}
x <- c(2.23,2.24,2.34,2.31,2.35,2.27,2.29,2.26,2.25,2.21,2.29,2.34,2.32)
y <- c(2.27,2.29,2.37,2.38,2.39,2.25,2.39,2.16,2.55,2.81,2.19,2.44,2.22)

t.test(x, y)
```

R的默认是non-paired, unequal variance，你可以通过增加`paired = TRUE`，`var.equal = TRUE`这两个参数来改变它。

```{r}
t.test(x, y, paired = TRUE)
```

### $\chi^2$ 检验

$\chi^2$检验有两种，goodness of fit test（适配度检验）和contigency table test/test of independence（列联表分析/独立性检验）。都是用`chisq.test()`函数去完成。

#### 适配度检验

假设我们制造了一个有问题的骰子，使1至6朝上的概率分别为：

```{r}
expected_probs <- c(0.05, 0.1, 0.15, 0.2, 0.2, 0.3)
```

然后我们投掷了100次，实际1至6朝上的次数分别为：

```{r}
observed_vals <- c(6, 9, 14, 24, 18, 29)
```

通过`chisq.test()`，检验实际的1至6朝上概率是否与预期有偏差：

```{r}
chisq.test(observed_vals, p = expected_probs) # 参数p是指概率
```

p值很大（远大于0.05），因此结论是骰子各面朝上的概率符合预期。

如果不指定p参数，默认为检测是否所有值相等（即骰子的所有面朝上的概率相等）：

```{r}
chisq.test(observed_vals)
```

这时p值小于0.05. 得出“骰子各面朝上的概率不等”的结论。

#### 列联表分析/独立性检验

假设我们有一组不同年级的学生参加社团的人数数据：

```{r}
(社团参与 <- matrix(c(28,36,40,40,32,33,38,29,36), nrow = 3, dimnames = list(c("一年级", "二年级", "三年级"), c("棒球", "足球", "网球"))))
```

我们想知道社团的参与，与所在年级是否是独立事件：

```{r}
chisq.test(社团参与)
```

p值不小于0.05，无法拒绝“社团的参与，与所在年级是独立事件”的虚无假设。

彩蛋：用R代码实现卡方分布的概率密度函数的图像：

```{r}
#其实还可以更精简，但是为了易读性不得不牺牲一点精简度。
Z <- matrix(rep(rnorm(1000000), 6), nrow = 6)^2

X <- Z^2

Q <- matrix(nrow = 6, ncol = 1000000)

for (i in (1+1):6) {
  Q[1,] = Z[1,]
  Q[i,] = Q[(i-1),] + Z[i,]
}

plot(NULL, xlim=c(0.23,6), ylim = c(0,1),
     main = expression(paste('X ~ ', chi^'2', '(k)')), 
     xlab = "x", 
     ylab= expression(f[k]*'(x)')
    )
colors <- c('blue', 'black', 'red', 'green', 'gray', 'orange')
for (i in 1:6) {
  lines(density(Q[i,]),
        col=colors[i],
        lwd=2)
}
legend('topright',c('k=1','k=2','k=3','k=4','k=5','k=6'),
       fill = colors)
```


#### 其它

R自带的检验还有`Box.test()`, `PP.test()`, `ansari.test()`, `bartlett.test()`, `wilcox.test`等共31种。查看帮助文件或利用网络资源以了解更多/